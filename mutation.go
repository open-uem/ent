// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/open-uem/ent/agent"
	"github.com/open-uem/ent/antivirus"
	"github.com/open-uem/ent/app"
	"github.com/open-uem/ent/authentication"
	"github.com/open-uem/ent/certificate"
	"github.com/open-uem/ent/computer"
	"github.com/open-uem/ent/deployment"
	"github.com/open-uem/ent/logicaldisk"
	"github.com/open-uem/ent/memoryslot"
	"github.com/open-uem/ent/metadata"
	"github.com/open-uem/ent/monitor"
	"github.com/open-uem/ent/netbird"
	"github.com/open-uem/ent/netbirdsettings"
	"github.com/open-uem/ent/networkadapter"
	"github.com/open-uem/ent/operatingsystem"
	"github.com/open-uem/ent/orgmetadata"
	"github.com/open-uem/ent/physicaldisk"
	"github.com/open-uem/ent/predicate"
	"github.com/open-uem/ent/printer"
	"github.com/open-uem/ent/profile"
	"github.com/open-uem/ent/profileissue"
	"github.com/open-uem/ent/recoverycode"
	"github.com/open-uem/ent/release"
	"github.com/open-uem/ent/revocation"
	"github.com/open-uem/ent/rustdesk"
	"github.com/open-uem/ent/server"
	"github.com/open-uem/ent/sessions"
	"github.com/open-uem/ent/settings"
	"github.com/open-uem/ent/share"
	"github.com/open-uem/ent/site"
	"github.com/open-uem/ent/systemupdate"
	"github.com/open-uem/ent/tag"
	"github.com/open-uem/ent/task"
	"github.com/open-uem/ent/tenant"
	"github.com/open-uem/ent/update"
	"github.com/open-uem/ent/user"
	"github.com/open-uem/ent/wingetconfigexclusion"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgent                 = "Agent"
	TypeAntivirus             = "Antivirus"
	TypeApp                   = "App"
	TypeAuthentication        = "Authentication"
	TypeCertificate           = "Certificate"
	TypeComputer              = "Computer"
	TypeDeployment            = "Deployment"
	TypeLogicalDisk           = "LogicalDisk"
	TypeMemorySlot            = "MemorySlot"
	TypeMetadata              = "Metadata"
	TypeMonitor               = "Monitor"
	TypeNetbird               = "Netbird"
	TypeNetbirdSettings       = "NetbirdSettings"
	TypeNetworkAdapter        = "NetworkAdapter"
	TypeOperatingSystem       = "OperatingSystem"
	TypeOrgMetadata           = "OrgMetadata"
	TypePhysicalDisk          = "PhysicalDisk"
	TypePrinter               = "Printer"
	TypeProfile               = "Profile"
	TypeProfileIssue          = "ProfileIssue"
	TypeRecoveryCode          = "RecoveryCode"
	TypeRelease               = "Release"
	TypeRevocation            = "Revocation"
	TypeRustdesk              = "Rustdesk"
	TypeServer                = "Server"
	TypeSessions              = "Sessions"
	TypeSettings              = "Settings"
	TypeShare                 = "Share"
	TypeSite                  = "Site"
	TypeSystemUpdate          = "SystemUpdate"
	TypeTag                   = "Tag"
	TypeTask                  = "Task"
	TypeTenant                = "Tenant"
	TypeUpdate                = "Update"
	TypeUser                  = "User"
	TypeWingetConfigExclusion = "WingetConfigExclusion"
)

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	os                         *string
	hostname                   *string
	ip                         *string
	mac                        *string
	first_contact              *time.Time
	last_contact               *time.Time
	vnc                        *string
	notes                      *string
	update_task_status         *string
	update_task_description    *string
	update_task_result         *string
	update_task_execution      *time.Time
	update_task_version        *string
	vnc_proxy_port             *string
	sftp_port                  *string
	agent_status               *agent.AgentStatus
	certificate_ready          *bool
	restart_required           *bool
	is_remote                  *bool
	debug_mode                 *bool
	sftp_service               *bool
	remote_assistance          *bool
	settings_modified          *time.Time
	description                *string
	nickname                   *string
	endpoint_type              *agent.EndpointType
	has_rustdesk               *bool
	is_wayland                 *bool
	is_flatpak_rustdesk        *bool
	wan                        *string
	clearedFields              map[string]struct{}
	computer                   *int
	clearedcomputer            bool
	operatingsystem            *int
	clearedoperatingsystem     bool
	systemupdate               *int
	clearedsystemupdate        bool
	antivirus                  *int
	clearedantivirus           bool
	logicaldisks               map[int]struct{}
	removedlogicaldisks        map[int]struct{}
	clearedlogicaldisks        bool
	apps                       map[int]struct{}
	removedapps                map[int]struct{}
	clearedapps                bool
	monitors                   map[int]struct{}
	removedmonitors            map[int]struct{}
	clearedmonitors            bool
	shares                     map[int]struct{}
	removedshares              map[int]struct{}
	clearedshares              bool
	printers                   map[int]struct{}
	removedprinters            map[int]struct{}
	clearedprinters            bool
	networkadapters            map[int]struct{}
	removednetworkadapters     map[int]struct{}
	clearednetworkadapters     bool
	deployments                map[int]struct{}
	removeddeployments         map[int]struct{}
	cleareddeployments         bool
	updates                    map[int]struct{}
	removedupdates             map[int]struct{}
	clearedupdates             bool
	tags                       map[int]struct{}
	removedtags                map[int]struct{}
	clearedtags                bool
	metadata                   map[int]struct{}
	removedmetadata            map[int]struct{}
	clearedmetadata            bool
	wingetcfgexclusions        map[int]struct{}
	removedwingetcfgexclusions map[int]struct{}
	clearedwingetcfgexclusions bool
	memoryslots                map[int]struct{}
	removedmemoryslots         map[int]struct{}
	clearedmemoryslots         bool
	release                    *int
	clearedrelease             bool
	profileissue               map[int]struct{}
	removedprofileissue        map[int]struct{}
	clearedprofileissue        bool
	site                       map[int]struct{}
	removedsite                map[int]struct{}
	clearedsite                bool
	physicaldisks              map[int]struct{}
	removedphysicaldisks       map[int]struct{}
	clearedphysicaldisks       bool
	netbird                    *int
	clearednetbird             bool
	done                       bool
	oldValue                   func(context.Context) (*Agent, error)
	predicates                 []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id string) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Agent entities.
func (m *AgentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOs sets the "os" field.
func (m *AgentMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *AgentMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *AgentMutation) ResetOs() {
	m.os = nil
}

// SetHostname sets the "hostname" field.
func (m *AgentMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *AgentMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *AgentMutation) ResetHostname() {
	m.hostname = nil
}

// SetIP sets the "ip" field.
func (m *AgentMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AgentMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AgentMutation) ResetIP() {
	m.ip = nil
}

// SetMAC sets the "mac" field.
func (m *AgentMutation) SetMAC(s string) {
	m.mac = &s
}

// MAC returns the value of the "mac" field in the mutation.
func (m *AgentMutation) MAC() (r string, exists bool) {
	v := m.mac
	if v == nil {
		return
	}
	return *v, true
}

// OldMAC returns the old "mac" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldMAC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMAC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMAC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMAC: %w", err)
	}
	return oldValue.MAC, nil
}

// ResetMAC resets all changes to the "mac" field.
func (m *AgentMutation) ResetMAC() {
	m.mac = nil
}

// SetFirstContact sets the "first_contact" field.
func (m *AgentMutation) SetFirstContact(t time.Time) {
	m.first_contact = &t
}

// FirstContact returns the value of the "first_contact" field in the mutation.
func (m *AgentMutation) FirstContact() (r time.Time, exists bool) {
	v := m.first_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstContact returns the old "first_contact" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldFirstContact(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstContact: %w", err)
	}
	return oldValue.FirstContact, nil
}

// ClearFirstContact clears the value of the "first_contact" field.
func (m *AgentMutation) ClearFirstContact() {
	m.first_contact = nil
	m.clearedFields[agent.FieldFirstContact] = struct{}{}
}

// FirstContactCleared returns if the "first_contact" field was cleared in this mutation.
func (m *AgentMutation) FirstContactCleared() bool {
	_, ok := m.clearedFields[agent.FieldFirstContact]
	return ok
}

// ResetFirstContact resets all changes to the "first_contact" field.
func (m *AgentMutation) ResetFirstContact() {
	m.first_contact = nil
	delete(m.clearedFields, agent.FieldFirstContact)
}

// SetLastContact sets the "last_contact" field.
func (m *AgentMutation) SetLastContact(t time.Time) {
	m.last_contact = &t
}

// LastContact returns the value of the "last_contact" field in the mutation.
func (m *AgentMutation) LastContact() (r time.Time, exists bool) {
	v := m.last_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldLastContact returns the old "last_contact" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldLastContact(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastContact: %w", err)
	}
	return oldValue.LastContact, nil
}

// ClearLastContact clears the value of the "last_contact" field.
func (m *AgentMutation) ClearLastContact() {
	m.last_contact = nil
	m.clearedFields[agent.FieldLastContact] = struct{}{}
}

// LastContactCleared returns if the "last_contact" field was cleared in this mutation.
func (m *AgentMutation) LastContactCleared() bool {
	_, ok := m.clearedFields[agent.FieldLastContact]
	return ok
}

// ResetLastContact resets all changes to the "last_contact" field.
func (m *AgentMutation) ResetLastContact() {
	m.last_contact = nil
	delete(m.clearedFields, agent.FieldLastContact)
}

// SetVnc sets the "vnc" field.
func (m *AgentMutation) SetVnc(s string) {
	m.vnc = &s
}

// Vnc returns the value of the "vnc" field in the mutation.
func (m *AgentMutation) Vnc() (r string, exists bool) {
	v := m.vnc
	if v == nil {
		return
	}
	return *v, true
}

// OldVnc returns the old "vnc" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldVnc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVnc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVnc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVnc: %w", err)
	}
	return oldValue.Vnc, nil
}

// ClearVnc clears the value of the "vnc" field.
func (m *AgentMutation) ClearVnc() {
	m.vnc = nil
	m.clearedFields[agent.FieldVnc] = struct{}{}
}

// VncCleared returns if the "vnc" field was cleared in this mutation.
func (m *AgentMutation) VncCleared() bool {
	_, ok := m.clearedFields[agent.FieldVnc]
	return ok
}

// ResetVnc resets all changes to the "vnc" field.
func (m *AgentMutation) ResetVnc() {
	m.vnc = nil
	delete(m.clearedFields, agent.FieldVnc)
}

// SetNotes sets the "notes" field.
func (m *AgentMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *AgentMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *AgentMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[agent.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *AgentMutation) NotesCleared() bool {
	_, ok := m.clearedFields[agent.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *AgentMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, agent.FieldNotes)
}

// SetUpdateTaskStatus sets the "update_task_status" field.
func (m *AgentMutation) SetUpdateTaskStatus(s string) {
	m.update_task_status = &s
}

// UpdateTaskStatus returns the value of the "update_task_status" field in the mutation.
func (m *AgentMutation) UpdateTaskStatus() (r string, exists bool) {
	v := m.update_task_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTaskStatus returns the old "update_task_status" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdateTaskStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTaskStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTaskStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTaskStatus: %w", err)
	}
	return oldValue.UpdateTaskStatus, nil
}

// ClearUpdateTaskStatus clears the value of the "update_task_status" field.
func (m *AgentMutation) ClearUpdateTaskStatus() {
	m.update_task_status = nil
	m.clearedFields[agent.FieldUpdateTaskStatus] = struct{}{}
}

// UpdateTaskStatusCleared returns if the "update_task_status" field was cleared in this mutation.
func (m *AgentMutation) UpdateTaskStatusCleared() bool {
	_, ok := m.clearedFields[agent.FieldUpdateTaskStatus]
	return ok
}

// ResetUpdateTaskStatus resets all changes to the "update_task_status" field.
func (m *AgentMutation) ResetUpdateTaskStatus() {
	m.update_task_status = nil
	delete(m.clearedFields, agent.FieldUpdateTaskStatus)
}

// SetUpdateTaskDescription sets the "update_task_description" field.
func (m *AgentMutation) SetUpdateTaskDescription(s string) {
	m.update_task_description = &s
}

// UpdateTaskDescription returns the value of the "update_task_description" field in the mutation.
func (m *AgentMutation) UpdateTaskDescription() (r string, exists bool) {
	v := m.update_task_description
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTaskDescription returns the old "update_task_description" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdateTaskDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTaskDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTaskDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTaskDescription: %w", err)
	}
	return oldValue.UpdateTaskDescription, nil
}

// ClearUpdateTaskDescription clears the value of the "update_task_description" field.
func (m *AgentMutation) ClearUpdateTaskDescription() {
	m.update_task_description = nil
	m.clearedFields[agent.FieldUpdateTaskDescription] = struct{}{}
}

// UpdateTaskDescriptionCleared returns if the "update_task_description" field was cleared in this mutation.
func (m *AgentMutation) UpdateTaskDescriptionCleared() bool {
	_, ok := m.clearedFields[agent.FieldUpdateTaskDescription]
	return ok
}

// ResetUpdateTaskDescription resets all changes to the "update_task_description" field.
func (m *AgentMutation) ResetUpdateTaskDescription() {
	m.update_task_description = nil
	delete(m.clearedFields, agent.FieldUpdateTaskDescription)
}

// SetUpdateTaskResult sets the "update_task_result" field.
func (m *AgentMutation) SetUpdateTaskResult(s string) {
	m.update_task_result = &s
}

// UpdateTaskResult returns the value of the "update_task_result" field in the mutation.
func (m *AgentMutation) UpdateTaskResult() (r string, exists bool) {
	v := m.update_task_result
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTaskResult returns the old "update_task_result" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdateTaskResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTaskResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTaskResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTaskResult: %w", err)
	}
	return oldValue.UpdateTaskResult, nil
}

// ClearUpdateTaskResult clears the value of the "update_task_result" field.
func (m *AgentMutation) ClearUpdateTaskResult() {
	m.update_task_result = nil
	m.clearedFields[agent.FieldUpdateTaskResult] = struct{}{}
}

// UpdateTaskResultCleared returns if the "update_task_result" field was cleared in this mutation.
func (m *AgentMutation) UpdateTaskResultCleared() bool {
	_, ok := m.clearedFields[agent.FieldUpdateTaskResult]
	return ok
}

// ResetUpdateTaskResult resets all changes to the "update_task_result" field.
func (m *AgentMutation) ResetUpdateTaskResult() {
	m.update_task_result = nil
	delete(m.clearedFields, agent.FieldUpdateTaskResult)
}

// SetUpdateTaskExecution sets the "update_task_execution" field.
func (m *AgentMutation) SetUpdateTaskExecution(t time.Time) {
	m.update_task_execution = &t
}

// UpdateTaskExecution returns the value of the "update_task_execution" field in the mutation.
func (m *AgentMutation) UpdateTaskExecution() (r time.Time, exists bool) {
	v := m.update_task_execution
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTaskExecution returns the old "update_task_execution" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdateTaskExecution(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTaskExecution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTaskExecution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTaskExecution: %w", err)
	}
	return oldValue.UpdateTaskExecution, nil
}

// ClearUpdateTaskExecution clears the value of the "update_task_execution" field.
func (m *AgentMutation) ClearUpdateTaskExecution() {
	m.update_task_execution = nil
	m.clearedFields[agent.FieldUpdateTaskExecution] = struct{}{}
}

// UpdateTaskExecutionCleared returns if the "update_task_execution" field was cleared in this mutation.
func (m *AgentMutation) UpdateTaskExecutionCleared() bool {
	_, ok := m.clearedFields[agent.FieldUpdateTaskExecution]
	return ok
}

// ResetUpdateTaskExecution resets all changes to the "update_task_execution" field.
func (m *AgentMutation) ResetUpdateTaskExecution() {
	m.update_task_execution = nil
	delete(m.clearedFields, agent.FieldUpdateTaskExecution)
}

// SetUpdateTaskVersion sets the "update_task_version" field.
func (m *AgentMutation) SetUpdateTaskVersion(s string) {
	m.update_task_version = &s
}

// UpdateTaskVersion returns the value of the "update_task_version" field in the mutation.
func (m *AgentMutation) UpdateTaskVersion() (r string, exists bool) {
	v := m.update_task_version
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTaskVersion returns the old "update_task_version" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdateTaskVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTaskVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTaskVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTaskVersion: %w", err)
	}
	return oldValue.UpdateTaskVersion, nil
}

// ClearUpdateTaskVersion clears the value of the "update_task_version" field.
func (m *AgentMutation) ClearUpdateTaskVersion() {
	m.update_task_version = nil
	m.clearedFields[agent.FieldUpdateTaskVersion] = struct{}{}
}

// UpdateTaskVersionCleared returns if the "update_task_version" field was cleared in this mutation.
func (m *AgentMutation) UpdateTaskVersionCleared() bool {
	_, ok := m.clearedFields[agent.FieldUpdateTaskVersion]
	return ok
}

// ResetUpdateTaskVersion resets all changes to the "update_task_version" field.
func (m *AgentMutation) ResetUpdateTaskVersion() {
	m.update_task_version = nil
	delete(m.clearedFields, agent.FieldUpdateTaskVersion)
}

// SetVncProxyPort sets the "vnc_proxy_port" field.
func (m *AgentMutation) SetVncProxyPort(s string) {
	m.vnc_proxy_port = &s
}

// VncProxyPort returns the value of the "vnc_proxy_port" field in the mutation.
func (m *AgentMutation) VncProxyPort() (r string, exists bool) {
	v := m.vnc_proxy_port
	if v == nil {
		return
	}
	return *v, true
}

// OldVncProxyPort returns the old "vnc_proxy_port" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldVncProxyPort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVncProxyPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVncProxyPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVncProxyPort: %w", err)
	}
	return oldValue.VncProxyPort, nil
}

// ClearVncProxyPort clears the value of the "vnc_proxy_port" field.
func (m *AgentMutation) ClearVncProxyPort() {
	m.vnc_proxy_port = nil
	m.clearedFields[agent.FieldVncProxyPort] = struct{}{}
}

// VncProxyPortCleared returns if the "vnc_proxy_port" field was cleared in this mutation.
func (m *AgentMutation) VncProxyPortCleared() bool {
	_, ok := m.clearedFields[agent.FieldVncProxyPort]
	return ok
}

// ResetVncProxyPort resets all changes to the "vnc_proxy_port" field.
func (m *AgentMutation) ResetVncProxyPort() {
	m.vnc_proxy_port = nil
	delete(m.clearedFields, agent.FieldVncProxyPort)
}

// SetSftpPort sets the "sftp_port" field.
func (m *AgentMutation) SetSftpPort(s string) {
	m.sftp_port = &s
}

// SftpPort returns the value of the "sftp_port" field in the mutation.
func (m *AgentMutation) SftpPort() (r string, exists bool) {
	v := m.sftp_port
	if v == nil {
		return
	}
	return *v, true
}

// OldSftpPort returns the old "sftp_port" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSftpPort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSftpPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSftpPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSftpPort: %w", err)
	}
	return oldValue.SftpPort, nil
}

// ClearSftpPort clears the value of the "sftp_port" field.
func (m *AgentMutation) ClearSftpPort() {
	m.sftp_port = nil
	m.clearedFields[agent.FieldSftpPort] = struct{}{}
}

// SftpPortCleared returns if the "sftp_port" field was cleared in this mutation.
func (m *AgentMutation) SftpPortCleared() bool {
	_, ok := m.clearedFields[agent.FieldSftpPort]
	return ok
}

// ResetSftpPort resets all changes to the "sftp_port" field.
func (m *AgentMutation) ResetSftpPort() {
	m.sftp_port = nil
	delete(m.clearedFields, agent.FieldSftpPort)
}

// SetAgentStatus sets the "agent_status" field.
func (m *AgentMutation) SetAgentStatus(as agent.AgentStatus) {
	m.agent_status = &as
}

// AgentStatus returns the value of the "agent_status" field in the mutation.
func (m *AgentMutation) AgentStatus() (r agent.AgentStatus, exists bool) {
	v := m.agent_status
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentStatus returns the old "agent_status" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldAgentStatus(ctx context.Context) (v agent.AgentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentStatus: %w", err)
	}
	return oldValue.AgentStatus, nil
}

// ClearAgentStatus clears the value of the "agent_status" field.
func (m *AgentMutation) ClearAgentStatus() {
	m.agent_status = nil
	m.clearedFields[agent.FieldAgentStatus] = struct{}{}
}

// AgentStatusCleared returns if the "agent_status" field was cleared in this mutation.
func (m *AgentMutation) AgentStatusCleared() bool {
	_, ok := m.clearedFields[agent.FieldAgentStatus]
	return ok
}

// ResetAgentStatus resets all changes to the "agent_status" field.
func (m *AgentMutation) ResetAgentStatus() {
	m.agent_status = nil
	delete(m.clearedFields, agent.FieldAgentStatus)
}

// SetCertificateReady sets the "certificate_ready" field.
func (m *AgentMutation) SetCertificateReady(b bool) {
	m.certificate_ready = &b
}

// CertificateReady returns the value of the "certificate_ready" field in the mutation.
func (m *AgentMutation) CertificateReady() (r bool, exists bool) {
	v := m.certificate_ready
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateReady returns the old "certificate_ready" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCertificateReady(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateReady is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateReady requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateReady: %w", err)
	}
	return oldValue.CertificateReady, nil
}

// ClearCertificateReady clears the value of the "certificate_ready" field.
func (m *AgentMutation) ClearCertificateReady() {
	m.certificate_ready = nil
	m.clearedFields[agent.FieldCertificateReady] = struct{}{}
}

// CertificateReadyCleared returns if the "certificate_ready" field was cleared in this mutation.
func (m *AgentMutation) CertificateReadyCleared() bool {
	_, ok := m.clearedFields[agent.FieldCertificateReady]
	return ok
}

// ResetCertificateReady resets all changes to the "certificate_ready" field.
func (m *AgentMutation) ResetCertificateReady() {
	m.certificate_ready = nil
	delete(m.clearedFields, agent.FieldCertificateReady)
}

// SetRestartRequired sets the "restart_required" field.
func (m *AgentMutation) SetRestartRequired(b bool) {
	m.restart_required = &b
}

// RestartRequired returns the value of the "restart_required" field in the mutation.
func (m *AgentMutation) RestartRequired() (r bool, exists bool) {
	v := m.restart_required
	if v == nil {
		return
	}
	return *v, true
}

// OldRestartRequired returns the old "restart_required" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldRestartRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRestartRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRestartRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRestartRequired: %w", err)
	}
	return oldValue.RestartRequired, nil
}

// ClearRestartRequired clears the value of the "restart_required" field.
func (m *AgentMutation) ClearRestartRequired() {
	m.restart_required = nil
	m.clearedFields[agent.FieldRestartRequired] = struct{}{}
}

// RestartRequiredCleared returns if the "restart_required" field was cleared in this mutation.
func (m *AgentMutation) RestartRequiredCleared() bool {
	_, ok := m.clearedFields[agent.FieldRestartRequired]
	return ok
}

// ResetRestartRequired resets all changes to the "restart_required" field.
func (m *AgentMutation) ResetRestartRequired() {
	m.restart_required = nil
	delete(m.clearedFields, agent.FieldRestartRequired)
}

// SetIsRemote sets the "is_remote" field.
func (m *AgentMutation) SetIsRemote(b bool) {
	m.is_remote = &b
}

// IsRemote returns the value of the "is_remote" field in the mutation.
func (m *AgentMutation) IsRemote() (r bool, exists bool) {
	v := m.is_remote
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRemote returns the old "is_remote" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIsRemote(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRemote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRemote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRemote: %w", err)
	}
	return oldValue.IsRemote, nil
}

// ClearIsRemote clears the value of the "is_remote" field.
func (m *AgentMutation) ClearIsRemote() {
	m.is_remote = nil
	m.clearedFields[agent.FieldIsRemote] = struct{}{}
}

// IsRemoteCleared returns if the "is_remote" field was cleared in this mutation.
func (m *AgentMutation) IsRemoteCleared() bool {
	_, ok := m.clearedFields[agent.FieldIsRemote]
	return ok
}

// ResetIsRemote resets all changes to the "is_remote" field.
func (m *AgentMutation) ResetIsRemote() {
	m.is_remote = nil
	delete(m.clearedFields, agent.FieldIsRemote)
}

// SetDebugMode sets the "debug_mode" field.
func (m *AgentMutation) SetDebugMode(b bool) {
	m.debug_mode = &b
}

// DebugMode returns the value of the "debug_mode" field in the mutation.
func (m *AgentMutation) DebugMode() (r bool, exists bool) {
	v := m.debug_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldDebugMode returns the old "debug_mode" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDebugMode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDebugMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDebugMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDebugMode: %w", err)
	}
	return oldValue.DebugMode, nil
}

// ClearDebugMode clears the value of the "debug_mode" field.
func (m *AgentMutation) ClearDebugMode() {
	m.debug_mode = nil
	m.clearedFields[agent.FieldDebugMode] = struct{}{}
}

// DebugModeCleared returns if the "debug_mode" field was cleared in this mutation.
func (m *AgentMutation) DebugModeCleared() bool {
	_, ok := m.clearedFields[agent.FieldDebugMode]
	return ok
}

// ResetDebugMode resets all changes to the "debug_mode" field.
func (m *AgentMutation) ResetDebugMode() {
	m.debug_mode = nil
	delete(m.clearedFields, agent.FieldDebugMode)
}

// SetSftpService sets the "sftp_service" field.
func (m *AgentMutation) SetSftpService(b bool) {
	m.sftp_service = &b
}

// SftpService returns the value of the "sftp_service" field in the mutation.
func (m *AgentMutation) SftpService() (r bool, exists bool) {
	v := m.sftp_service
	if v == nil {
		return
	}
	return *v, true
}

// OldSftpService returns the old "sftp_service" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSftpService(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSftpService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSftpService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSftpService: %w", err)
	}
	return oldValue.SftpService, nil
}

// ClearSftpService clears the value of the "sftp_service" field.
func (m *AgentMutation) ClearSftpService() {
	m.sftp_service = nil
	m.clearedFields[agent.FieldSftpService] = struct{}{}
}

// SftpServiceCleared returns if the "sftp_service" field was cleared in this mutation.
func (m *AgentMutation) SftpServiceCleared() bool {
	_, ok := m.clearedFields[agent.FieldSftpService]
	return ok
}

// ResetSftpService resets all changes to the "sftp_service" field.
func (m *AgentMutation) ResetSftpService() {
	m.sftp_service = nil
	delete(m.clearedFields, agent.FieldSftpService)
}

// SetRemoteAssistance sets the "remote_assistance" field.
func (m *AgentMutation) SetRemoteAssistance(b bool) {
	m.remote_assistance = &b
}

// RemoteAssistance returns the value of the "remote_assistance" field in the mutation.
func (m *AgentMutation) RemoteAssistance() (r bool, exists bool) {
	v := m.remote_assistance
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteAssistance returns the old "remote_assistance" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldRemoteAssistance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteAssistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteAssistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteAssistance: %w", err)
	}
	return oldValue.RemoteAssistance, nil
}

// ClearRemoteAssistance clears the value of the "remote_assistance" field.
func (m *AgentMutation) ClearRemoteAssistance() {
	m.remote_assistance = nil
	m.clearedFields[agent.FieldRemoteAssistance] = struct{}{}
}

// RemoteAssistanceCleared returns if the "remote_assistance" field was cleared in this mutation.
func (m *AgentMutation) RemoteAssistanceCleared() bool {
	_, ok := m.clearedFields[agent.FieldRemoteAssistance]
	return ok
}

// ResetRemoteAssistance resets all changes to the "remote_assistance" field.
func (m *AgentMutation) ResetRemoteAssistance() {
	m.remote_assistance = nil
	delete(m.clearedFields, agent.FieldRemoteAssistance)
}

// SetSettingsModified sets the "settings_modified" field.
func (m *AgentMutation) SetSettingsModified(t time.Time) {
	m.settings_modified = &t
}

// SettingsModified returns the value of the "settings_modified" field in the mutation.
func (m *AgentMutation) SettingsModified() (r time.Time, exists bool) {
	v := m.settings_modified
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingsModified returns the old "settings_modified" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSettingsModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingsModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingsModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingsModified: %w", err)
	}
	return oldValue.SettingsModified, nil
}

// ClearSettingsModified clears the value of the "settings_modified" field.
func (m *AgentMutation) ClearSettingsModified() {
	m.settings_modified = nil
	m.clearedFields[agent.FieldSettingsModified] = struct{}{}
}

// SettingsModifiedCleared returns if the "settings_modified" field was cleared in this mutation.
func (m *AgentMutation) SettingsModifiedCleared() bool {
	_, ok := m.clearedFields[agent.FieldSettingsModified]
	return ok
}

// ResetSettingsModified resets all changes to the "settings_modified" field.
func (m *AgentMutation) ResetSettingsModified() {
	m.settings_modified = nil
	delete(m.clearedFields, agent.FieldSettingsModified)
}

// SetDescription sets the "description" field.
func (m *AgentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AgentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AgentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[agent.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AgentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[agent.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AgentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, agent.FieldDescription)
}

// SetNickname sets the "nickname" field.
func (m *AgentMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AgentMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *AgentMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[agent.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *AgentMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[agent.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AgentMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, agent.FieldNickname)
}

// SetEndpointType sets the "endpoint_type" field.
func (m *AgentMutation) SetEndpointType(at agent.EndpointType) {
	m.endpoint_type = &at
}

// EndpointType returns the value of the "endpoint_type" field in the mutation.
func (m *AgentMutation) EndpointType() (r agent.EndpointType, exists bool) {
	v := m.endpoint_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpointType returns the old "endpoint_type" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldEndpointType(ctx context.Context) (v agent.EndpointType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpointType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpointType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpointType: %w", err)
	}
	return oldValue.EndpointType, nil
}

// ClearEndpointType clears the value of the "endpoint_type" field.
func (m *AgentMutation) ClearEndpointType() {
	m.endpoint_type = nil
	m.clearedFields[agent.FieldEndpointType] = struct{}{}
}

// EndpointTypeCleared returns if the "endpoint_type" field was cleared in this mutation.
func (m *AgentMutation) EndpointTypeCleared() bool {
	_, ok := m.clearedFields[agent.FieldEndpointType]
	return ok
}

// ResetEndpointType resets all changes to the "endpoint_type" field.
func (m *AgentMutation) ResetEndpointType() {
	m.endpoint_type = nil
	delete(m.clearedFields, agent.FieldEndpointType)
}

// SetHasRustdesk sets the "has_rustdesk" field.
func (m *AgentMutation) SetHasRustdesk(b bool) {
	m.has_rustdesk = &b
}

// HasRustdesk returns the value of the "has_rustdesk" field in the mutation.
func (m *AgentMutation) HasRustdesk() (r bool, exists bool) {
	v := m.has_rustdesk
	if v == nil {
		return
	}
	return *v, true
}

// OldHasRustdesk returns the old "has_rustdesk" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldHasRustdesk(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasRustdesk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasRustdesk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasRustdesk: %w", err)
	}
	return oldValue.HasRustdesk, nil
}

// ClearHasRustdesk clears the value of the "has_rustdesk" field.
func (m *AgentMutation) ClearHasRustdesk() {
	m.has_rustdesk = nil
	m.clearedFields[agent.FieldHasRustdesk] = struct{}{}
}

// HasRustdeskCleared returns if the "has_rustdesk" field was cleared in this mutation.
func (m *AgentMutation) HasRustdeskCleared() bool {
	_, ok := m.clearedFields[agent.FieldHasRustdesk]
	return ok
}

// ResetHasRustdesk resets all changes to the "has_rustdesk" field.
func (m *AgentMutation) ResetHasRustdesk() {
	m.has_rustdesk = nil
	delete(m.clearedFields, agent.FieldHasRustdesk)
}

// SetIsWayland sets the "is_wayland" field.
func (m *AgentMutation) SetIsWayland(b bool) {
	m.is_wayland = &b
}

// IsWayland returns the value of the "is_wayland" field in the mutation.
func (m *AgentMutation) IsWayland() (r bool, exists bool) {
	v := m.is_wayland
	if v == nil {
		return
	}
	return *v, true
}

// OldIsWayland returns the old "is_wayland" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIsWayland(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsWayland is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsWayland requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsWayland: %w", err)
	}
	return oldValue.IsWayland, nil
}

// ClearIsWayland clears the value of the "is_wayland" field.
func (m *AgentMutation) ClearIsWayland() {
	m.is_wayland = nil
	m.clearedFields[agent.FieldIsWayland] = struct{}{}
}

// IsWaylandCleared returns if the "is_wayland" field was cleared in this mutation.
func (m *AgentMutation) IsWaylandCleared() bool {
	_, ok := m.clearedFields[agent.FieldIsWayland]
	return ok
}

// ResetIsWayland resets all changes to the "is_wayland" field.
func (m *AgentMutation) ResetIsWayland() {
	m.is_wayland = nil
	delete(m.clearedFields, agent.FieldIsWayland)
}

// SetIsFlatpakRustdesk sets the "is_flatpak_rustdesk" field.
func (m *AgentMutation) SetIsFlatpakRustdesk(b bool) {
	m.is_flatpak_rustdesk = &b
}

// IsFlatpakRustdesk returns the value of the "is_flatpak_rustdesk" field in the mutation.
func (m *AgentMutation) IsFlatpakRustdesk() (r bool, exists bool) {
	v := m.is_flatpak_rustdesk
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFlatpakRustdesk returns the old "is_flatpak_rustdesk" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIsFlatpakRustdesk(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFlatpakRustdesk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFlatpakRustdesk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFlatpakRustdesk: %w", err)
	}
	return oldValue.IsFlatpakRustdesk, nil
}

// ClearIsFlatpakRustdesk clears the value of the "is_flatpak_rustdesk" field.
func (m *AgentMutation) ClearIsFlatpakRustdesk() {
	m.is_flatpak_rustdesk = nil
	m.clearedFields[agent.FieldIsFlatpakRustdesk] = struct{}{}
}

// IsFlatpakRustdeskCleared returns if the "is_flatpak_rustdesk" field was cleared in this mutation.
func (m *AgentMutation) IsFlatpakRustdeskCleared() bool {
	_, ok := m.clearedFields[agent.FieldIsFlatpakRustdesk]
	return ok
}

// ResetIsFlatpakRustdesk resets all changes to the "is_flatpak_rustdesk" field.
func (m *AgentMutation) ResetIsFlatpakRustdesk() {
	m.is_flatpak_rustdesk = nil
	delete(m.clearedFields, agent.FieldIsFlatpakRustdesk)
}

// SetWan sets the "wan" field.
func (m *AgentMutation) SetWan(s string) {
	m.wan = &s
}

// Wan returns the value of the "wan" field in the mutation.
func (m *AgentMutation) Wan() (r string, exists bool) {
	v := m.wan
	if v == nil {
		return
	}
	return *v, true
}

// OldWan returns the old "wan" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldWan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWan: %w", err)
	}
	return oldValue.Wan, nil
}

// ResetWan resets all changes to the "wan" field.
func (m *AgentMutation) ResetWan() {
	m.wan = nil
}

// SetComputerID sets the "computer" edge to the Computer entity by id.
func (m *AgentMutation) SetComputerID(id int) {
	m.computer = &id
}

// ClearComputer clears the "computer" edge to the Computer entity.
func (m *AgentMutation) ClearComputer() {
	m.clearedcomputer = true
}

// ComputerCleared reports if the "computer" edge to the Computer entity was cleared.
func (m *AgentMutation) ComputerCleared() bool {
	return m.clearedcomputer
}

// ComputerID returns the "computer" edge ID in the mutation.
func (m *AgentMutation) ComputerID() (id int, exists bool) {
	if m.computer != nil {
		return *m.computer, true
	}
	return
}

// ComputerIDs returns the "computer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComputerID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) ComputerIDs() (ids []int) {
	if id := m.computer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComputer resets all changes to the "computer" edge.
func (m *AgentMutation) ResetComputer() {
	m.computer = nil
	m.clearedcomputer = false
}

// SetOperatingsystemID sets the "operatingsystem" edge to the OperatingSystem entity by id.
func (m *AgentMutation) SetOperatingsystemID(id int) {
	m.operatingsystem = &id
}

// ClearOperatingsystem clears the "operatingsystem" edge to the OperatingSystem entity.
func (m *AgentMutation) ClearOperatingsystem() {
	m.clearedoperatingsystem = true
}

// OperatingsystemCleared reports if the "operatingsystem" edge to the OperatingSystem entity was cleared.
func (m *AgentMutation) OperatingsystemCleared() bool {
	return m.clearedoperatingsystem
}

// OperatingsystemID returns the "operatingsystem" edge ID in the mutation.
func (m *AgentMutation) OperatingsystemID() (id int, exists bool) {
	if m.operatingsystem != nil {
		return *m.operatingsystem, true
	}
	return
}

// OperatingsystemIDs returns the "operatingsystem" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OperatingsystemID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) OperatingsystemIDs() (ids []int) {
	if id := m.operatingsystem; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOperatingsystem resets all changes to the "operatingsystem" edge.
func (m *AgentMutation) ResetOperatingsystem() {
	m.operatingsystem = nil
	m.clearedoperatingsystem = false
}

// SetSystemupdateID sets the "systemupdate" edge to the SystemUpdate entity by id.
func (m *AgentMutation) SetSystemupdateID(id int) {
	m.systemupdate = &id
}

// ClearSystemupdate clears the "systemupdate" edge to the SystemUpdate entity.
func (m *AgentMutation) ClearSystemupdate() {
	m.clearedsystemupdate = true
}

// SystemupdateCleared reports if the "systemupdate" edge to the SystemUpdate entity was cleared.
func (m *AgentMutation) SystemupdateCleared() bool {
	return m.clearedsystemupdate
}

// SystemupdateID returns the "systemupdate" edge ID in the mutation.
func (m *AgentMutation) SystemupdateID() (id int, exists bool) {
	if m.systemupdate != nil {
		return *m.systemupdate, true
	}
	return
}

// SystemupdateIDs returns the "systemupdate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SystemupdateID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) SystemupdateIDs() (ids []int) {
	if id := m.systemupdate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSystemupdate resets all changes to the "systemupdate" edge.
func (m *AgentMutation) ResetSystemupdate() {
	m.systemupdate = nil
	m.clearedsystemupdate = false
}

// SetAntivirusID sets the "antivirus" edge to the Antivirus entity by id.
func (m *AgentMutation) SetAntivirusID(id int) {
	m.antivirus = &id
}

// ClearAntivirus clears the "antivirus" edge to the Antivirus entity.
func (m *AgentMutation) ClearAntivirus() {
	m.clearedantivirus = true
}

// AntivirusCleared reports if the "antivirus" edge to the Antivirus entity was cleared.
func (m *AgentMutation) AntivirusCleared() bool {
	return m.clearedantivirus
}

// AntivirusID returns the "antivirus" edge ID in the mutation.
func (m *AgentMutation) AntivirusID() (id int, exists bool) {
	if m.antivirus != nil {
		return *m.antivirus, true
	}
	return
}

// AntivirusIDs returns the "antivirus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AntivirusID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) AntivirusIDs() (ids []int) {
	if id := m.antivirus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAntivirus resets all changes to the "antivirus" edge.
func (m *AgentMutation) ResetAntivirus() {
	m.antivirus = nil
	m.clearedantivirus = false
}

// AddLogicaldiskIDs adds the "logicaldisks" edge to the LogicalDisk entity by ids.
func (m *AgentMutation) AddLogicaldiskIDs(ids ...int) {
	if m.logicaldisks == nil {
		m.logicaldisks = make(map[int]struct{})
	}
	for i := range ids {
		m.logicaldisks[ids[i]] = struct{}{}
	}
}

// ClearLogicaldisks clears the "logicaldisks" edge to the LogicalDisk entity.
func (m *AgentMutation) ClearLogicaldisks() {
	m.clearedlogicaldisks = true
}

// LogicaldisksCleared reports if the "logicaldisks" edge to the LogicalDisk entity was cleared.
func (m *AgentMutation) LogicaldisksCleared() bool {
	return m.clearedlogicaldisks
}

// RemoveLogicaldiskIDs removes the "logicaldisks" edge to the LogicalDisk entity by IDs.
func (m *AgentMutation) RemoveLogicaldiskIDs(ids ...int) {
	if m.removedlogicaldisks == nil {
		m.removedlogicaldisks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.logicaldisks, ids[i])
		m.removedlogicaldisks[ids[i]] = struct{}{}
	}
}

// RemovedLogicaldisks returns the removed IDs of the "logicaldisks" edge to the LogicalDisk entity.
func (m *AgentMutation) RemovedLogicaldisksIDs() (ids []int) {
	for id := range m.removedlogicaldisks {
		ids = append(ids, id)
	}
	return
}

// LogicaldisksIDs returns the "logicaldisks" edge IDs in the mutation.
func (m *AgentMutation) LogicaldisksIDs() (ids []int) {
	for id := range m.logicaldisks {
		ids = append(ids, id)
	}
	return
}

// ResetLogicaldisks resets all changes to the "logicaldisks" edge.
func (m *AgentMutation) ResetLogicaldisks() {
	m.logicaldisks = nil
	m.clearedlogicaldisks = false
	m.removedlogicaldisks = nil
}

// AddAppIDs adds the "apps" edge to the App entity by ids.
func (m *AgentMutation) AddAppIDs(ids ...int) {
	if m.apps == nil {
		m.apps = make(map[int]struct{})
	}
	for i := range ids {
		m.apps[ids[i]] = struct{}{}
	}
}

// ClearApps clears the "apps" edge to the App entity.
func (m *AgentMutation) ClearApps() {
	m.clearedapps = true
}

// AppsCleared reports if the "apps" edge to the App entity was cleared.
func (m *AgentMutation) AppsCleared() bool {
	return m.clearedapps
}

// RemoveAppIDs removes the "apps" edge to the App entity by IDs.
func (m *AgentMutation) RemoveAppIDs(ids ...int) {
	if m.removedapps == nil {
		m.removedapps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.apps, ids[i])
		m.removedapps[ids[i]] = struct{}{}
	}
}

// RemovedApps returns the removed IDs of the "apps" edge to the App entity.
func (m *AgentMutation) RemovedAppsIDs() (ids []int) {
	for id := range m.removedapps {
		ids = append(ids, id)
	}
	return
}

// AppsIDs returns the "apps" edge IDs in the mutation.
func (m *AgentMutation) AppsIDs() (ids []int) {
	for id := range m.apps {
		ids = append(ids, id)
	}
	return
}

// ResetApps resets all changes to the "apps" edge.
func (m *AgentMutation) ResetApps() {
	m.apps = nil
	m.clearedapps = false
	m.removedapps = nil
}

// AddMonitorIDs adds the "monitors" edge to the Monitor entity by ids.
func (m *AgentMutation) AddMonitorIDs(ids ...int) {
	if m.monitors == nil {
		m.monitors = make(map[int]struct{})
	}
	for i := range ids {
		m.monitors[ids[i]] = struct{}{}
	}
}

// ClearMonitors clears the "monitors" edge to the Monitor entity.
func (m *AgentMutation) ClearMonitors() {
	m.clearedmonitors = true
}

// MonitorsCleared reports if the "monitors" edge to the Monitor entity was cleared.
func (m *AgentMutation) MonitorsCleared() bool {
	return m.clearedmonitors
}

// RemoveMonitorIDs removes the "monitors" edge to the Monitor entity by IDs.
func (m *AgentMutation) RemoveMonitorIDs(ids ...int) {
	if m.removedmonitors == nil {
		m.removedmonitors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.monitors, ids[i])
		m.removedmonitors[ids[i]] = struct{}{}
	}
}

// RemovedMonitors returns the removed IDs of the "monitors" edge to the Monitor entity.
func (m *AgentMutation) RemovedMonitorsIDs() (ids []int) {
	for id := range m.removedmonitors {
		ids = append(ids, id)
	}
	return
}

// MonitorsIDs returns the "monitors" edge IDs in the mutation.
func (m *AgentMutation) MonitorsIDs() (ids []int) {
	for id := range m.monitors {
		ids = append(ids, id)
	}
	return
}

// ResetMonitors resets all changes to the "monitors" edge.
func (m *AgentMutation) ResetMonitors() {
	m.monitors = nil
	m.clearedmonitors = false
	m.removedmonitors = nil
}

// AddShareIDs adds the "shares" edge to the Share entity by ids.
func (m *AgentMutation) AddShareIDs(ids ...int) {
	if m.shares == nil {
		m.shares = make(map[int]struct{})
	}
	for i := range ids {
		m.shares[ids[i]] = struct{}{}
	}
}

// ClearShares clears the "shares" edge to the Share entity.
func (m *AgentMutation) ClearShares() {
	m.clearedshares = true
}

// SharesCleared reports if the "shares" edge to the Share entity was cleared.
func (m *AgentMutation) SharesCleared() bool {
	return m.clearedshares
}

// RemoveShareIDs removes the "shares" edge to the Share entity by IDs.
func (m *AgentMutation) RemoveShareIDs(ids ...int) {
	if m.removedshares == nil {
		m.removedshares = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.shares, ids[i])
		m.removedshares[ids[i]] = struct{}{}
	}
}

// RemovedShares returns the removed IDs of the "shares" edge to the Share entity.
func (m *AgentMutation) RemovedSharesIDs() (ids []int) {
	for id := range m.removedshares {
		ids = append(ids, id)
	}
	return
}

// SharesIDs returns the "shares" edge IDs in the mutation.
func (m *AgentMutation) SharesIDs() (ids []int) {
	for id := range m.shares {
		ids = append(ids, id)
	}
	return
}

// ResetShares resets all changes to the "shares" edge.
func (m *AgentMutation) ResetShares() {
	m.shares = nil
	m.clearedshares = false
	m.removedshares = nil
}

// AddPrinterIDs adds the "printers" edge to the Printer entity by ids.
func (m *AgentMutation) AddPrinterIDs(ids ...int) {
	if m.printers == nil {
		m.printers = make(map[int]struct{})
	}
	for i := range ids {
		m.printers[ids[i]] = struct{}{}
	}
}

// ClearPrinters clears the "printers" edge to the Printer entity.
func (m *AgentMutation) ClearPrinters() {
	m.clearedprinters = true
}

// PrintersCleared reports if the "printers" edge to the Printer entity was cleared.
func (m *AgentMutation) PrintersCleared() bool {
	return m.clearedprinters
}

// RemovePrinterIDs removes the "printers" edge to the Printer entity by IDs.
func (m *AgentMutation) RemovePrinterIDs(ids ...int) {
	if m.removedprinters == nil {
		m.removedprinters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.printers, ids[i])
		m.removedprinters[ids[i]] = struct{}{}
	}
}

// RemovedPrinters returns the removed IDs of the "printers" edge to the Printer entity.
func (m *AgentMutation) RemovedPrintersIDs() (ids []int) {
	for id := range m.removedprinters {
		ids = append(ids, id)
	}
	return
}

// PrintersIDs returns the "printers" edge IDs in the mutation.
func (m *AgentMutation) PrintersIDs() (ids []int) {
	for id := range m.printers {
		ids = append(ids, id)
	}
	return
}

// ResetPrinters resets all changes to the "printers" edge.
func (m *AgentMutation) ResetPrinters() {
	m.printers = nil
	m.clearedprinters = false
	m.removedprinters = nil
}

// AddNetworkadapterIDs adds the "networkadapters" edge to the NetworkAdapter entity by ids.
func (m *AgentMutation) AddNetworkadapterIDs(ids ...int) {
	if m.networkadapters == nil {
		m.networkadapters = make(map[int]struct{})
	}
	for i := range ids {
		m.networkadapters[ids[i]] = struct{}{}
	}
}

// ClearNetworkadapters clears the "networkadapters" edge to the NetworkAdapter entity.
func (m *AgentMutation) ClearNetworkadapters() {
	m.clearednetworkadapters = true
}

// NetworkadaptersCleared reports if the "networkadapters" edge to the NetworkAdapter entity was cleared.
func (m *AgentMutation) NetworkadaptersCleared() bool {
	return m.clearednetworkadapters
}

// RemoveNetworkadapterIDs removes the "networkadapters" edge to the NetworkAdapter entity by IDs.
func (m *AgentMutation) RemoveNetworkadapterIDs(ids ...int) {
	if m.removednetworkadapters == nil {
		m.removednetworkadapters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.networkadapters, ids[i])
		m.removednetworkadapters[ids[i]] = struct{}{}
	}
}

// RemovedNetworkadapters returns the removed IDs of the "networkadapters" edge to the NetworkAdapter entity.
func (m *AgentMutation) RemovedNetworkadaptersIDs() (ids []int) {
	for id := range m.removednetworkadapters {
		ids = append(ids, id)
	}
	return
}

// NetworkadaptersIDs returns the "networkadapters" edge IDs in the mutation.
func (m *AgentMutation) NetworkadaptersIDs() (ids []int) {
	for id := range m.networkadapters {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkadapters resets all changes to the "networkadapters" edge.
func (m *AgentMutation) ResetNetworkadapters() {
	m.networkadapters = nil
	m.clearednetworkadapters = false
	m.removednetworkadapters = nil
}

// AddDeploymentIDs adds the "deployments" edge to the Deployment entity by ids.
func (m *AgentMutation) AddDeploymentIDs(ids ...int) {
	if m.deployments == nil {
		m.deployments = make(map[int]struct{})
	}
	for i := range ids {
		m.deployments[ids[i]] = struct{}{}
	}
}

// ClearDeployments clears the "deployments" edge to the Deployment entity.
func (m *AgentMutation) ClearDeployments() {
	m.cleareddeployments = true
}

// DeploymentsCleared reports if the "deployments" edge to the Deployment entity was cleared.
func (m *AgentMutation) DeploymentsCleared() bool {
	return m.cleareddeployments
}

// RemoveDeploymentIDs removes the "deployments" edge to the Deployment entity by IDs.
func (m *AgentMutation) RemoveDeploymentIDs(ids ...int) {
	if m.removeddeployments == nil {
		m.removeddeployments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.deployments, ids[i])
		m.removeddeployments[ids[i]] = struct{}{}
	}
}

// RemovedDeployments returns the removed IDs of the "deployments" edge to the Deployment entity.
func (m *AgentMutation) RemovedDeploymentsIDs() (ids []int) {
	for id := range m.removeddeployments {
		ids = append(ids, id)
	}
	return
}

// DeploymentsIDs returns the "deployments" edge IDs in the mutation.
func (m *AgentMutation) DeploymentsIDs() (ids []int) {
	for id := range m.deployments {
		ids = append(ids, id)
	}
	return
}

// ResetDeployments resets all changes to the "deployments" edge.
func (m *AgentMutation) ResetDeployments() {
	m.deployments = nil
	m.cleareddeployments = false
	m.removeddeployments = nil
}

// AddUpdateIDs adds the "updates" edge to the Update entity by ids.
func (m *AgentMutation) AddUpdateIDs(ids ...int) {
	if m.updates == nil {
		m.updates = make(map[int]struct{})
	}
	for i := range ids {
		m.updates[ids[i]] = struct{}{}
	}
}

// ClearUpdates clears the "updates" edge to the Update entity.
func (m *AgentMutation) ClearUpdates() {
	m.clearedupdates = true
}

// UpdatesCleared reports if the "updates" edge to the Update entity was cleared.
func (m *AgentMutation) UpdatesCleared() bool {
	return m.clearedupdates
}

// RemoveUpdateIDs removes the "updates" edge to the Update entity by IDs.
func (m *AgentMutation) RemoveUpdateIDs(ids ...int) {
	if m.removedupdates == nil {
		m.removedupdates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.updates, ids[i])
		m.removedupdates[ids[i]] = struct{}{}
	}
}

// RemovedUpdates returns the removed IDs of the "updates" edge to the Update entity.
func (m *AgentMutation) RemovedUpdatesIDs() (ids []int) {
	for id := range m.removedupdates {
		ids = append(ids, id)
	}
	return
}

// UpdatesIDs returns the "updates" edge IDs in the mutation.
func (m *AgentMutation) UpdatesIDs() (ids []int) {
	for id := range m.updates {
		ids = append(ids, id)
	}
	return
}

// ResetUpdates resets all changes to the "updates" edge.
func (m *AgentMutation) ResetUpdates() {
	m.updates = nil
	m.clearedupdates = false
	m.removedupdates = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *AgentMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *AgentMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *AgentMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *AgentMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *AgentMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *AgentMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *AgentMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *AgentMutation) AddMetadatumIDs(ids ...int) {
	if m.metadata == nil {
		m.metadata = make(map[int]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *AgentMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *AgentMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *AgentMutation) RemoveMetadatumIDs(ids ...int) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *AgentMutation) RemovedMetadataIDs() (ids []int) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *AgentMutation) MetadataIDs() (ids []int) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *AgentMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// AddWingetcfgexclusionIDs adds the "wingetcfgexclusions" edge to the WingetConfigExclusion entity by ids.
func (m *AgentMutation) AddWingetcfgexclusionIDs(ids ...int) {
	if m.wingetcfgexclusions == nil {
		m.wingetcfgexclusions = make(map[int]struct{})
	}
	for i := range ids {
		m.wingetcfgexclusions[ids[i]] = struct{}{}
	}
}

// ClearWingetcfgexclusions clears the "wingetcfgexclusions" edge to the WingetConfigExclusion entity.
func (m *AgentMutation) ClearWingetcfgexclusions() {
	m.clearedwingetcfgexclusions = true
}

// WingetcfgexclusionsCleared reports if the "wingetcfgexclusions" edge to the WingetConfigExclusion entity was cleared.
func (m *AgentMutation) WingetcfgexclusionsCleared() bool {
	return m.clearedwingetcfgexclusions
}

// RemoveWingetcfgexclusionIDs removes the "wingetcfgexclusions" edge to the WingetConfigExclusion entity by IDs.
func (m *AgentMutation) RemoveWingetcfgexclusionIDs(ids ...int) {
	if m.removedwingetcfgexclusions == nil {
		m.removedwingetcfgexclusions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.wingetcfgexclusions, ids[i])
		m.removedwingetcfgexclusions[ids[i]] = struct{}{}
	}
}

// RemovedWingetcfgexclusions returns the removed IDs of the "wingetcfgexclusions" edge to the WingetConfigExclusion entity.
func (m *AgentMutation) RemovedWingetcfgexclusionsIDs() (ids []int) {
	for id := range m.removedwingetcfgexclusions {
		ids = append(ids, id)
	}
	return
}

// WingetcfgexclusionsIDs returns the "wingetcfgexclusions" edge IDs in the mutation.
func (m *AgentMutation) WingetcfgexclusionsIDs() (ids []int) {
	for id := range m.wingetcfgexclusions {
		ids = append(ids, id)
	}
	return
}

// ResetWingetcfgexclusions resets all changes to the "wingetcfgexclusions" edge.
func (m *AgentMutation) ResetWingetcfgexclusions() {
	m.wingetcfgexclusions = nil
	m.clearedwingetcfgexclusions = false
	m.removedwingetcfgexclusions = nil
}

// AddMemoryslotIDs adds the "memoryslots" edge to the MemorySlot entity by ids.
func (m *AgentMutation) AddMemoryslotIDs(ids ...int) {
	if m.memoryslots == nil {
		m.memoryslots = make(map[int]struct{})
	}
	for i := range ids {
		m.memoryslots[ids[i]] = struct{}{}
	}
}

// ClearMemoryslots clears the "memoryslots" edge to the MemorySlot entity.
func (m *AgentMutation) ClearMemoryslots() {
	m.clearedmemoryslots = true
}

// MemoryslotsCleared reports if the "memoryslots" edge to the MemorySlot entity was cleared.
func (m *AgentMutation) MemoryslotsCleared() bool {
	return m.clearedmemoryslots
}

// RemoveMemoryslotIDs removes the "memoryslots" edge to the MemorySlot entity by IDs.
func (m *AgentMutation) RemoveMemoryslotIDs(ids ...int) {
	if m.removedmemoryslots == nil {
		m.removedmemoryslots = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.memoryslots, ids[i])
		m.removedmemoryslots[ids[i]] = struct{}{}
	}
}

// RemovedMemoryslots returns the removed IDs of the "memoryslots" edge to the MemorySlot entity.
func (m *AgentMutation) RemovedMemoryslotsIDs() (ids []int) {
	for id := range m.removedmemoryslots {
		ids = append(ids, id)
	}
	return
}

// MemoryslotsIDs returns the "memoryslots" edge IDs in the mutation.
func (m *AgentMutation) MemoryslotsIDs() (ids []int) {
	for id := range m.memoryslots {
		ids = append(ids, id)
	}
	return
}

// ResetMemoryslots resets all changes to the "memoryslots" edge.
func (m *AgentMutation) ResetMemoryslots() {
	m.memoryslots = nil
	m.clearedmemoryslots = false
	m.removedmemoryslots = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *AgentMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *AgentMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *AgentMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *AgentMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *AgentMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// AddProfileissueIDs adds the "profileissue" edge to the ProfileIssue entity by ids.
func (m *AgentMutation) AddProfileissueIDs(ids ...int) {
	if m.profileissue == nil {
		m.profileissue = make(map[int]struct{})
	}
	for i := range ids {
		m.profileissue[ids[i]] = struct{}{}
	}
}

// ClearProfileissue clears the "profileissue" edge to the ProfileIssue entity.
func (m *AgentMutation) ClearProfileissue() {
	m.clearedprofileissue = true
}

// ProfileissueCleared reports if the "profileissue" edge to the ProfileIssue entity was cleared.
func (m *AgentMutation) ProfileissueCleared() bool {
	return m.clearedprofileissue
}

// RemoveProfileissueIDs removes the "profileissue" edge to the ProfileIssue entity by IDs.
func (m *AgentMutation) RemoveProfileissueIDs(ids ...int) {
	if m.removedprofileissue == nil {
		m.removedprofileissue = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.profileissue, ids[i])
		m.removedprofileissue[ids[i]] = struct{}{}
	}
}

// RemovedProfileissue returns the removed IDs of the "profileissue" edge to the ProfileIssue entity.
func (m *AgentMutation) RemovedProfileissueIDs() (ids []int) {
	for id := range m.removedprofileissue {
		ids = append(ids, id)
	}
	return
}

// ProfileissueIDs returns the "profileissue" edge IDs in the mutation.
func (m *AgentMutation) ProfileissueIDs() (ids []int) {
	for id := range m.profileissue {
		ids = append(ids, id)
	}
	return
}

// ResetProfileissue resets all changes to the "profileissue" edge.
func (m *AgentMutation) ResetProfileissue() {
	m.profileissue = nil
	m.clearedprofileissue = false
	m.removedprofileissue = nil
}

// AddSiteIDs adds the "site" edge to the Site entity by ids.
func (m *AgentMutation) AddSiteIDs(ids ...int) {
	if m.site == nil {
		m.site = make(map[int]struct{})
	}
	for i := range ids {
		m.site[ids[i]] = struct{}{}
	}
}

// ClearSite clears the "site" edge to the Site entity.
func (m *AgentMutation) ClearSite() {
	m.clearedsite = true
}

// SiteCleared reports if the "site" edge to the Site entity was cleared.
func (m *AgentMutation) SiteCleared() bool {
	return m.clearedsite
}

// RemoveSiteIDs removes the "site" edge to the Site entity by IDs.
func (m *AgentMutation) RemoveSiteIDs(ids ...int) {
	if m.removedsite == nil {
		m.removedsite = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.site, ids[i])
		m.removedsite[ids[i]] = struct{}{}
	}
}

// RemovedSite returns the removed IDs of the "site" edge to the Site entity.
func (m *AgentMutation) RemovedSiteIDs() (ids []int) {
	for id := range m.removedsite {
		ids = append(ids, id)
	}
	return
}

// SiteIDs returns the "site" edge IDs in the mutation.
func (m *AgentMutation) SiteIDs() (ids []int) {
	for id := range m.site {
		ids = append(ids, id)
	}
	return
}

// ResetSite resets all changes to the "site" edge.
func (m *AgentMutation) ResetSite() {
	m.site = nil
	m.clearedsite = false
	m.removedsite = nil
}

// AddPhysicaldiskIDs adds the "physicaldisks" edge to the PhysicalDisk entity by ids.
func (m *AgentMutation) AddPhysicaldiskIDs(ids ...int) {
	if m.physicaldisks == nil {
		m.physicaldisks = make(map[int]struct{})
	}
	for i := range ids {
		m.physicaldisks[ids[i]] = struct{}{}
	}
}

// ClearPhysicaldisks clears the "physicaldisks" edge to the PhysicalDisk entity.
func (m *AgentMutation) ClearPhysicaldisks() {
	m.clearedphysicaldisks = true
}

// PhysicaldisksCleared reports if the "physicaldisks" edge to the PhysicalDisk entity was cleared.
func (m *AgentMutation) PhysicaldisksCleared() bool {
	return m.clearedphysicaldisks
}

// RemovePhysicaldiskIDs removes the "physicaldisks" edge to the PhysicalDisk entity by IDs.
func (m *AgentMutation) RemovePhysicaldiskIDs(ids ...int) {
	if m.removedphysicaldisks == nil {
		m.removedphysicaldisks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.physicaldisks, ids[i])
		m.removedphysicaldisks[ids[i]] = struct{}{}
	}
}

// RemovedPhysicaldisks returns the removed IDs of the "physicaldisks" edge to the PhysicalDisk entity.
func (m *AgentMutation) RemovedPhysicaldisksIDs() (ids []int) {
	for id := range m.removedphysicaldisks {
		ids = append(ids, id)
	}
	return
}

// PhysicaldisksIDs returns the "physicaldisks" edge IDs in the mutation.
func (m *AgentMutation) PhysicaldisksIDs() (ids []int) {
	for id := range m.physicaldisks {
		ids = append(ids, id)
	}
	return
}

// ResetPhysicaldisks resets all changes to the "physicaldisks" edge.
func (m *AgentMutation) ResetPhysicaldisks() {
	m.physicaldisks = nil
	m.clearedphysicaldisks = false
	m.removedphysicaldisks = nil
}

// SetNetbirdID sets the "netbird" edge to the Netbird entity by id.
func (m *AgentMutation) SetNetbirdID(id int) {
	m.netbird = &id
}

// ClearNetbird clears the "netbird" edge to the Netbird entity.
func (m *AgentMutation) ClearNetbird() {
	m.clearednetbird = true
}

// NetbirdCleared reports if the "netbird" edge to the Netbird entity was cleared.
func (m *AgentMutation) NetbirdCleared() bool {
	return m.clearednetbird
}

// NetbirdID returns the "netbird" edge ID in the mutation.
func (m *AgentMutation) NetbirdID() (id int, exists bool) {
	if m.netbird != nil {
		return *m.netbird, true
	}
	return
}

// NetbirdIDs returns the "netbird" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NetbirdID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) NetbirdIDs() (ids []int) {
	if id := m.netbird; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNetbird resets all changes to the "netbird" edge.
func (m *AgentMutation) ResetNetbird() {
	m.netbird = nil
	m.clearednetbird = false
}

// Where appends a list predicates to the AgentMutation builder.
func (m *AgentMutation) Where(ps ...predicate.Agent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Agent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 30)
	if m.os != nil {
		fields = append(fields, agent.FieldOs)
	}
	if m.hostname != nil {
		fields = append(fields, agent.FieldHostname)
	}
	if m.ip != nil {
		fields = append(fields, agent.FieldIP)
	}
	if m.mac != nil {
		fields = append(fields, agent.FieldMAC)
	}
	if m.first_contact != nil {
		fields = append(fields, agent.FieldFirstContact)
	}
	if m.last_contact != nil {
		fields = append(fields, agent.FieldLastContact)
	}
	if m.vnc != nil {
		fields = append(fields, agent.FieldVnc)
	}
	if m.notes != nil {
		fields = append(fields, agent.FieldNotes)
	}
	if m.update_task_status != nil {
		fields = append(fields, agent.FieldUpdateTaskStatus)
	}
	if m.update_task_description != nil {
		fields = append(fields, agent.FieldUpdateTaskDescription)
	}
	if m.update_task_result != nil {
		fields = append(fields, agent.FieldUpdateTaskResult)
	}
	if m.update_task_execution != nil {
		fields = append(fields, agent.FieldUpdateTaskExecution)
	}
	if m.update_task_version != nil {
		fields = append(fields, agent.FieldUpdateTaskVersion)
	}
	if m.vnc_proxy_port != nil {
		fields = append(fields, agent.FieldVncProxyPort)
	}
	if m.sftp_port != nil {
		fields = append(fields, agent.FieldSftpPort)
	}
	if m.agent_status != nil {
		fields = append(fields, agent.FieldAgentStatus)
	}
	if m.certificate_ready != nil {
		fields = append(fields, agent.FieldCertificateReady)
	}
	if m.restart_required != nil {
		fields = append(fields, agent.FieldRestartRequired)
	}
	if m.is_remote != nil {
		fields = append(fields, agent.FieldIsRemote)
	}
	if m.debug_mode != nil {
		fields = append(fields, agent.FieldDebugMode)
	}
	if m.sftp_service != nil {
		fields = append(fields, agent.FieldSftpService)
	}
	if m.remote_assistance != nil {
		fields = append(fields, agent.FieldRemoteAssistance)
	}
	if m.settings_modified != nil {
		fields = append(fields, agent.FieldSettingsModified)
	}
	if m.description != nil {
		fields = append(fields, agent.FieldDescription)
	}
	if m.nickname != nil {
		fields = append(fields, agent.FieldNickname)
	}
	if m.endpoint_type != nil {
		fields = append(fields, agent.FieldEndpointType)
	}
	if m.has_rustdesk != nil {
		fields = append(fields, agent.FieldHasRustdesk)
	}
	if m.is_wayland != nil {
		fields = append(fields, agent.FieldIsWayland)
	}
	if m.is_flatpak_rustdesk != nil {
		fields = append(fields, agent.FieldIsFlatpakRustdesk)
	}
	if m.wan != nil {
		fields = append(fields, agent.FieldWan)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldOs:
		return m.Os()
	case agent.FieldHostname:
		return m.Hostname()
	case agent.FieldIP:
		return m.IP()
	case agent.FieldMAC:
		return m.MAC()
	case agent.FieldFirstContact:
		return m.FirstContact()
	case agent.FieldLastContact:
		return m.LastContact()
	case agent.FieldVnc:
		return m.Vnc()
	case agent.FieldNotes:
		return m.Notes()
	case agent.FieldUpdateTaskStatus:
		return m.UpdateTaskStatus()
	case agent.FieldUpdateTaskDescription:
		return m.UpdateTaskDescription()
	case agent.FieldUpdateTaskResult:
		return m.UpdateTaskResult()
	case agent.FieldUpdateTaskExecution:
		return m.UpdateTaskExecution()
	case agent.FieldUpdateTaskVersion:
		return m.UpdateTaskVersion()
	case agent.FieldVncProxyPort:
		return m.VncProxyPort()
	case agent.FieldSftpPort:
		return m.SftpPort()
	case agent.FieldAgentStatus:
		return m.AgentStatus()
	case agent.FieldCertificateReady:
		return m.CertificateReady()
	case agent.FieldRestartRequired:
		return m.RestartRequired()
	case agent.FieldIsRemote:
		return m.IsRemote()
	case agent.FieldDebugMode:
		return m.DebugMode()
	case agent.FieldSftpService:
		return m.SftpService()
	case agent.FieldRemoteAssistance:
		return m.RemoteAssistance()
	case agent.FieldSettingsModified:
		return m.SettingsModified()
	case agent.FieldDescription:
		return m.Description()
	case agent.FieldNickname:
		return m.Nickname()
	case agent.FieldEndpointType:
		return m.EndpointType()
	case agent.FieldHasRustdesk:
		return m.HasRustdesk()
	case agent.FieldIsWayland:
		return m.IsWayland()
	case agent.FieldIsFlatpakRustdesk:
		return m.IsFlatpakRustdesk()
	case agent.FieldWan:
		return m.Wan()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldOs:
		return m.OldOs(ctx)
	case agent.FieldHostname:
		return m.OldHostname(ctx)
	case agent.FieldIP:
		return m.OldIP(ctx)
	case agent.FieldMAC:
		return m.OldMAC(ctx)
	case agent.FieldFirstContact:
		return m.OldFirstContact(ctx)
	case agent.FieldLastContact:
		return m.OldLastContact(ctx)
	case agent.FieldVnc:
		return m.OldVnc(ctx)
	case agent.FieldNotes:
		return m.OldNotes(ctx)
	case agent.FieldUpdateTaskStatus:
		return m.OldUpdateTaskStatus(ctx)
	case agent.FieldUpdateTaskDescription:
		return m.OldUpdateTaskDescription(ctx)
	case agent.FieldUpdateTaskResult:
		return m.OldUpdateTaskResult(ctx)
	case agent.FieldUpdateTaskExecution:
		return m.OldUpdateTaskExecution(ctx)
	case agent.FieldUpdateTaskVersion:
		return m.OldUpdateTaskVersion(ctx)
	case agent.FieldVncProxyPort:
		return m.OldVncProxyPort(ctx)
	case agent.FieldSftpPort:
		return m.OldSftpPort(ctx)
	case agent.FieldAgentStatus:
		return m.OldAgentStatus(ctx)
	case agent.FieldCertificateReady:
		return m.OldCertificateReady(ctx)
	case agent.FieldRestartRequired:
		return m.OldRestartRequired(ctx)
	case agent.FieldIsRemote:
		return m.OldIsRemote(ctx)
	case agent.FieldDebugMode:
		return m.OldDebugMode(ctx)
	case agent.FieldSftpService:
		return m.OldSftpService(ctx)
	case agent.FieldRemoteAssistance:
		return m.OldRemoteAssistance(ctx)
	case agent.FieldSettingsModified:
		return m.OldSettingsModified(ctx)
	case agent.FieldDescription:
		return m.OldDescription(ctx)
	case agent.FieldNickname:
		return m.OldNickname(ctx)
	case agent.FieldEndpointType:
		return m.OldEndpointType(ctx)
	case agent.FieldHasRustdesk:
		return m.OldHasRustdesk(ctx)
	case agent.FieldIsWayland:
		return m.OldIsWayland(ctx)
	case agent.FieldIsFlatpakRustdesk:
		return m.OldIsFlatpakRustdesk(ctx)
	case agent.FieldWan:
		return m.OldWan(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case agent.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case agent.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case agent.FieldMAC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMAC(v)
		return nil
	case agent.FieldFirstContact:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstContact(v)
		return nil
	case agent.FieldLastContact:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastContact(v)
		return nil
	case agent.FieldVnc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVnc(v)
		return nil
	case agent.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case agent.FieldUpdateTaskStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTaskStatus(v)
		return nil
	case agent.FieldUpdateTaskDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTaskDescription(v)
		return nil
	case agent.FieldUpdateTaskResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTaskResult(v)
		return nil
	case agent.FieldUpdateTaskExecution:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTaskExecution(v)
		return nil
	case agent.FieldUpdateTaskVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTaskVersion(v)
		return nil
	case agent.FieldVncProxyPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVncProxyPort(v)
		return nil
	case agent.FieldSftpPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSftpPort(v)
		return nil
	case agent.FieldAgentStatus:
		v, ok := value.(agent.AgentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentStatus(v)
		return nil
	case agent.FieldCertificateReady:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateReady(v)
		return nil
	case agent.FieldRestartRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRestartRequired(v)
		return nil
	case agent.FieldIsRemote:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRemote(v)
		return nil
	case agent.FieldDebugMode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDebugMode(v)
		return nil
	case agent.FieldSftpService:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSftpService(v)
		return nil
	case agent.FieldRemoteAssistance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteAssistance(v)
		return nil
	case agent.FieldSettingsModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingsModified(v)
		return nil
	case agent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case agent.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case agent.FieldEndpointType:
		v, ok := value.(agent.EndpointType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpointType(v)
		return nil
	case agent.FieldHasRustdesk:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasRustdesk(v)
		return nil
	case agent.FieldIsWayland:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsWayland(v)
		return nil
	case agent.FieldIsFlatpakRustdesk:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFlatpakRustdesk(v)
		return nil
	case agent.FieldWan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWan(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agent.FieldFirstContact) {
		fields = append(fields, agent.FieldFirstContact)
	}
	if m.FieldCleared(agent.FieldLastContact) {
		fields = append(fields, agent.FieldLastContact)
	}
	if m.FieldCleared(agent.FieldVnc) {
		fields = append(fields, agent.FieldVnc)
	}
	if m.FieldCleared(agent.FieldNotes) {
		fields = append(fields, agent.FieldNotes)
	}
	if m.FieldCleared(agent.FieldUpdateTaskStatus) {
		fields = append(fields, agent.FieldUpdateTaskStatus)
	}
	if m.FieldCleared(agent.FieldUpdateTaskDescription) {
		fields = append(fields, agent.FieldUpdateTaskDescription)
	}
	if m.FieldCleared(agent.FieldUpdateTaskResult) {
		fields = append(fields, agent.FieldUpdateTaskResult)
	}
	if m.FieldCleared(agent.FieldUpdateTaskExecution) {
		fields = append(fields, agent.FieldUpdateTaskExecution)
	}
	if m.FieldCleared(agent.FieldUpdateTaskVersion) {
		fields = append(fields, agent.FieldUpdateTaskVersion)
	}
	if m.FieldCleared(agent.FieldVncProxyPort) {
		fields = append(fields, agent.FieldVncProxyPort)
	}
	if m.FieldCleared(agent.FieldSftpPort) {
		fields = append(fields, agent.FieldSftpPort)
	}
	if m.FieldCleared(agent.FieldAgentStatus) {
		fields = append(fields, agent.FieldAgentStatus)
	}
	if m.FieldCleared(agent.FieldCertificateReady) {
		fields = append(fields, agent.FieldCertificateReady)
	}
	if m.FieldCleared(agent.FieldRestartRequired) {
		fields = append(fields, agent.FieldRestartRequired)
	}
	if m.FieldCleared(agent.FieldIsRemote) {
		fields = append(fields, agent.FieldIsRemote)
	}
	if m.FieldCleared(agent.FieldDebugMode) {
		fields = append(fields, agent.FieldDebugMode)
	}
	if m.FieldCleared(agent.FieldSftpService) {
		fields = append(fields, agent.FieldSftpService)
	}
	if m.FieldCleared(agent.FieldRemoteAssistance) {
		fields = append(fields, agent.FieldRemoteAssistance)
	}
	if m.FieldCleared(agent.FieldSettingsModified) {
		fields = append(fields, agent.FieldSettingsModified)
	}
	if m.FieldCleared(agent.FieldDescription) {
		fields = append(fields, agent.FieldDescription)
	}
	if m.FieldCleared(agent.FieldNickname) {
		fields = append(fields, agent.FieldNickname)
	}
	if m.FieldCleared(agent.FieldEndpointType) {
		fields = append(fields, agent.FieldEndpointType)
	}
	if m.FieldCleared(agent.FieldHasRustdesk) {
		fields = append(fields, agent.FieldHasRustdesk)
	}
	if m.FieldCleared(agent.FieldIsWayland) {
		fields = append(fields, agent.FieldIsWayland)
	}
	if m.FieldCleared(agent.FieldIsFlatpakRustdesk) {
		fields = append(fields, agent.FieldIsFlatpakRustdesk)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	switch name {
	case agent.FieldFirstContact:
		m.ClearFirstContact()
		return nil
	case agent.FieldLastContact:
		m.ClearLastContact()
		return nil
	case agent.FieldVnc:
		m.ClearVnc()
		return nil
	case agent.FieldNotes:
		m.ClearNotes()
		return nil
	case agent.FieldUpdateTaskStatus:
		m.ClearUpdateTaskStatus()
		return nil
	case agent.FieldUpdateTaskDescription:
		m.ClearUpdateTaskDescription()
		return nil
	case agent.FieldUpdateTaskResult:
		m.ClearUpdateTaskResult()
		return nil
	case agent.FieldUpdateTaskExecution:
		m.ClearUpdateTaskExecution()
		return nil
	case agent.FieldUpdateTaskVersion:
		m.ClearUpdateTaskVersion()
		return nil
	case agent.FieldVncProxyPort:
		m.ClearVncProxyPort()
		return nil
	case agent.FieldSftpPort:
		m.ClearSftpPort()
		return nil
	case agent.FieldAgentStatus:
		m.ClearAgentStatus()
		return nil
	case agent.FieldCertificateReady:
		m.ClearCertificateReady()
		return nil
	case agent.FieldRestartRequired:
		m.ClearRestartRequired()
		return nil
	case agent.FieldIsRemote:
		m.ClearIsRemote()
		return nil
	case agent.FieldDebugMode:
		m.ClearDebugMode()
		return nil
	case agent.FieldSftpService:
		m.ClearSftpService()
		return nil
	case agent.FieldRemoteAssistance:
		m.ClearRemoteAssistance()
		return nil
	case agent.FieldSettingsModified:
		m.ClearSettingsModified()
		return nil
	case agent.FieldDescription:
		m.ClearDescription()
		return nil
	case agent.FieldNickname:
		m.ClearNickname()
		return nil
	case agent.FieldEndpointType:
		m.ClearEndpointType()
		return nil
	case agent.FieldHasRustdesk:
		m.ClearHasRustdesk()
		return nil
	case agent.FieldIsWayland:
		m.ClearIsWayland()
		return nil
	case agent.FieldIsFlatpakRustdesk:
		m.ClearIsFlatpakRustdesk()
		return nil
	}
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldOs:
		m.ResetOs()
		return nil
	case agent.FieldHostname:
		m.ResetHostname()
		return nil
	case agent.FieldIP:
		m.ResetIP()
		return nil
	case agent.FieldMAC:
		m.ResetMAC()
		return nil
	case agent.FieldFirstContact:
		m.ResetFirstContact()
		return nil
	case agent.FieldLastContact:
		m.ResetLastContact()
		return nil
	case agent.FieldVnc:
		m.ResetVnc()
		return nil
	case agent.FieldNotes:
		m.ResetNotes()
		return nil
	case agent.FieldUpdateTaskStatus:
		m.ResetUpdateTaskStatus()
		return nil
	case agent.FieldUpdateTaskDescription:
		m.ResetUpdateTaskDescription()
		return nil
	case agent.FieldUpdateTaskResult:
		m.ResetUpdateTaskResult()
		return nil
	case agent.FieldUpdateTaskExecution:
		m.ResetUpdateTaskExecution()
		return nil
	case agent.FieldUpdateTaskVersion:
		m.ResetUpdateTaskVersion()
		return nil
	case agent.FieldVncProxyPort:
		m.ResetVncProxyPort()
		return nil
	case agent.FieldSftpPort:
		m.ResetSftpPort()
		return nil
	case agent.FieldAgentStatus:
		m.ResetAgentStatus()
		return nil
	case agent.FieldCertificateReady:
		m.ResetCertificateReady()
		return nil
	case agent.FieldRestartRequired:
		m.ResetRestartRequired()
		return nil
	case agent.FieldIsRemote:
		m.ResetIsRemote()
		return nil
	case agent.FieldDebugMode:
		m.ResetDebugMode()
		return nil
	case agent.FieldSftpService:
		m.ResetSftpService()
		return nil
	case agent.FieldRemoteAssistance:
		m.ResetRemoteAssistance()
		return nil
	case agent.FieldSettingsModified:
		m.ResetSettingsModified()
		return nil
	case agent.FieldDescription:
		m.ResetDescription()
		return nil
	case agent.FieldNickname:
		m.ResetNickname()
		return nil
	case agent.FieldEndpointType:
		m.ResetEndpointType()
		return nil
	case agent.FieldHasRustdesk:
		m.ResetHasRustdesk()
		return nil
	case agent.FieldIsWayland:
		m.ResetIsWayland()
		return nil
	case agent.FieldIsFlatpakRustdesk:
		m.ResetIsFlatpakRustdesk()
		return nil
	case agent.FieldWan:
		m.ResetWan()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 21)
	if m.computer != nil {
		edges = append(edges, agent.EdgeComputer)
	}
	if m.operatingsystem != nil {
		edges = append(edges, agent.EdgeOperatingsystem)
	}
	if m.systemupdate != nil {
		edges = append(edges, agent.EdgeSystemupdate)
	}
	if m.antivirus != nil {
		edges = append(edges, agent.EdgeAntivirus)
	}
	if m.logicaldisks != nil {
		edges = append(edges, agent.EdgeLogicaldisks)
	}
	if m.apps != nil {
		edges = append(edges, agent.EdgeApps)
	}
	if m.monitors != nil {
		edges = append(edges, agent.EdgeMonitors)
	}
	if m.shares != nil {
		edges = append(edges, agent.EdgeShares)
	}
	if m.printers != nil {
		edges = append(edges, agent.EdgePrinters)
	}
	if m.networkadapters != nil {
		edges = append(edges, agent.EdgeNetworkadapters)
	}
	if m.deployments != nil {
		edges = append(edges, agent.EdgeDeployments)
	}
	if m.updates != nil {
		edges = append(edges, agent.EdgeUpdates)
	}
	if m.tags != nil {
		edges = append(edges, agent.EdgeTags)
	}
	if m.metadata != nil {
		edges = append(edges, agent.EdgeMetadata)
	}
	if m.wingetcfgexclusions != nil {
		edges = append(edges, agent.EdgeWingetcfgexclusions)
	}
	if m.memoryslots != nil {
		edges = append(edges, agent.EdgeMemoryslots)
	}
	if m.release != nil {
		edges = append(edges, agent.EdgeRelease)
	}
	if m.profileissue != nil {
		edges = append(edges, agent.EdgeProfileissue)
	}
	if m.site != nil {
		edges = append(edges, agent.EdgeSite)
	}
	if m.physicaldisks != nil {
		edges = append(edges, agent.EdgePhysicaldisks)
	}
	if m.netbird != nil {
		edges = append(edges, agent.EdgeNetbird)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeComputer:
		if id := m.computer; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeOperatingsystem:
		if id := m.operatingsystem; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeSystemupdate:
		if id := m.systemupdate; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeAntivirus:
		if id := m.antivirus; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeLogicaldisks:
		ids := make([]ent.Value, 0, len(m.logicaldisks))
		for id := range m.logicaldisks {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeApps:
		ids := make([]ent.Value, 0, len(m.apps))
		for id := range m.apps {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeMonitors:
		ids := make([]ent.Value, 0, len(m.monitors))
		for id := range m.monitors {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeShares:
		ids := make([]ent.Value, 0, len(m.shares))
		for id := range m.shares {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgePrinters:
		ids := make([]ent.Value, 0, len(m.printers))
		for id := range m.printers {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeNetworkadapters:
		ids := make([]ent.Value, 0, len(m.networkadapters))
		for id := range m.networkadapters {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeDeployments:
		ids := make([]ent.Value, 0, len(m.deployments))
		for id := range m.deployments {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeUpdates:
		ids := make([]ent.Value, 0, len(m.updates))
		for id := range m.updates {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeWingetcfgexclusions:
		ids := make([]ent.Value, 0, len(m.wingetcfgexclusions))
		for id := range m.wingetcfgexclusions {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeMemoryslots:
		ids := make([]ent.Value, 0, len(m.memoryslots))
		for id := range m.memoryslots {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeProfileissue:
		ids := make([]ent.Value, 0, len(m.profileissue))
		for id := range m.profileissue {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeSite:
		ids := make([]ent.Value, 0, len(m.site))
		for id := range m.site {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgePhysicaldisks:
		ids := make([]ent.Value, 0, len(m.physicaldisks))
		for id := range m.physicaldisks {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeNetbird:
		if id := m.netbird; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 21)
	if m.removedlogicaldisks != nil {
		edges = append(edges, agent.EdgeLogicaldisks)
	}
	if m.removedapps != nil {
		edges = append(edges, agent.EdgeApps)
	}
	if m.removedmonitors != nil {
		edges = append(edges, agent.EdgeMonitors)
	}
	if m.removedshares != nil {
		edges = append(edges, agent.EdgeShares)
	}
	if m.removedprinters != nil {
		edges = append(edges, agent.EdgePrinters)
	}
	if m.removednetworkadapters != nil {
		edges = append(edges, agent.EdgeNetworkadapters)
	}
	if m.removeddeployments != nil {
		edges = append(edges, agent.EdgeDeployments)
	}
	if m.removedupdates != nil {
		edges = append(edges, agent.EdgeUpdates)
	}
	if m.removedtags != nil {
		edges = append(edges, agent.EdgeTags)
	}
	if m.removedmetadata != nil {
		edges = append(edges, agent.EdgeMetadata)
	}
	if m.removedwingetcfgexclusions != nil {
		edges = append(edges, agent.EdgeWingetcfgexclusions)
	}
	if m.removedmemoryslots != nil {
		edges = append(edges, agent.EdgeMemoryslots)
	}
	if m.removedprofileissue != nil {
		edges = append(edges, agent.EdgeProfileissue)
	}
	if m.removedsite != nil {
		edges = append(edges, agent.EdgeSite)
	}
	if m.removedphysicaldisks != nil {
		edges = append(edges, agent.EdgePhysicaldisks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeLogicaldisks:
		ids := make([]ent.Value, 0, len(m.removedlogicaldisks))
		for id := range m.removedlogicaldisks {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeApps:
		ids := make([]ent.Value, 0, len(m.removedapps))
		for id := range m.removedapps {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeMonitors:
		ids := make([]ent.Value, 0, len(m.removedmonitors))
		for id := range m.removedmonitors {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeShares:
		ids := make([]ent.Value, 0, len(m.removedshares))
		for id := range m.removedshares {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgePrinters:
		ids := make([]ent.Value, 0, len(m.removedprinters))
		for id := range m.removedprinters {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeNetworkadapters:
		ids := make([]ent.Value, 0, len(m.removednetworkadapters))
		for id := range m.removednetworkadapters {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeDeployments:
		ids := make([]ent.Value, 0, len(m.removeddeployments))
		for id := range m.removeddeployments {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeUpdates:
		ids := make([]ent.Value, 0, len(m.removedupdates))
		for id := range m.removedupdates {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeWingetcfgexclusions:
		ids := make([]ent.Value, 0, len(m.removedwingetcfgexclusions))
		for id := range m.removedwingetcfgexclusions {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeMemoryslots:
		ids := make([]ent.Value, 0, len(m.removedmemoryslots))
		for id := range m.removedmemoryslots {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeProfileissue:
		ids := make([]ent.Value, 0, len(m.removedprofileissue))
		for id := range m.removedprofileissue {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeSite:
		ids := make([]ent.Value, 0, len(m.removedsite))
		for id := range m.removedsite {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgePhysicaldisks:
		ids := make([]ent.Value, 0, len(m.removedphysicaldisks))
		for id := range m.removedphysicaldisks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 21)
	if m.clearedcomputer {
		edges = append(edges, agent.EdgeComputer)
	}
	if m.clearedoperatingsystem {
		edges = append(edges, agent.EdgeOperatingsystem)
	}
	if m.clearedsystemupdate {
		edges = append(edges, agent.EdgeSystemupdate)
	}
	if m.clearedantivirus {
		edges = append(edges, agent.EdgeAntivirus)
	}
	if m.clearedlogicaldisks {
		edges = append(edges, agent.EdgeLogicaldisks)
	}
	if m.clearedapps {
		edges = append(edges, agent.EdgeApps)
	}
	if m.clearedmonitors {
		edges = append(edges, agent.EdgeMonitors)
	}
	if m.clearedshares {
		edges = append(edges, agent.EdgeShares)
	}
	if m.clearedprinters {
		edges = append(edges, agent.EdgePrinters)
	}
	if m.clearednetworkadapters {
		edges = append(edges, agent.EdgeNetworkadapters)
	}
	if m.cleareddeployments {
		edges = append(edges, agent.EdgeDeployments)
	}
	if m.clearedupdates {
		edges = append(edges, agent.EdgeUpdates)
	}
	if m.clearedtags {
		edges = append(edges, agent.EdgeTags)
	}
	if m.clearedmetadata {
		edges = append(edges, agent.EdgeMetadata)
	}
	if m.clearedwingetcfgexclusions {
		edges = append(edges, agent.EdgeWingetcfgexclusions)
	}
	if m.clearedmemoryslots {
		edges = append(edges, agent.EdgeMemoryslots)
	}
	if m.clearedrelease {
		edges = append(edges, agent.EdgeRelease)
	}
	if m.clearedprofileissue {
		edges = append(edges, agent.EdgeProfileissue)
	}
	if m.clearedsite {
		edges = append(edges, agent.EdgeSite)
	}
	if m.clearedphysicaldisks {
		edges = append(edges, agent.EdgePhysicaldisks)
	}
	if m.clearednetbird {
		edges = append(edges, agent.EdgeNetbird)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	switch name {
	case agent.EdgeComputer:
		return m.clearedcomputer
	case agent.EdgeOperatingsystem:
		return m.clearedoperatingsystem
	case agent.EdgeSystemupdate:
		return m.clearedsystemupdate
	case agent.EdgeAntivirus:
		return m.clearedantivirus
	case agent.EdgeLogicaldisks:
		return m.clearedlogicaldisks
	case agent.EdgeApps:
		return m.clearedapps
	case agent.EdgeMonitors:
		return m.clearedmonitors
	case agent.EdgeShares:
		return m.clearedshares
	case agent.EdgePrinters:
		return m.clearedprinters
	case agent.EdgeNetworkadapters:
		return m.clearednetworkadapters
	case agent.EdgeDeployments:
		return m.cleareddeployments
	case agent.EdgeUpdates:
		return m.clearedupdates
	case agent.EdgeTags:
		return m.clearedtags
	case agent.EdgeMetadata:
		return m.clearedmetadata
	case agent.EdgeWingetcfgexclusions:
		return m.clearedwingetcfgexclusions
	case agent.EdgeMemoryslots:
		return m.clearedmemoryslots
	case agent.EdgeRelease:
		return m.clearedrelease
	case agent.EdgeProfileissue:
		return m.clearedprofileissue
	case agent.EdgeSite:
		return m.clearedsite
	case agent.EdgePhysicaldisks:
		return m.clearedphysicaldisks
	case agent.EdgeNetbird:
		return m.clearednetbird
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	switch name {
	case agent.EdgeComputer:
		m.ClearComputer()
		return nil
	case agent.EdgeOperatingsystem:
		m.ClearOperatingsystem()
		return nil
	case agent.EdgeSystemupdate:
		m.ClearSystemupdate()
		return nil
	case agent.EdgeAntivirus:
		m.ClearAntivirus()
		return nil
	case agent.EdgeRelease:
		m.ClearRelease()
		return nil
	case agent.EdgeNetbird:
		m.ClearNetbird()
		return nil
	}
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	switch name {
	case agent.EdgeComputer:
		m.ResetComputer()
		return nil
	case agent.EdgeOperatingsystem:
		m.ResetOperatingsystem()
		return nil
	case agent.EdgeSystemupdate:
		m.ResetSystemupdate()
		return nil
	case agent.EdgeAntivirus:
		m.ResetAntivirus()
		return nil
	case agent.EdgeLogicaldisks:
		m.ResetLogicaldisks()
		return nil
	case agent.EdgeApps:
		m.ResetApps()
		return nil
	case agent.EdgeMonitors:
		m.ResetMonitors()
		return nil
	case agent.EdgeShares:
		m.ResetShares()
		return nil
	case agent.EdgePrinters:
		m.ResetPrinters()
		return nil
	case agent.EdgeNetworkadapters:
		m.ResetNetworkadapters()
		return nil
	case agent.EdgeDeployments:
		m.ResetDeployments()
		return nil
	case agent.EdgeUpdates:
		m.ResetUpdates()
		return nil
	case agent.EdgeTags:
		m.ResetTags()
		return nil
	case agent.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case agent.EdgeWingetcfgexclusions:
		m.ResetWingetcfgexclusions()
		return nil
	case agent.EdgeMemoryslots:
		m.ResetMemoryslots()
		return nil
	case agent.EdgeRelease:
		m.ResetRelease()
		return nil
	case agent.EdgeProfileissue:
		m.ResetProfileissue()
		return nil
	case agent.EdgeSite:
		m.ResetSite()
		return nil
	case agent.EdgePhysicaldisks:
		m.ResetPhysicaldisks()
		return nil
	case agent.EdgeNetbird:
		m.ResetNetbird()
		return nil
	}
	return fmt.Errorf("unknown Agent edge %s", name)
}

// AntivirusMutation represents an operation that mutates the Antivirus nodes in the graph.
type AntivirusMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	is_active     *bool
	is_updated    *bool
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Antivirus, error)
	predicates    []predicate.Antivirus
}

var _ ent.Mutation = (*AntivirusMutation)(nil)

// antivirusOption allows management of the mutation configuration using functional options.
type antivirusOption func(*AntivirusMutation)

// newAntivirusMutation creates new mutation for the Antivirus entity.
func newAntivirusMutation(c config, op Op, opts ...antivirusOption) *AntivirusMutation {
	m := &AntivirusMutation{
		config:        c,
		op:            op,
		typ:           TypeAntivirus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAntivirusID sets the ID field of the mutation.
func withAntivirusID(id int) antivirusOption {
	return func(m *AntivirusMutation) {
		var (
			err   error
			once  sync.Once
			value *Antivirus
		)
		m.oldValue = func(ctx context.Context) (*Antivirus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Antivirus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAntivirus sets the old Antivirus of the mutation.
func withAntivirus(node *Antivirus) antivirusOption {
	return func(m *AntivirusMutation) {
		m.oldValue = func(context.Context) (*Antivirus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AntivirusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AntivirusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AntivirusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AntivirusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Antivirus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AntivirusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AntivirusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Antivirus entity.
// If the Antivirus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AntivirusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AntivirusMutation) ResetName() {
	m.name = nil
}

// SetIsActive sets the "is_active" field.
func (m *AntivirusMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *AntivirusMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Antivirus entity.
// If the Antivirus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AntivirusMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *AntivirusMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsUpdated sets the "is_updated" field.
func (m *AntivirusMutation) SetIsUpdated(b bool) {
	m.is_updated = &b
}

// IsUpdated returns the value of the "is_updated" field in the mutation.
func (m *AntivirusMutation) IsUpdated() (r bool, exists bool) {
	v := m.is_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUpdated returns the old "is_updated" field's value of the Antivirus entity.
// If the Antivirus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AntivirusMutation) OldIsUpdated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUpdated: %w", err)
	}
	return oldValue.IsUpdated, nil
}

// ResetIsUpdated resets all changes to the "is_updated" field.
func (m *AntivirusMutation) ResetIsUpdated() {
	m.is_updated = nil
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *AntivirusMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *AntivirusMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *AntivirusMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AntivirusMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AntivirusMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AntivirusMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the AntivirusMutation builder.
func (m *AntivirusMutation) Where(ps ...predicate.Antivirus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AntivirusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AntivirusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Antivirus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AntivirusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AntivirusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Antivirus).
func (m *AntivirusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AntivirusMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, antivirus.FieldName)
	}
	if m.is_active != nil {
		fields = append(fields, antivirus.FieldIsActive)
	}
	if m.is_updated != nil {
		fields = append(fields, antivirus.FieldIsUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AntivirusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case antivirus.FieldName:
		return m.Name()
	case antivirus.FieldIsActive:
		return m.IsActive()
	case antivirus.FieldIsUpdated:
		return m.IsUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AntivirusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case antivirus.FieldName:
		return m.OldName(ctx)
	case antivirus.FieldIsActive:
		return m.OldIsActive(ctx)
	case antivirus.FieldIsUpdated:
		return m.OldIsUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Antivirus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AntivirusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case antivirus.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case antivirus.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case antivirus.FieldIsUpdated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Antivirus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AntivirusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AntivirusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AntivirusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Antivirus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AntivirusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AntivirusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AntivirusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Antivirus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AntivirusMutation) ResetField(name string) error {
	switch name {
	case antivirus.FieldName:
		m.ResetName()
		return nil
	case antivirus.FieldIsActive:
		m.ResetIsActive()
		return nil
	case antivirus.FieldIsUpdated:
		m.ResetIsUpdated()
		return nil
	}
	return fmt.Errorf("unknown Antivirus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AntivirusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, antivirus.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AntivirusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case antivirus.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AntivirusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AntivirusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AntivirusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, antivirus.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AntivirusMutation) EdgeCleared(name string) bool {
	switch name {
	case antivirus.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AntivirusMutation) ClearEdge(name string) error {
	switch name {
	case antivirus.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Antivirus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AntivirusMutation) ResetEdge(name string) error {
	switch name {
	case antivirus.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Antivirus edge %s", name)
}

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	version       *string
	publisher     *string
	install_date  *string
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*App, error)
	predicates    []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id int) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *AppMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AppMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AppMutation) ResetVersion() {
	m.version = nil
}

// SetPublisher sets the "publisher" field.
func (m *AppMutation) SetPublisher(s string) {
	m.publisher = &s
}

// Publisher returns the value of the "publisher" field in the mutation.
func (m *AppMutation) Publisher() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisher returns the old "publisher" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldPublisher(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisher: %w", err)
	}
	return oldValue.Publisher, nil
}

// ClearPublisher clears the value of the "publisher" field.
func (m *AppMutation) ClearPublisher() {
	m.publisher = nil
	m.clearedFields[app.FieldPublisher] = struct{}{}
}

// PublisherCleared returns if the "publisher" field was cleared in this mutation.
func (m *AppMutation) PublisherCleared() bool {
	_, ok := m.clearedFields[app.FieldPublisher]
	return ok
}

// ResetPublisher resets all changes to the "publisher" field.
func (m *AppMutation) ResetPublisher() {
	m.publisher = nil
	delete(m.clearedFields, app.FieldPublisher)
}

// SetInstallDate sets the "install_date" field.
func (m *AppMutation) SetInstallDate(s string) {
	m.install_date = &s
}

// InstallDate returns the value of the "install_date" field in the mutation.
func (m *AppMutation) InstallDate() (r string, exists bool) {
	v := m.install_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallDate returns the old "install_date" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldInstallDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallDate: %w", err)
	}
	return oldValue.InstallDate, nil
}

// ClearInstallDate clears the value of the "install_date" field.
func (m *AppMutation) ClearInstallDate() {
	m.install_date = nil
	m.clearedFields[app.FieldInstallDate] = struct{}{}
}

// InstallDateCleared returns if the "install_date" field was cleared in this mutation.
func (m *AppMutation) InstallDateCleared() bool {
	_, ok := m.clearedFields[app.FieldInstallDate]
	return ok
}

// ResetInstallDate resets all changes to the "install_date" field.
func (m *AppMutation) ResetInstallDate() {
	m.install_date = nil
	delete(m.clearedFields, app.FieldInstallDate)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *AppMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *AppMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *AppMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AppMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AppMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AppMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.version != nil {
		fields = append(fields, app.FieldVersion)
	}
	if m.publisher != nil {
		fields = append(fields, app.FieldPublisher)
	}
	if m.install_date != nil {
		fields = append(fields, app.FieldInstallDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldName:
		return m.Name()
	case app.FieldVersion:
		return m.Version()
	case app.FieldPublisher:
		return m.Publisher()
	case app.FieldInstallDate:
		return m.InstallDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldVersion:
		return m.OldVersion(ctx)
	case app.FieldPublisher:
		return m.OldPublisher(ctx)
	case app.FieldInstallDate:
		return m.OldInstallDate(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case app.FieldPublisher:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisher(v)
		return nil
	case app.FieldInstallDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallDate(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldPublisher) {
		fields = append(fields, app.FieldPublisher)
	}
	if m.FieldCleared(app.FieldInstallDate) {
		fields = append(fields, app.FieldInstallDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldPublisher:
		m.ClearPublisher()
		return nil
	case app.FieldInstallDate:
		m.ClearInstallDate()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldVersion:
		m.ResetVersion()
		return nil
	case app.FieldPublisher:
		m.ResetPublisher()
		return nil
	case app.FieldInstallDate:
		m.ResetInstallDate()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, app.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, app.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	case app.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AuthenticationMutation represents an operation that mutates the Authentication nodes in the graph.
type AuthenticationMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	use_certificates            *bool
	allow_register              *bool
	use_OIDC                    *bool
	_OIDC_provider              *string
	_OIDC_issuer_url            *string
	_OIDC_client_id             *string
	_OIDC_role                  *string
	_OIDC_cookie_encription_key *string
	_OIDC_keycloak_public_key   *string
	_OIDC_auto_create_account   *bool
	_OIDC_auto_approve          *bool
	use_passwd                  *bool
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*Authentication, error)
	predicates                  []predicate.Authentication
}

var _ ent.Mutation = (*AuthenticationMutation)(nil)

// authenticationOption allows management of the mutation configuration using functional options.
type authenticationOption func(*AuthenticationMutation)

// newAuthenticationMutation creates new mutation for the Authentication entity.
func newAuthenticationMutation(c config, op Op, opts ...authenticationOption) *AuthenticationMutation {
	m := &AuthenticationMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthentication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthenticationID sets the ID field of the mutation.
func withAuthenticationID(id int) authenticationOption {
	return func(m *AuthenticationMutation) {
		var (
			err   error
			once  sync.Once
			value *Authentication
		)
		m.oldValue = func(ctx context.Context) (*Authentication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Authentication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthentication sets the old Authentication of the mutation.
func withAuthentication(node *Authentication) authenticationOption {
	return func(m *AuthenticationMutation) {
		m.oldValue = func(context.Context) (*Authentication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthenticationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthenticationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthenticationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthenticationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Authentication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUseCertificates sets the "use_certificates" field.
func (m *AuthenticationMutation) SetUseCertificates(b bool) {
	m.use_certificates = &b
}

// UseCertificates returns the value of the "use_certificates" field in the mutation.
func (m *AuthenticationMutation) UseCertificates() (r bool, exists bool) {
	v := m.use_certificates
	if v == nil {
		return
	}
	return *v, true
}

// OldUseCertificates returns the old "use_certificates" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldUseCertificates(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseCertificates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseCertificates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseCertificates: %w", err)
	}
	return oldValue.UseCertificates, nil
}

// ClearUseCertificates clears the value of the "use_certificates" field.
func (m *AuthenticationMutation) ClearUseCertificates() {
	m.use_certificates = nil
	m.clearedFields[authentication.FieldUseCertificates] = struct{}{}
}

// UseCertificatesCleared returns if the "use_certificates" field was cleared in this mutation.
func (m *AuthenticationMutation) UseCertificatesCleared() bool {
	_, ok := m.clearedFields[authentication.FieldUseCertificates]
	return ok
}

// ResetUseCertificates resets all changes to the "use_certificates" field.
func (m *AuthenticationMutation) ResetUseCertificates() {
	m.use_certificates = nil
	delete(m.clearedFields, authentication.FieldUseCertificates)
}

// SetAllowRegister sets the "allow_register" field.
func (m *AuthenticationMutation) SetAllowRegister(b bool) {
	m.allow_register = &b
}

// AllowRegister returns the value of the "allow_register" field in the mutation.
func (m *AuthenticationMutation) AllowRegister() (r bool, exists bool) {
	v := m.allow_register
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowRegister returns the old "allow_register" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldAllowRegister(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowRegister is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowRegister requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowRegister: %w", err)
	}
	return oldValue.AllowRegister, nil
}

// ClearAllowRegister clears the value of the "allow_register" field.
func (m *AuthenticationMutation) ClearAllowRegister() {
	m.allow_register = nil
	m.clearedFields[authentication.FieldAllowRegister] = struct{}{}
}

// AllowRegisterCleared returns if the "allow_register" field was cleared in this mutation.
func (m *AuthenticationMutation) AllowRegisterCleared() bool {
	_, ok := m.clearedFields[authentication.FieldAllowRegister]
	return ok
}

// ResetAllowRegister resets all changes to the "allow_register" field.
func (m *AuthenticationMutation) ResetAllowRegister() {
	m.allow_register = nil
	delete(m.clearedFields, authentication.FieldAllowRegister)
}

// SetUseOIDC sets the "use_OIDC" field.
func (m *AuthenticationMutation) SetUseOIDC(b bool) {
	m.use_OIDC = &b
}

// UseOIDC returns the value of the "use_OIDC" field in the mutation.
func (m *AuthenticationMutation) UseOIDC() (r bool, exists bool) {
	v := m.use_OIDC
	if v == nil {
		return
	}
	return *v, true
}

// OldUseOIDC returns the old "use_OIDC" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldUseOIDC(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseOIDC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseOIDC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseOIDC: %w", err)
	}
	return oldValue.UseOIDC, nil
}

// ClearUseOIDC clears the value of the "use_OIDC" field.
func (m *AuthenticationMutation) ClearUseOIDC() {
	m.use_OIDC = nil
	m.clearedFields[authentication.FieldUseOIDC] = struct{}{}
}

// UseOIDCCleared returns if the "use_OIDC" field was cleared in this mutation.
func (m *AuthenticationMutation) UseOIDCCleared() bool {
	_, ok := m.clearedFields[authentication.FieldUseOIDC]
	return ok
}

// ResetUseOIDC resets all changes to the "use_OIDC" field.
func (m *AuthenticationMutation) ResetUseOIDC() {
	m.use_OIDC = nil
	delete(m.clearedFields, authentication.FieldUseOIDC)
}

// SetOIDCProvider sets the "OIDC_provider" field.
func (m *AuthenticationMutation) SetOIDCProvider(s string) {
	m._OIDC_provider = &s
}

// OIDCProvider returns the value of the "OIDC_provider" field in the mutation.
func (m *AuthenticationMutation) OIDCProvider() (r string, exists bool) {
	v := m._OIDC_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldOIDCProvider returns the old "OIDC_provider" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldOIDCProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOIDCProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOIDCProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOIDCProvider: %w", err)
	}
	return oldValue.OIDCProvider, nil
}

// ClearOIDCProvider clears the value of the "OIDC_provider" field.
func (m *AuthenticationMutation) ClearOIDCProvider() {
	m._OIDC_provider = nil
	m.clearedFields[authentication.FieldOIDCProvider] = struct{}{}
}

// OIDCProviderCleared returns if the "OIDC_provider" field was cleared in this mutation.
func (m *AuthenticationMutation) OIDCProviderCleared() bool {
	_, ok := m.clearedFields[authentication.FieldOIDCProvider]
	return ok
}

// ResetOIDCProvider resets all changes to the "OIDC_provider" field.
func (m *AuthenticationMutation) ResetOIDCProvider() {
	m._OIDC_provider = nil
	delete(m.clearedFields, authentication.FieldOIDCProvider)
}

// SetOIDCIssuerURL sets the "OIDC_issuer_url" field.
func (m *AuthenticationMutation) SetOIDCIssuerURL(s string) {
	m._OIDC_issuer_url = &s
}

// OIDCIssuerURL returns the value of the "OIDC_issuer_url" field in the mutation.
func (m *AuthenticationMutation) OIDCIssuerURL() (r string, exists bool) {
	v := m._OIDC_issuer_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOIDCIssuerURL returns the old "OIDC_issuer_url" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldOIDCIssuerURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOIDCIssuerURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOIDCIssuerURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOIDCIssuerURL: %w", err)
	}
	return oldValue.OIDCIssuerURL, nil
}

// ClearOIDCIssuerURL clears the value of the "OIDC_issuer_url" field.
func (m *AuthenticationMutation) ClearOIDCIssuerURL() {
	m._OIDC_issuer_url = nil
	m.clearedFields[authentication.FieldOIDCIssuerURL] = struct{}{}
}

// OIDCIssuerURLCleared returns if the "OIDC_issuer_url" field was cleared in this mutation.
func (m *AuthenticationMutation) OIDCIssuerURLCleared() bool {
	_, ok := m.clearedFields[authentication.FieldOIDCIssuerURL]
	return ok
}

// ResetOIDCIssuerURL resets all changes to the "OIDC_issuer_url" field.
func (m *AuthenticationMutation) ResetOIDCIssuerURL() {
	m._OIDC_issuer_url = nil
	delete(m.clearedFields, authentication.FieldOIDCIssuerURL)
}

// SetOIDCClientID sets the "OIDC_client_id" field.
func (m *AuthenticationMutation) SetOIDCClientID(s string) {
	m._OIDC_client_id = &s
}

// OIDCClientID returns the value of the "OIDC_client_id" field in the mutation.
func (m *AuthenticationMutation) OIDCClientID() (r string, exists bool) {
	v := m._OIDC_client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOIDCClientID returns the old "OIDC_client_id" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldOIDCClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOIDCClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOIDCClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOIDCClientID: %w", err)
	}
	return oldValue.OIDCClientID, nil
}

// ClearOIDCClientID clears the value of the "OIDC_client_id" field.
func (m *AuthenticationMutation) ClearOIDCClientID() {
	m._OIDC_client_id = nil
	m.clearedFields[authentication.FieldOIDCClientID] = struct{}{}
}

// OIDCClientIDCleared returns if the "OIDC_client_id" field was cleared in this mutation.
func (m *AuthenticationMutation) OIDCClientIDCleared() bool {
	_, ok := m.clearedFields[authentication.FieldOIDCClientID]
	return ok
}

// ResetOIDCClientID resets all changes to the "OIDC_client_id" field.
func (m *AuthenticationMutation) ResetOIDCClientID() {
	m._OIDC_client_id = nil
	delete(m.clearedFields, authentication.FieldOIDCClientID)
}

// SetOIDCRole sets the "OIDC_role" field.
func (m *AuthenticationMutation) SetOIDCRole(s string) {
	m._OIDC_role = &s
}

// OIDCRole returns the value of the "OIDC_role" field in the mutation.
func (m *AuthenticationMutation) OIDCRole() (r string, exists bool) {
	v := m._OIDC_role
	if v == nil {
		return
	}
	return *v, true
}

// OldOIDCRole returns the old "OIDC_role" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldOIDCRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOIDCRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOIDCRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOIDCRole: %w", err)
	}
	return oldValue.OIDCRole, nil
}

// ClearOIDCRole clears the value of the "OIDC_role" field.
func (m *AuthenticationMutation) ClearOIDCRole() {
	m._OIDC_role = nil
	m.clearedFields[authentication.FieldOIDCRole] = struct{}{}
}

// OIDCRoleCleared returns if the "OIDC_role" field was cleared in this mutation.
func (m *AuthenticationMutation) OIDCRoleCleared() bool {
	_, ok := m.clearedFields[authentication.FieldOIDCRole]
	return ok
}

// ResetOIDCRole resets all changes to the "OIDC_role" field.
func (m *AuthenticationMutation) ResetOIDCRole() {
	m._OIDC_role = nil
	delete(m.clearedFields, authentication.FieldOIDCRole)
}

// SetOIDCCookieEncriptionKey sets the "OIDC_cookie_encription_key" field.
func (m *AuthenticationMutation) SetOIDCCookieEncriptionKey(s string) {
	m._OIDC_cookie_encription_key = &s
}

// OIDCCookieEncriptionKey returns the value of the "OIDC_cookie_encription_key" field in the mutation.
func (m *AuthenticationMutation) OIDCCookieEncriptionKey() (r string, exists bool) {
	v := m._OIDC_cookie_encription_key
	if v == nil {
		return
	}
	return *v, true
}

// OldOIDCCookieEncriptionKey returns the old "OIDC_cookie_encription_key" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldOIDCCookieEncriptionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOIDCCookieEncriptionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOIDCCookieEncriptionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOIDCCookieEncriptionKey: %w", err)
	}
	return oldValue.OIDCCookieEncriptionKey, nil
}

// ClearOIDCCookieEncriptionKey clears the value of the "OIDC_cookie_encription_key" field.
func (m *AuthenticationMutation) ClearOIDCCookieEncriptionKey() {
	m._OIDC_cookie_encription_key = nil
	m.clearedFields[authentication.FieldOIDCCookieEncriptionKey] = struct{}{}
}

// OIDCCookieEncriptionKeyCleared returns if the "OIDC_cookie_encription_key" field was cleared in this mutation.
func (m *AuthenticationMutation) OIDCCookieEncriptionKeyCleared() bool {
	_, ok := m.clearedFields[authentication.FieldOIDCCookieEncriptionKey]
	return ok
}

// ResetOIDCCookieEncriptionKey resets all changes to the "OIDC_cookie_encription_key" field.
func (m *AuthenticationMutation) ResetOIDCCookieEncriptionKey() {
	m._OIDC_cookie_encription_key = nil
	delete(m.clearedFields, authentication.FieldOIDCCookieEncriptionKey)
}

// SetOIDCKeycloakPublicKey sets the "OIDC_keycloak_public_key" field.
func (m *AuthenticationMutation) SetOIDCKeycloakPublicKey(s string) {
	m._OIDC_keycloak_public_key = &s
}

// OIDCKeycloakPublicKey returns the value of the "OIDC_keycloak_public_key" field in the mutation.
func (m *AuthenticationMutation) OIDCKeycloakPublicKey() (r string, exists bool) {
	v := m._OIDC_keycloak_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldOIDCKeycloakPublicKey returns the old "OIDC_keycloak_public_key" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldOIDCKeycloakPublicKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOIDCKeycloakPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOIDCKeycloakPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOIDCKeycloakPublicKey: %w", err)
	}
	return oldValue.OIDCKeycloakPublicKey, nil
}

// ClearOIDCKeycloakPublicKey clears the value of the "OIDC_keycloak_public_key" field.
func (m *AuthenticationMutation) ClearOIDCKeycloakPublicKey() {
	m._OIDC_keycloak_public_key = nil
	m.clearedFields[authentication.FieldOIDCKeycloakPublicKey] = struct{}{}
}

// OIDCKeycloakPublicKeyCleared returns if the "OIDC_keycloak_public_key" field was cleared in this mutation.
func (m *AuthenticationMutation) OIDCKeycloakPublicKeyCleared() bool {
	_, ok := m.clearedFields[authentication.FieldOIDCKeycloakPublicKey]
	return ok
}

// ResetOIDCKeycloakPublicKey resets all changes to the "OIDC_keycloak_public_key" field.
func (m *AuthenticationMutation) ResetOIDCKeycloakPublicKey() {
	m._OIDC_keycloak_public_key = nil
	delete(m.clearedFields, authentication.FieldOIDCKeycloakPublicKey)
}

// SetOIDCAutoCreateAccount sets the "OIDC_auto_create_account" field.
func (m *AuthenticationMutation) SetOIDCAutoCreateAccount(b bool) {
	m._OIDC_auto_create_account = &b
}

// OIDCAutoCreateAccount returns the value of the "OIDC_auto_create_account" field in the mutation.
func (m *AuthenticationMutation) OIDCAutoCreateAccount() (r bool, exists bool) {
	v := m._OIDC_auto_create_account
	if v == nil {
		return
	}
	return *v, true
}

// OldOIDCAutoCreateAccount returns the old "OIDC_auto_create_account" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldOIDCAutoCreateAccount(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOIDCAutoCreateAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOIDCAutoCreateAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOIDCAutoCreateAccount: %w", err)
	}
	return oldValue.OIDCAutoCreateAccount, nil
}

// ClearOIDCAutoCreateAccount clears the value of the "OIDC_auto_create_account" field.
func (m *AuthenticationMutation) ClearOIDCAutoCreateAccount() {
	m._OIDC_auto_create_account = nil
	m.clearedFields[authentication.FieldOIDCAutoCreateAccount] = struct{}{}
}

// OIDCAutoCreateAccountCleared returns if the "OIDC_auto_create_account" field was cleared in this mutation.
func (m *AuthenticationMutation) OIDCAutoCreateAccountCleared() bool {
	_, ok := m.clearedFields[authentication.FieldOIDCAutoCreateAccount]
	return ok
}

// ResetOIDCAutoCreateAccount resets all changes to the "OIDC_auto_create_account" field.
func (m *AuthenticationMutation) ResetOIDCAutoCreateAccount() {
	m._OIDC_auto_create_account = nil
	delete(m.clearedFields, authentication.FieldOIDCAutoCreateAccount)
}

// SetOIDCAutoApprove sets the "OIDC_auto_approve" field.
func (m *AuthenticationMutation) SetOIDCAutoApprove(b bool) {
	m._OIDC_auto_approve = &b
}

// OIDCAutoApprove returns the value of the "OIDC_auto_approve" field in the mutation.
func (m *AuthenticationMutation) OIDCAutoApprove() (r bool, exists bool) {
	v := m._OIDC_auto_approve
	if v == nil {
		return
	}
	return *v, true
}

// OldOIDCAutoApprove returns the old "OIDC_auto_approve" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldOIDCAutoApprove(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOIDCAutoApprove is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOIDCAutoApprove requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOIDCAutoApprove: %w", err)
	}
	return oldValue.OIDCAutoApprove, nil
}

// ClearOIDCAutoApprove clears the value of the "OIDC_auto_approve" field.
func (m *AuthenticationMutation) ClearOIDCAutoApprove() {
	m._OIDC_auto_approve = nil
	m.clearedFields[authentication.FieldOIDCAutoApprove] = struct{}{}
}

// OIDCAutoApproveCleared returns if the "OIDC_auto_approve" field was cleared in this mutation.
func (m *AuthenticationMutation) OIDCAutoApproveCleared() bool {
	_, ok := m.clearedFields[authentication.FieldOIDCAutoApprove]
	return ok
}

// ResetOIDCAutoApprove resets all changes to the "OIDC_auto_approve" field.
func (m *AuthenticationMutation) ResetOIDCAutoApprove() {
	m._OIDC_auto_approve = nil
	delete(m.clearedFields, authentication.FieldOIDCAutoApprove)
}

// SetUsePasswd sets the "use_passwd" field.
func (m *AuthenticationMutation) SetUsePasswd(b bool) {
	m.use_passwd = &b
}

// UsePasswd returns the value of the "use_passwd" field in the mutation.
func (m *AuthenticationMutation) UsePasswd() (r bool, exists bool) {
	v := m.use_passwd
	if v == nil {
		return
	}
	return *v, true
}

// OldUsePasswd returns the old "use_passwd" field's value of the Authentication entity.
// If the Authentication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthenticationMutation) OldUsePasswd(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsePasswd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsePasswd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsePasswd: %w", err)
	}
	return oldValue.UsePasswd, nil
}

// ClearUsePasswd clears the value of the "use_passwd" field.
func (m *AuthenticationMutation) ClearUsePasswd() {
	m.use_passwd = nil
	m.clearedFields[authentication.FieldUsePasswd] = struct{}{}
}

// UsePasswdCleared returns if the "use_passwd" field was cleared in this mutation.
func (m *AuthenticationMutation) UsePasswdCleared() bool {
	_, ok := m.clearedFields[authentication.FieldUsePasswd]
	return ok
}

// ResetUsePasswd resets all changes to the "use_passwd" field.
func (m *AuthenticationMutation) ResetUsePasswd() {
	m.use_passwd = nil
	delete(m.clearedFields, authentication.FieldUsePasswd)
}

// Where appends a list predicates to the AuthenticationMutation builder.
func (m *AuthenticationMutation) Where(ps ...predicate.Authentication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthenticationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthenticationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Authentication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthenticationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthenticationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Authentication).
func (m *AuthenticationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthenticationMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.use_certificates != nil {
		fields = append(fields, authentication.FieldUseCertificates)
	}
	if m.allow_register != nil {
		fields = append(fields, authentication.FieldAllowRegister)
	}
	if m.use_OIDC != nil {
		fields = append(fields, authentication.FieldUseOIDC)
	}
	if m._OIDC_provider != nil {
		fields = append(fields, authentication.FieldOIDCProvider)
	}
	if m._OIDC_issuer_url != nil {
		fields = append(fields, authentication.FieldOIDCIssuerURL)
	}
	if m._OIDC_client_id != nil {
		fields = append(fields, authentication.FieldOIDCClientID)
	}
	if m._OIDC_role != nil {
		fields = append(fields, authentication.FieldOIDCRole)
	}
	if m._OIDC_cookie_encription_key != nil {
		fields = append(fields, authentication.FieldOIDCCookieEncriptionKey)
	}
	if m._OIDC_keycloak_public_key != nil {
		fields = append(fields, authentication.FieldOIDCKeycloakPublicKey)
	}
	if m._OIDC_auto_create_account != nil {
		fields = append(fields, authentication.FieldOIDCAutoCreateAccount)
	}
	if m._OIDC_auto_approve != nil {
		fields = append(fields, authentication.FieldOIDCAutoApprove)
	}
	if m.use_passwd != nil {
		fields = append(fields, authentication.FieldUsePasswd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthenticationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authentication.FieldUseCertificates:
		return m.UseCertificates()
	case authentication.FieldAllowRegister:
		return m.AllowRegister()
	case authentication.FieldUseOIDC:
		return m.UseOIDC()
	case authentication.FieldOIDCProvider:
		return m.OIDCProvider()
	case authentication.FieldOIDCIssuerURL:
		return m.OIDCIssuerURL()
	case authentication.FieldOIDCClientID:
		return m.OIDCClientID()
	case authentication.FieldOIDCRole:
		return m.OIDCRole()
	case authentication.FieldOIDCCookieEncriptionKey:
		return m.OIDCCookieEncriptionKey()
	case authentication.FieldOIDCKeycloakPublicKey:
		return m.OIDCKeycloakPublicKey()
	case authentication.FieldOIDCAutoCreateAccount:
		return m.OIDCAutoCreateAccount()
	case authentication.FieldOIDCAutoApprove:
		return m.OIDCAutoApprove()
	case authentication.FieldUsePasswd:
		return m.UsePasswd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthenticationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authentication.FieldUseCertificates:
		return m.OldUseCertificates(ctx)
	case authentication.FieldAllowRegister:
		return m.OldAllowRegister(ctx)
	case authentication.FieldUseOIDC:
		return m.OldUseOIDC(ctx)
	case authentication.FieldOIDCProvider:
		return m.OldOIDCProvider(ctx)
	case authentication.FieldOIDCIssuerURL:
		return m.OldOIDCIssuerURL(ctx)
	case authentication.FieldOIDCClientID:
		return m.OldOIDCClientID(ctx)
	case authentication.FieldOIDCRole:
		return m.OldOIDCRole(ctx)
	case authentication.FieldOIDCCookieEncriptionKey:
		return m.OldOIDCCookieEncriptionKey(ctx)
	case authentication.FieldOIDCKeycloakPublicKey:
		return m.OldOIDCKeycloakPublicKey(ctx)
	case authentication.FieldOIDCAutoCreateAccount:
		return m.OldOIDCAutoCreateAccount(ctx)
	case authentication.FieldOIDCAutoApprove:
		return m.OldOIDCAutoApprove(ctx)
	case authentication.FieldUsePasswd:
		return m.OldUsePasswd(ctx)
	}
	return nil, fmt.Errorf("unknown Authentication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthenticationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authentication.FieldUseCertificates:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseCertificates(v)
		return nil
	case authentication.FieldAllowRegister:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowRegister(v)
		return nil
	case authentication.FieldUseOIDC:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseOIDC(v)
		return nil
	case authentication.FieldOIDCProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOIDCProvider(v)
		return nil
	case authentication.FieldOIDCIssuerURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOIDCIssuerURL(v)
		return nil
	case authentication.FieldOIDCClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOIDCClientID(v)
		return nil
	case authentication.FieldOIDCRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOIDCRole(v)
		return nil
	case authentication.FieldOIDCCookieEncriptionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOIDCCookieEncriptionKey(v)
		return nil
	case authentication.FieldOIDCKeycloakPublicKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOIDCKeycloakPublicKey(v)
		return nil
	case authentication.FieldOIDCAutoCreateAccount:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOIDCAutoCreateAccount(v)
		return nil
	case authentication.FieldOIDCAutoApprove:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOIDCAutoApprove(v)
		return nil
	case authentication.FieldUsePasswd:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsePasswd(v)
		return nil
	}
	return fmt.Errorf("unknown Authentication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthenticationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthenticationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthenticationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Authentication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthenticationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authentication.FieldUseCertificates) {
		fields = append(fields, authentication.FieldUseCertificates)
	}
	if m.FieldCleared(authentication.FieldAllowRegister) {
		fields = append(fields, authentication.FieldAllowRegister)
	}
	if m.FieldCleared(authentication.FieldUseOIDC) {
		fields = append(fields, authentication.FieldUseOIDC)
	}
	if m.FieldCleared(authentication.FieldOIDCProvider) {
		fields = append(fields, authentication.FieldOIDCProvider)
	}
	if m.FieldCleared(authentication.FieldOIDCIssuerURL) {
		fields = append(fields, authentication.FieldOIDCIssuerURL)
	}
	if m.FieldCleared(authentication.FieldOIDCClientID) {
		fields = append(fields, authentication.FieldOIDCClientID)
	}
	if m.FieldCleared(authentication.FieldOIDCRole) {
		fields = append(fields, authentication.FieldOIDCRole)
	}
	if m.FieldCleared(authentication.FieldOIDCCookieEncriptionKey) {
		fields = append(fields, authentication.FieldOIDCCookieEncriptionKey)
	}
	if m.FieldCleared(authentication.FieldOIDCKeycloakPublicKey) {
		fields = append(fields, authentication.FieldOIDCKeycloakPublicKey)
	}
	if m.FieldCleared(authentication.FieldOIDCAutoCreateAccount) {
		fields = append(fields, authentication.FieldOIDCAutoCreateAccount)
	}
	if m.FieldCleared(authentication.FieldOIDCAutoApprove) {
		fields = append(fields, authentication.FieldOIDCAutoApprove)
	}
	if m.FieldCleared(authentication.FieldUsePasswd) {
		fields = append(fields, authentication.FieldUsePasswd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthenticationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthenticationMutation) ClearField(name string) error {
	switch name {
	case authentication.FieldUseCertificates:
		m.ClearUseCertificates()
		return nil
	case authentication.FieldAllowRegister:
		m.ClearAllowRegister()
		return nil
	case authentication.FieldUseOIDC:
		m.ClearUseOIDC()
		return nil
	case authentication.FieldOIDCProvider:
		m.ClearOIDCProvider()
		return nil
	case authentication.FieldOIDCIssuerURL:
		m.ClearOIDCIssuerURL()
		return nil
	case authentication.FieldOIDCClientID:
		m.ClearOIDCClientID()
		return nil
	case authentication.FieldOIDCRole:
		m.ClearOIDCRole()
		return nil
	case authentication.FieldOIDCCookieEncriptionKey:
		m.ClearOIDCCookieEncriptionKey()
		return nil
	case authentication.FieldOIDCKeycloakPublicKey:
		m.ClearOIDCKeycloakPublicKey()
		return nil
	case authentication.FieldOIDCAutoCreateAccount:
		m.ClearOIDCAutoCreateAccount()
		return nil
	case authentication.FieldOIDCAutoApprove:
		m.ClearOIDCAutoApprove()
		return nil
	case authentication.FieldUsePasswd:
		m.ClearUsePasswd()
		return nil
	}
	return fmt.Errorf("unknown Authentication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthenticationMutation) ResetField(name string) error {
	switch name {
	case authentication.FieldUseCertificates:
		m.ResetUseCertificates()
		return nil
	case authentication.FieldAllowRegister:
		m.ResetAllowRegister()
		return nil
	case authentication.FieldUseOIDC:
		m.ResetUseOIDC()
		return nil
	case authentication.FieldOIDCProvider:
		m.ResetOIDCProvider()
		return nil
	case authentication.FieldOIDCIssuerURL:
		m.ResetOIDCIssuerURL()
		return nil
	case authentication.FieldOIDCClientID:
		m.ResetOIDCClientID()
		return nil
	case authentication.FieldOIDCRole:
		m.ResetOIDCRole()
		return nil
	case authentication.FieldOIDCCookieEncriptionKey:
		m.ResetOIDCCookieEncriptionKey()
		return nil
	case authentication.FieldOIDCKeycloakPublicKey:
		m.ResetOIDCKeycloakPublicKey()
		return nil
	case authentication.FieldOIDCAutoCreateAccount:
		m.ResetOIDCAutoCreateAccount()
		return nil
	case authentication.FieldOIDCAutoApprove:
		m.ResetOIDCAutoApprove()
		return nil
	case authentication.FieldUsePasswd:
		m.ResetUsePasswd()
		return nil
	}
	return fmt.Errorf("unknown Authentication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthenticationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthenticationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthenticationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthenticationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthenticationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthenticationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthenticationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Authentication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthenticationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Authentication edge %s", name)
}

// CertificateMutation represents an operation that mutates the Certificate nodes in the graph.
type CertificateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	_type         *certificate.Type
	description   *string
	expiry        *time.Time
	uid           *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Certificate, error)
	predicates    []predicate.Certificate
}

var _ ent.Mutation = (*CertificateMutation)(nil)

// certificateOption allows management of the mutation configuration using functional options.
type certificateOption func(*CertificateMutation)

// newCertificateMutation creates new mutation for the Certificate entity.
func newCertificateMutation(c config, op Op, opts ...certificateOption) *CertificateMutation {
	m := &CertificateMutation{
		config:        c,
		op:            op,
		typ:           TypeCertificate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificateID sets the ID field of the mutation.
func withCertificateID(id int64) certificateOption {
	return func(m *CertificateMutation) {
		var (
			err   error
			once  sync.Once
			value *Certificate
		)
		m.oldValue = func(ctx context.Context) (*Certificate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Certificate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertificate sets the old Certificate of the mutation.
func withCertificate(node *Certificate) certificateOption {
	return func(m *CertificateMutation) {
		m.oldValue = func(context.Context) (*Certificate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Certificate entities.
func (m *CertificateMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificateMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Certificate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *CertificateMutation) SetType(c certificate.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CertificateMutation) GetType() (r certificate.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldType(ctx context.Context) (v certificate.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CertificateMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *CertificateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CertificateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CertificateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[certificate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CertificateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[certificate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CertificateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, certificate.FieldDescription)
}

// SetExpiry sets the "expiry" field.
func (m *CertificateMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *CertificateMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ClearExpiry clears the value of the "expiry" field.
func (m *CertificateMutation) ClearExpiry() {
	m.expiry = nil
	m.clearedFields[certificate.FieldExpiry] = struct{}{}
}

// ExpiryCleared returns if the "expiry" field was cleared in this mutation.
func (m *CertificateMutation) ExpiryCleared() bool {
	_, ok := m.clearedFields[certificate.FieldExpiry]
	return ok
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *CertificateMutation) ResetExpiry() {
	m.expiry = nil
	delete(m.clearedFields, certificate.FieldExpiry)
}

// SetUID sets the "uid" field.
func (m *CertificateMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *CertificateMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ClearUID clears the value of the "uid" field.
func (m *CertificateMutation) ClearUID() {
	m.uid = nil
	m.clearedFields[certificate.FieldUID] = struct{}{}
}

// UIDCleared returns if the "uid" field was cleared in this mutation.
func (m *CertificateMutation) UIDCleared() bool {
	_, ok := m.clearedFields[certificate.FieldUID]
	return ok
}

// ResetUID resets all changes to the "uid" field.
func (m *CertificateMutation) ResetUID() {
	m.uid = nil
	delete(m.clearedFields, certificate.FieldUID)
}

// Where appends a list predicates to the CertificateMutation builder.
func (m *CertificateMutation) Where(ps ...predicate.Certificate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertificateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertificateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Certificate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertificateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertificateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Certificate).
func (m *CertificateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificateMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._type != nil {
		fields = append(fields, certificate.FieldType)
	}
	if m.description != nil {
		fields = append(fields, certificate.FieldDescription)
	}
	if m.expiry != nil {
		fields = append(fields, certificate.FieldExpiry)
	}
	if m.uid != nil {
		fields = append(fields, certificate.FieldUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certificate.FieldType:
		return m.GetType()
	case certificate.FieldDescription:
		return m.Description()
	case certificate.FieldExpiry:
		return m.Expiry()
	case certificate.FieldUID:
		return m.UID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certificate.FieldType:
		return m.OldType(ctx)
	case certificate.FieldDescription:
		return m.OldDescription(ctx)
	case certificate.FieldExpiry:
		return m.OldExpiry(ctx)
	case certificate.FieldUID:
		return m.OldUID(ctx)
	}
	return nil, fmt.Errorf("unknown Certificate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certificate.FieldType:
		v, ok := value.(certificate.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case certificate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case certificate.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case certificate.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	}
	return fmt.Errorf("unknown Certificate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Certificate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certificate.FieldDescription) {
		fields = append(fields, certificate.FieldDescription)
	}
	if m.FieldCleared(certificate.FieldExpiry) {
		fields = append(fields, certificate.FieldExpiry)
	}
	if m.FieldCleared(certificate.FieldUID) {
		fields = append(fields, certificate.FieldUID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificateMutation) ClearField(name string) error {
	switch name {
	case certificate.FieldDescription:
		m.ClearDescription()
		return nil
	case certificate.FieldExpiry:
		m.ClearExpiry()
		return nil
	case certificate.FieldUID:
		m.ClearUID()
		return nil
	}
	return fmt.Errorf("unknown Certificate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificateMutation) ResetField(name string) error {
	switch name {
	case certificate.FieldType:
		m.ResetType()
		return nil
	case certificate.FieldDescription:
		m.ResetDescription()
		return nil
	case certificate.FieldExpiry:
		m.ResetExpiry()
		return nil
	case certificate.FieldUID:
		m.ResetUID()
		return nil
	}
	return fmt.Errorf("unknown Certificate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Certificate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Certificate edge %s", name)
}

// ComputerMutation represents an operation that mutates the Computer nodes in the graph.
type ComputerMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	manufacturer       *string
	model              *string
	serial             *string
	memory             *uint64
	addmemory          *int64
	processor          *string
	processor_cores    *int64
	addprocessor_cores *int64
	processor_arch     *string
	clearedFields      map[string]struct{}
	owner              *string
	clearedowner       bool
	done               bool
	oldValue           func(context.Context) (*Computer, error)
	predicates         []predicate.Computer
}

var _ ent.Mutation = (*ComputerMutation)(nil)

// computerOption allows management of the mutation configuration using functional options.
type computerOption func(*ComputerMutation)

// newComputerMutation creates new mutation for the Computer entity.
func newComputerMutation(c config, op Op, opts ...computerOption) *ComputerMutation {
	m := &ComputerMutation{
		config:        c,
		op:            op,
		typ:           TypeComputer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComputerID sets the ID field of the mutation.
func withComputerID(id int) computerOption {
	return func(m *ComputerMutation) {
		var (
			err   error
			once  sync.Once
			value *Computer
		)
		m.oldValue = func(ctx context.Context) (*Computer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Computer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComputer sets the old Computer of the mutation.
func withComputer(node *Computer) computerOption {
	return func(m *ComputerMutation) {
		m.oldValue = func(context.Context) (*Computer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComputerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComputerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ComputerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ComputerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Computer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetManufacturer sets the "manufacturer" field.
func (m *ComputerMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *ComputerMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *ComputerMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[computer.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *ComputerMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[computer.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *ComputerMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, computer.FieldManufacturer)
}

// SetModel sets the "model" field.
func (m *ComputerMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ComputerMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *ComputerMutation) ClearModel() {
	m.model = nil
	m.clearedFields[computer.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *ComputerMutation) ModelCleared() bool {
	_, ok := m.clearedFields[computer.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *ComputerMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, computer.FieldModel)
}

// SetSerial sets the "serial" field.
func (m *ComputerMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ComputerMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ClearSerial clears the value of the "serial" field.
func (m *ComputerMutation) ClearSerial() {
	m.serial = nil
	m.clearedFields[computer.FieldSerial] = struct{}{}
}

// SerialCleared returns if the "serial" field was cleared in this mutation.
func (m *ComputerMutation) SerialCleared() bool {
	_, ok := m.clearedFields[computer.FieldSerial]
	return ok
}

// ResetSerial resets all changes to the "serial" field.
func (m *ComputerMutation) ResetSerial() {
	m.serial = nil
	delete(m.clearedFields, computer.FieldSerial)
}

// SetMemory sets the "memory" field.
func (m *ComputerMutation) SetMemory(u uint64) {
	m.memory = &u
	m.addmemory = nil
}

// Memory returns the value of the "memory" field in the mutation.
func (m *ComputerMutation) Memory() (r uint64, exists bool) {
	v := m.memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMemory returns the old "memory" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldMemory(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemory: %w", err)
	}
	return oldValue.Memory, nil
}

// AddMemory adds u to the "memory" field.
func (m *ComputerMutation) AddMemory(u int64) {
	if m.addmemory != nil {
		*m.addmemory += u
	} else {
		m.addmemory = &u
	}
}

// AddedMemory returns the value that was added to the "memory" field in this mutation.
func (m *ComputerMutation) AddedMemory() (r int64, exists bool) {
	v := m.addmemory
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemory clears the value of the "memory" field.
func (m *ComputerMutation) ClearMemory() {
	m.memory = nil
	m.addmemory = nil
	m.clearedFields[computer.FieldMemory] = struct{}{}
}

// MemoryCleared returns if the "memory" field was cleared in this mutation.
func (m *ComputerMutation) MemoryCleared() bool {
	_, ok := m.clearedFields[computer.FieldMemory]
	return ok
}

// ResetMemory resets all changes to the "memory" field.
func (m *ComputerMutation) ResetMemory() {
	m.memory = nil
	m.addmemory = nil
	delete(m.clearedFields, computer.FieldMemory)
}

// SetProcessor sets the "processor" field.
func (m *ComputerMutation) SetProcessor(s string) {
	m.processor = &s
}

// Processor returns the value of the "processor" field in the mutation.
func (m *ComputerMutation) Processor() (r string, exists bool) {
	v := m.processor
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessor returns the old "processor" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldProcessor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessor: %w", err)
	}
	return oldValue.Processor, nil
}

// ClearProcessor clears the value of the "processor" field.
func (m *ComputerMutation) ClearProcessor() {
	m.processor = nil
	m.clearedFields[computer.FieldProcessor] = struct{}{}
}

// ProcessorCleared returns if the "processor" field was cleared in this mutation.
func (m *ComputerMutation) ProcessorCleared() bool {
	_, ok := m.clearedFields[computer.FieldProcessor]
	return ok
}

// ResetProcessor resets all changes to the "processor" field.
func (m *ComputerMutation) ResetProcessor() {
	m.processor = nil
	delete(m.clearedFields, computer.FieldProcessor)
}

// SetProcessorCores sets the "processor_cores" field.
func (m *ComputerMutation) SetProcessorCores(i int64) {
	m.processor_cores = &i
	m.addprocessor_cores = nil
}

// ProcessorCores returns the value of the "processor_cores" field in the mutation.
func (m *ComputerMutation) ProcessorCores() (r int64, exists bool) {
	v := m.processor_cores
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessorCores returns the old "processor_cores" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldProcessorCores(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessorCores is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessorCores requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessorCores: %w", err)
	}
	return oldValue.ProcessorCores, nil
}

// AddProcessorCores adds i to the "processor_cores" field.
func (m *ComputerMutation) AddProcessorCores(i int64) {
	if m.addprocessor_cores != nil {
		*m.addprocessor_cores += i
	} else {
		m.addprocessor_cores = &i
	}
}

// AddedProcessorCores returns the value that was added to the "processor_cores" field in this mutation.
func (m *ComputerMutation) AddedProcessorCores() (r int64, exists bool) {
	v := m.addprocessor_cores
	if v == nil {
		return
	}
	return *v, true
}

// ClearProcessorCores clears the value of the "processor_cores" field.
func (m *ComputerMutation) ClearProcessorCores() {
	m.processor_cores = nil
	m.addprocessor_cores = nil
	m.clearedFields[computer.FieldProcessorCores] = struct{}{}
}

// ProcessorCoresCleared returns if the "processor_cores" field was cleared in this mutation.
func (m *ComputerMutation) ProcessorCoresCleared() bool {
	_, ok := m.clearedFields[computer.FieldProcessorCores]
	return ok
}

// ResetProcessorCores resets all changes to the "processor_cores" field.
func (m *ComputerMutation) ResetProcessorCores() {
	m.processor_cores = nil
	m.addprocessor_cores = nil
	delete(m.clearedFields, computer.FieldProcessorCores)
}

// SetProcessorArch sets the "processor_arch" field.
func (m *ComputerMutation) SetProcessorArch(s string) {
	m.processor_arch = &s
}

// ProcessorArch returns the value of the "processor_arch" field in the mutation.
func (m *ComputerMutation) ProcessorArch() (r string, exists bool) {
	v := m.processor_arch
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessorArch returns the old "processor_arch" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldProcessorArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessorArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessorArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessorArch: %w", err)
	}
	return oldValue.ProcessorArch, nil
}

// ClearProcessorArch clears the value of the "processor_arch" field.
func (m *ComputerMutation) ClearProcessorArch() {
	m.processor_arch = nil
	m.clearedFields[computer.FieldProcessorArch] = struct{}{}
}

// ProcessorArchCleared returns if the "processor_arch" field was cleared in this mutation.
func (m *ComputerMutation) ProcessorArchCleared() bool {
	_, ok := m.clearedFields[computer.FieldProcessorArch]
	return ok
}

// ResetProcessorArch resets all changes to the "processor_arch" field.
func (m *ComputerMutation) ResetProcessorArch() {
	m.processor_arch = nil
	delete(m.clearedFields, computer.FieldProcessorArch)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *ComputerMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *ComputerMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *ComputerMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ComputerMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ComputerMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ComputerMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the ComputerMutation builder.
func (m *ComputerMutation) Where(ps ...predicate.Computer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ComputerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ComputerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Computer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ComputerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ComputerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Computer).
func (m *ComputerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ComputerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.manufacturer != nil {
		fields = append(fields, computer.FieldManufacturer)
	}
	if m.model != nil {
		fields = append(fields, computer.FieldModel)
	}
	if m.serial != nil {
		fields = append(fields, computer.FieldSerial)
	}
	if m.memory != nil {
		fields = append(fields, computer.FieldMemory)
	}
	if m.processor != nil {
		fields = append(fields, computer.FieldProcessor)
	}
	if m.processor_cores != nil {
		fields = append(fields, computer.FieldProcessorCores)
	}
	if m.processor_arch != nil {
		fields = append(fields, computer.FieldProcessorArch)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ComputerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case computer.FieldManufacturer:
		return m.Manufacturer()
	case computer.FieldModel:
		return m.Model()
	case computer.FieldSerial:
		return m.Serial()
	case computer.FieldMemory:
		return m.Memory()
	case computer.FieldProcessor:
		return m.Processor()
	case computer.FieldProcessorCores:
		return m.ProcessorCores()
	case computer.FieldProcessorArch:
		return m.ProcessorArch()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ComputerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case computer.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case computer.FieldModel:
		return m.OldModel(ctx)
	case computer.FieldSerial:
		return m.OldSerial(ctx)
	case computer.FieldMemory:
		return m.OldMemory(ctx)
	case computer.FieldProcessor:
		return m.OldProcessor(ctx)
	case computer.FieldProcessorCores:
		return m.OldProcessorCores(ctx)
	case computer.FieldProcessorArch:
		return m.OldProcessorArch(ctx)
	}
	return nil, fmt.Errorf("unknown Computer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComputerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case computer.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case computer.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case computer.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case computer.FieldMemory:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemory(v)
		return nil
	case computer.FieldProcessor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessor(v)
		return nil
	case computer.FieldProcessorCores:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessorCores(v)
		return nil
	case computer.FieldProcessorArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessorArch(v)
		return nil
	}
	return fmt.Errorf("unknown Computer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ComputerMutation) AddedFields() []string {
	var fields []string
	if m.addmemory != nil {
		fields = append(fields, computer.FieldMemory)
	}
	if m.addprocessor_cores != nil {
		fields = append(fields, computer.FieldProcessorCores)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ComputerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case computer.FieldMemory:
		return m.AddedMemory()
	case computer.FieldProcessorCores:
		return m.AddedProcessorCores()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComputerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case computer.FieldMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemory(v)
		return nil
	case computer.FieldProcessorCores:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcessorCores(v)
		return nil
	}
	return fmt.Errorf("unknown Computer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ComputerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(computer.FieldManufacturer) {
		fields = append(fields, computer.FieldManufacturer)
	}
	if m.FieldCleared(computer.FieldModel) {
		fields = append(fields, computer.FieldModel)
	}
	if m.FieldCleared(computer.FieldSerial) {
		fields = append(fields, computer.FieldSerial)
	}
	if m.FieldCleared(computer.FieldMemory) {
		fields = append(fields, computer.FieldMemory)
	}
	if m.FieldCleared(computer.FieldProcessor) {
		fields = append(fields, computer.FieldProcessor)
	}
	if m.FieldCleared(computer.FieldProcessorCores) {
		fields = append(fields, computer.FieldProcessorCores)
	}
	if m.FieldCleared(computer.FieldProcessorArch) {
		fields = append(fields, computer.FieldProcessorArch)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ComputerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComputerMutation) ClearField(name string) error {
	switch name {
	case computer.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	case computer.FieldModel:
		m.ClearModel()
		return nil
	case computer.FieldSerial:
		m.ClearSerial()
		return nil
	case computer.FieldMemory:
		m.ClearMemory()
		return nil
	case computer.FieldProcessor:
		m.ClearProcessor()
		return nil
	case computer.FieldProcessorCores:
		m.ClearProcessorCores()
		return nil
	case computer.FieldProcessorArch:
		m.ClearProcessorArch()
		return nil
	}
	return fmt.Errorf("unknown Computer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ComputerMutation) ResetField(name string) error {
	switch name {
	case computer.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case computer.FieldModel:
		m.ResetModel()
		return nil
	case computer.FieldSerial:
		m.ResetSerial()
		return nil
	case computer.FieldMemory:
		m.ResetMemory()
		return nil
	case computer.FieldProcessor:
		m.ResetProcessor()
		return nil
	case computer.FieldProcessorCores:
		m.ResetProcessorCores()
		return nil
	case computer.FieldProcessorArch:
		m.ResetProcessorArch()
		return nil
	}
	return fmt.Errorf("unknown Computer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ComputerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, computer.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ComputerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case computer.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ComputerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ComputerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ComputerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, computer.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ComputerMutation) EdgeCleared(name string) bool {
	switch name {
	case computer.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ComputerMutation) ClearEdge(name string) error {
	switch name {
	case computer.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Computer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ComputerMutation) ResetEdge(name string) error {
	switch name {
	case computer.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Computer edge %s", name)
}

// DeploymentMutation represents an operation that mutates the Deployment nodes in the graph.
type DeploymentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	package_id    *string
	name          *string
	version       *string
	installed     *time.Time
	updated       *time.Time
	failed        *bool
	by_profile    *bool
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Deployment, error)
	predicates    []predicate.Deployment
}

var _ ent.Mutation = (*DeploymentMutation)(nil)

// deploymentOption allows management of the mutation configuration using functional options.
type deploymentOption func(*DeploymentMutation)

// newDeploymentMutation creates new mutation for the Deployment entity.
func newDeploymentMutation(c config, op Op, opts ...deploymentOption) *DeploymentMutation {
	m := &DeploymentMutation{
		config:        c,
		op:            op,
		typ:           TypeDeployment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeploymentID sets the ID field of the mutation.
func withDeploymentID(id int) deploymentOption {
	return func(m *DeploymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Deployment
		)
		m.oldValue = func(ctx context.Context) (*Deployment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deployment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeployment sets the old Deployment of the mutation.
func withDeployment(node *Deployment) deploymentOption {
	return func(m *DeploymentMutation) {
		m.oldValue = func(context.Context) (*Deployment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeploymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeploymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeploymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeploymentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Deployment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *DeploymentMutation) SetPackageID(s string) {
	m.package_id = &s
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *DeploymentMutation) PackageID() (r string, exists bool) {
	v := m.package_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldPackageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *DeploymentMutation) ResetPackageID() {
	m.package_id = nil
}

// SetName sets the "name" field.
func (m *DeploymentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeploymentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeploymentMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *DeploymentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *DeploymentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *DeploymentMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[deployment.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *DeploymentMutation) VersionCleared() bool {
	_, ok := m.clearedFields[deployment.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *DeploymentMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, deployment.FieldVersion)
}

// SetInstalled sets the "installed" field.
func (m *DeploymentMutation) SetInstalled(t time.Time) {
	m.installed = &t
}

// Installed returns the value of the "installed" field in the mutation.
func (m *DeploymentMutation) Installed() (r time.Time, exists bool) {
	v := m.installed
	if v == nil {
		return
	}
	return *v, true
}

// OldInstalled returns the old "installed" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldInstalled(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstalled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstalled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstalled: %w", err)
	}
	return oldValue.Installed, nil
}

// ClearInstalled clears the value of the "installed" field.
func (m *DeploymentMutation) ClearInstalled() {
	m.installed = nil
	m.clearedFields[deployment.FieldInstalled] = struct{}{}
}

// InstalledCleared returns if the "installed" field was cleared in this mutation.
func (m *DeploymentMutation) InstalledCleared() bool {
	_, ok := m.clearedFields[deployment.FieldInstalled]
	return ok
}

// ResetInstalled resets all changes to the "installed" field.
func (m *DeploymentMutation) ResetInstalled() {
	m.installed = nil
	delete(m.clearedFields, deployment.FieldInstalled)
}

// SetUpdated sets the "updated" field.
func (m *DeploymentMutation) SetUpdated(t time.Time) {
	m.updated = &t
}

// Updated returns the value of the "updated" field in the mutation.
func (m *DeploymentMutation) Updated() (r time.Time, exists bool) {
	v := m.updated
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdated returns the old "updated" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdated: %w", err)
	}
	return oldValue.Updated, nil
}

// ClearUpdated clears the value of the "updated" field.
func (m *DeploymentMutation) ClearUpdated() {
	m.updated = nil
	m.clearedFields[deployment.FieldUpdated] = struct{}{}
}

// UpdatedCleared returns if the "updated" field was cleared in this mutation.
func (m *DeploymentMutation) UpdatedCleared() bool {
	_, ok := m.clearedFields[deployment.FieldUpdated]
	return ok
}

// ResetUpdated resets all changes to the "updated" field.
func (m *DeploymentMutation) ResetUpdated() {
	m.updated = nil
	delete(m.clearedFields, deployment.FieldUpdated)
}

// SetFailed sets the "failed" field.
func (m *DeploymentMutation) SetFailed(b bool) {
	m.failed = &b
}

// Failed returns the value of the "failed" field in the mutation.
func (m *DeploymentMutation) Failed() (r bool, exists bool) {
	v := m.failed
	if v == nil {
		return
	}
	return *v, true
}

// OldFailed returns the old "failed" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldFailed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailed: %w", err)
	}
	return oldValue.Failed, nil
}

// ClearFailed clears the value of the "failed" field.
func (m *DeploymentMutation) ClearFailed() {
	m.failed = nil
	m.clearedFields[deployment.FieldFailed] = struct{}{}
}

// FailedCleared returns if the "failed" field was cleared in this mutation.
func (m *DeploymentMutation) FailedCleared() bool {
	_, ok := m.clearedFields[deployment.FieldFailed]
	return ok
}

// ResetFailed resets all changes to the "failed" field.
func (m *DeploymentMutation) ResetFailed() {
	m.failed = nil
	delete(m.clearedFields, deployment.FieldFailed)
}

// SetByProfile sets the "by_profile" field.
func (m *DeploymentMutation) SetByProfile(b bool) {
	m.by_profile = &b
}

// ByProfile returns the value of the "by_profile" field in the mutation.
func (m *DeploymentMutation) ByProfile() (r bool, exists bool) {
	v := m.by_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldByProfile returns the old "by_profile" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldByProfile(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldByProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldByProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldByProfile: %w", err)
	}
	return oldValue.ByProfile, nil
}

// ClearByProfile clears the value of the "by_profile" field.
func (m *DeploymentMutation) ClearByProfile() {
	m.by_profile = nil
	m.clearedFields[deployment.FieldByProfile] = struct{}{}
}

// ByProfileCleared returns if the "by_profile" field was cleared in this mutation.
func (m *DeploymentMutation) ByProfileCleared() bool {
	_, ok := m.clearedFields[deployment.FieldByProfile]
	return ok
}

// ResetByProfile resets all changes to the "by_profile" field.
func (m *DeploymentMutation) ResetByProfile() {
	m.by_profile = nil
	delete(m.clearedFields, deployment.FieldByProfile)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *DeploymentMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *DeploymentMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *DeploymentMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *DeploymentMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *DeploymentMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *DeploymentMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the DeploymentMutation builder.
func (m *DeploymentMutation) Where(ps ...predicate.Deployment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeploymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeploymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Deployment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeploymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeploymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Deployment).
func (m *DeploymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeploymentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.package_id != nil {
		fields = append(fields, deployment.FieldPackageID)
	}
	if m.name != nil {
		fields = append(fields, deployment.FieldName)
	}
	if m.version != nil {
		fields = append(fields, deployment.FieldVersion)
	}
	if m.installed != nil {
		fields = append(fields, deployment.FieldInstalled)
	}
	if m.updated != nil {
		fields = append(fields, deployment.FieldUpdated)
	}
	if m.failed != nil {
		fields = append(fields, deployment.FieldFailed)
	}
	if m.by_profile != nil {
		fields = append(fields, deployment.FieldByProfile)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeploymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deployment.FieldPackageID:
		return m.PackageID()
	case deployment.FieldName:
		return m.Name()
	case deployment.FieldVersion:
		return m.Version()
	case deployment.FieldInstalled:
		return m.Installed()
	case deployment.FieldUpdated:
		return m.Updated()
	case deployment.FieldFailed:
		return m.Failed()
	case deployment.FieldByProfile:
		return m.ByProfile()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeploymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deployment.FieldPackageID:
		return m.OldPackageID(ctx)
	case deployment.FieldName:
		return m.OldName(ctx)
	case deployment.FieldVersion:
		return m.OldVersion(ctx)
	case deployment.FieldInstalled:
		return m.OldInstalled(ctx)
	case deployment.FieldUpdated:
		return m.OldUpdated(ctx)
	case deployment.FieldFailed:
		return m.OldFailed(ctx)
	case deployment.FieldByProfile:
		return m.OldByProfile(ctx)
	}
	return nil, fmt.Errorf("unknown Deployment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deployment.FieldPackageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case deployment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deployment.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case deployment.FieldInstalled:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstalled(v)
		return nil
	case deployment.FieldUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdated(v)
		return nil
	case deployment.FieldFailed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailed(v)
		return nil
	case deployment.FieldByProfile:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetByProfile(v)
		return nil
	}
	return fmt.Errorf("unknown Deployment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeploymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeploymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Deployment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeploymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deployment.FieldVersion) {
		fields = append(fields, deployment.FieldVersion)
	}
	if m.FieldCleared(deployment.FieldInstalled) {
		fields = append(fields, deployment.FieldInstalled)
	}
	if m.FieldCleared(deployment.FieldUpdated) {
		fields = append(fields, deployment.FieldUpdated)
	}
	if m.FieldCleared(deployment.FieldFailed) {
		fields = append(fields, deployment.FieldFailed)
	}
	if m.FieldCleared(deployment.FieldByProfile) {
		fields = append(fields, deployment.FieldByProfile)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeploymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeploymentMutation) ClearField(name string) error {
	switch name {
	case deployment.FieldVersion:
		m.ClearVersion()
		return nil
	case deployment.FieldInstalled:
		m.ClearInstalled()
		return nil
	case deployment.FieldUpdated:
		m.ClearUpdated()
		return nil
	case deployment.FieldFailed:
		m.ClearFailed()
		return nil
	case deployment.FieldByProfile:
		m.ClearByProfile()
		return nil
	}
	return fmt.Errorf("unknown Deployment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeploymentMutation) ResetField(name string) error {
	switch name {
	case deployment.FieldPackageID:
		m.ResetPackageID()
		return nil
	case deployment.FieldName:
		m.ResetName()
		return nil
	case deployment.FieldVersion:
		m.ResetVersion()
		return nil
	case deployment.FieldInstalled:
		m.ResetInstalled()
		return nil
	case deployment.FieldUpdated:
		m.ResetUpdated()
		return nil
	case deployment.FieldFailed:
		m.ResetFailed()
		return nil
	case deployment.FieldByProfile:
		m.ResetByProfile()
		return nil
	}
	return fmt.Errorf("unknown Deployment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeploymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, deployment.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeploymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deployment.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeploymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeploymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeploymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, deployment.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeploymentMutation) EdgeCleared(name string) bool {
	switch name {
	case deployment.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeploymentMutation) ClearEdge(name string) error {
	switch name {
	case deployment.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Deployment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeploymentMutation) ResetEdge(name string) error {
	switch name {
	case deployment.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Deployment edge %s", name)
}

// LogicalDiskMutation represents an operation that mutates the LogicalDisk nodes in the graph.
type LogicalDiskMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	label                              *string
	filesystem                         *string
	usage                              *int8
	addusage                           *int8
	size_in_units                      *string
	remaining_space_in_units           *string
	volume_name                        *string
	bitlocker_status                   *string
	volume_type                        *uint32
	addvolume_type                     *int32
	bitlocker_conversion_status        *int32
	addbitlocker_conversion_status     *int32
	bitlocker_encryption_percentage    *int32
	addbitlocker_encryption_percentage *int32
	bitlocker_recovery_key             *string
	bitlocker_operation_in_progress    *string
	clearedFields                      map[string]struct{}
	owner                              *string
	clearedowner                       bool
	done                               bool
	oldValue                           func(context.Context) (*LogicalDisk, error)
	predicates                         []predicate.LogicalDisk
}

var _ ent.Mutation = (*LogicalDiskMutation)(nil)

// logicaldiskOption allows management of the mutation configuration using functional options.
type logicaldiskOption func(*LogicalDiskMutation)

// newLogicalDiskMutation creates new mutation for the LogicalDisk entity.
func newLogicalDiskMutation(c config, op Op, opts ...logicaldiskOption) *LogicalDiskMutation {
	m := &LogicalDiskMutation{
		config:        c,
		op:            op,
		typ:           TypeLogicalDisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogicalDiskID sets the ID field of the mutation.
func withLogicalDiskID(id int) logicaldiskOption {
	return func(m *LogicalDiskMutation) {
		var (
			err   error
			once  sync.Once
			value *LogicalDisk
		)
		m.oldValue = func(ctx context.Context) (*LogicalDisk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LogicalDisk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogicalDisk sets the old LogicalDisk of the mutation.
func withLogicalDisk(node *LogicalDisk) logicaldiskOption {
	return func(m *LogicalDiskMutation) {
		m.oldValue = func(context.Context) (*LogicalDisk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogicalDiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogicalDiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogicalDiskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogicalDiskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LogicalDisk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *LogicalDiskMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *LogicalDiskMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *LogicalDiskMutation) ResetLabel() {
	m.label = nil
}

// SetFilesystem sets the "filesystem" field.
func (m *LogicalDiskMutation) SetFilesystem(s string) {
	m.filesystem = &s
}

// Filesystem returns the value of the "filesystem" field in the mutation.
func (m *LogicalDiskMutation) Filesystem() (r string, exists bool) {
	v := m.filesystem
	if v == nil {
		return
	}
	return *v, true
}

// OldFilesystem returns the old "filesystem" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldFilesystem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilesystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilesystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilesystem: %w", err)
	}
	return oldValue.Filesystem, nil
}

// ClearFilesystem clears the value of the "filesystem" field.
func (m *LogicalDiskMutation) ClearFilesystem() {
	m.filesystem = nil
	m.clearedFields[logicaldisk.FieldFilesystem] = struct{}{}
}

// FilesystemCleared returns if the "filesystem" field was cleared in this mutation.
func (m *LogicalDiskMutation) FilesystemCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldFilesystem]
	return ok
}

// ResetFilesystem resets all changes to the "filesystem" field.
func (m *LogicalDiskMutation) ResetFilesystem() {
	m.filesystem = nil
	delete(m.clearedFields, logicaldisk.FieldFilesystem)
}

// SetUsage sets the "usage" field.
func (m *LogicalDiskMutation) SetUsage(i int8) {
	m.usage = &i
	m.addusage = nil
}

// Usage returns the value of the "usage" field in the mutation.
func (m *LogicalDiskMutation) Usage() (r int8, exists bool) {
	v := m.usage
	if v == nil {
		return
	}
	return *v, true
}

// OldUsage returns the old "usage" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldUsage(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsage: %w", err)
	}
	return oldValue.Usage, nil
}

// AddUsage adds i to the "usage" field.
func (m *LogicalDiskMutation) AddUsage(i int8) {
	if m.addusage != nil {
		*m.addusage += i
	} else {
		m.addusage = &i
	}
}

// AddedUsage returns the value that was added to the "usage" field in this mutation.
func (m *LogicalDiskMutation) AddedUsage() (r int8, exists bool) {
	v := m.addusage
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsage resets all changes to the "usage" field.
func (m *LogicalDiskMutation) ResetUsage() {
	m.usage = nil
	m.addusage = nil
}

// SetSizeInUnits sets the "size_in_units" field.
func (m *LogicalDiskMutation) SetSizeInUnits(s string) {
	m.size_in_units = &s
}

// SizeInUnits returns the value of the "size_in_units" field in the mutation.
func (m *LogicalDiskMutation) SizeInUnits() (r string, exists bool) {
	v := m.size_in_units
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeInUnits returns the old "size_in_units" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldSizeInUnits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeInUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeInUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeInUnits: %w", err)
	}
	return oldValue.SizeInUnits, nil
}

// ClearSizeInUnits clears the value of the "size_in_units" field.
func (m *LogicalDiskMutation) ClearSizeInUnits() {
	m.size_in_units = nil
	m.clearedFields[logicaldisk.FieldSizeInUnits] = struct{}{}
}

// SizeInUnitsCleared returns if the "size_in_units" field was cleared in this mutation.
func (m *LogicalDiskMutation) SizeInUnitsCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldSizeInUnits]
	return ok
}

// ResetSizeInUnits resets all changes to the "size_in_units" field.
func (m *LogicalDiskMutation) ResetSizeInUnits() {
	m.size_in_units = nil
	delete(m.clearedFields, logicaldisk.FieldSizeInUnits)
}

// SetRemainingSpaceInUnits sets the "remaining_space_in_units" field.
func (m *LogicalDiskMutation) SetRemainingSpaceInUnits(s string) {
	m.remaining_space_in_units = &s
}

// RemainingSpaceInUnits returns the value of the "remaining_space_in_units" field in the mutation.
func (m *LogicalDiskMutation) RemainingSpaceInUnits() (r string, exists bool) {
	v := m.remaining_space_in_units
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingSpaceInUnits returns the old "remaining_space_in_units" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldRemainingSpaceInUnits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainingSpaceInUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainingSpaceInUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingSpaceInUnits: %w", err)
	}
	return oldValue.RemainingSpaceInUnits, nil
}

// ClearRemainingSpaceInUnits clears the value of the "remaining_space_in_units" field.
func (m *LogicalDiskMutation) ClearRemainingSpaceInUnits() {
	m.remaining_space_in_units = nil
	m.clearedFields[logicaldisk.FieldRemainingSpaceInUnits] = struct{}{}
}

// RemainingSpaceInUnitsCleared returns if the "remaining_space_in_units" field was cleared in this mutation.
func (m *LogicalDiskMutation) RemainingSpaceInUnitsCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldRemainingSpaceInUnits]
	return ok
}

// ResetRemainingSpaceInUnits resets all changes to the "remaining_space_in_units" field.
func (m *LogicalDiskMutation) ResetRemainingSpaceInUnits() {
	m.remaining_space_in_units = nil
	delete(m.clearedFields, logicaldisk.FieldRemainingSpaceInUnits)
}

// SetVolumeName sets the "volume_name" field.
func (m *LogicalDiskMutation) SetVolumeName(s string) {
	m.volume_name = &s
}

// VolumeName returns the value of the "volume_name" field in the mutation.
func (m *LogicalDiskMutation) VolumeName() (r string, exists bool) {
	v := m.volume_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVolumeName returns the old "volume_name" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldVolumeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolumeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolumeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolumeName: %w", err)
	}
	return oldValue.VolumeName, nil
}

// ClearVolumeName clears the value of the "volume_name" field.
func (m *LogicalDiskMutation) ClearVolumeName() {
	m.volume_name = nil
	m.clearedFields[logicaldisk.FieldVolumeName] = struct{}{}
}

// VolumeNameCleared returns if the "volume_name" field was cleared in this mutation.
func (m *LogicalDiskMutation) VolumeNameCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldVolumeName]
	return ok
}

// ResetVolumeName resets all changes to the "volume_name" field.
func (m *LogicalDiskMutation) ResetVolumeName() {
	m.volume_name = nil
	delete(m.clearedFields, logicaldisk.FieldVolumeName)
}

// SetBitlockerStatus sets the "bitlocker_status" field.
func (m *LogicalDiskMutation) SetBitlockerStatus(s string) {
	m.bitlocker_status = &s
}

// BitlockerStatus returns the value of the "bitlocker_status" field in the mutation.
func (m *LogicalDiskMutation) BitlockerStatus() (r string, exists bool) {
	v := m.bitlocker_status
	if v == nil {
		return
	}
	return *v, true
}

// OldBitlockerStatus returns the old "bitlocker_status" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldBitlockerStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBitlockerStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBitlockerStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBitlockerStatus: %w", err)
	}
	return oldValue.BitlockerStatus, nil
}

// ClearBitlockerStatus clears the value of the "bitlocker_status" field.
func (m *LogicalDiskMutation) ClearBitlockerStatus() {
	m.bitlocker_status = nil
	m.clearedFields[logicaldisk.FieldBitlockerStatus] = struct{}{}
}

// BitlockerStatusCleared returns if the "bitlocker_status" field was cleared in this mutation.
func (m *LogicalDiskMutation) BitlockerStatusCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldBitlockerStatus]
	return ok
}

// ResetBitlockerStatus resets all changes to the "bitlocker_status" field.
func (m *LogicalDiskMutation) ResetBitlockerStatus() {
	m.bitlocker_status = nil
	delete(m.clearedFields, logicaldisk.FieldBitlockerStatus)
}

// SetVolumeType sets the "volume_type" field.
func (m *LogicalDiskMutation) SetVolumeType(u uint32) {
	m.volume_type = &u
	m.addvolume_type = nil
}

// VolumeType returns the value of the "volume_type" field in the mutation.
func (m *LogicalDiskMutation) VolumeType() (r uint32, exists bool) {
	v := m.volume_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVolumeType returns the old "volume_type" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldVolumeType(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolumeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolumeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolumeType: %w", err)
	}
	return oldValue.VolumeType, nil
}

// AddVolumeType adds u to the "volume_type" field.
func (m *LogicalDiskMutation) AddVolumeType(u int32) {
	if m.addvolume_type != nil {
		*m.addvolume_type += u
	} else {
		m.addvolume_type = &u
	}
}

// AddedVolumeType returns the value that was added to the "volume_type" field in this mutation.
func (m *LogicalDiskMutation) AddedVolumeType() (r int32, exists bool) {
	v := m.addvolume_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearVolumeType clears the value of the "volume_type" field.
func (m *LogicalDiskMutation) ClearVolumeType() {
	m.volume_type = nil
	m.addvolume_type = nil
	m.clearedFields[logicaldisk.FieldVolumeType] = struct{}{}
}

// VolumeTypeCleared returns if the "volume_type" field was cleared in this mutation.
func (m *LogicalDiskMutation) VolumeTypeCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldVolumeType]
	return ok
}

// ResetVolumeType resets all changes to the "volume_type" field.
func (m *LogicalDiskMutation) ResetVolumeType() {
	m.volume_type = nil
	m.addvolume_type = nil
	delete(m.clearedFields, logicaldisk.FieldVolumeType)
}

// SetBitlockerConversionStatus sets the "bitlocker_conversion_status" field.
func (m *LogicalDiskMutation) SetBitlockerConversionStatus(i int32) {
	m.bitlocker_conversion_status = &i
	m.addbitlocker_conversion_status = nil
}

// BitlockerConversionStatus returns the value of the "bitlocker_conversion_status" field in the mutation.
func (m *LogicalDiskMutation) BitlockerConversionStatus() (r int32, exists bool) {
	v := m.bitlocker_conversion_status
	if v == nil {
		return
	}
	return *v, true
}

// OldBitlockerConversionStatus returns the old "bitlocker_conversion_status" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldBitlockerConversionStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBitlockerConversionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBitlockerConversionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBitlockerConversionStatus: %w", err)
	}
	return oldValue.BitlockerConversionStatus, nil
}

// AddBitlockerConversionStatus adds i to the "bitlocker_conversion_status" field.
func (m *LogicalDiskMutation) AddBitlockerConversionStatus(i int32) {
	if m.addbitlocker_conversion_status != nil {
		*m.addbitlocker_conversion_status += i
	} else {
		m.addbitlocker_conversion_status = &i
	}
}

// AddedBitlockerConversionStatus returns the value that was added to the "bitlocker_conversion_status" field in this mutation.
func (m *LogicalDiskMutation) AddedBitlockerConversionStatus() (r int32, exists bool) {
	v := m.addbitlocker_conversion_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearBitlockerConversionStatus clears the value of the "bitlocker_conversion_status" field.
func (m *LogicalDiskMutation) ClearBitlockerConversionStatus() {
	m.bitlocker_conversion_status = nil
	m.addbitlocker_conversion_status = nil
	m.clearedFields[logicaldisk.FieldBitlockerConversionStatus] = struct{}{}
}

// BitlockerConversionStatusCleared returns if the "bitlocker_conversion_status" field was cleared in this mutation.
func (m *LogicalDiskMutation) BitlockerConversionStatusCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldBitlockerConversionStatus]
	return ok
}

// ResetBitlockerConversionStatus resets all changes to the "bitlocker_conversion_status" field.
func (m *LogicalDiskMutation) ResetBitlockerConversionStatus() {
	m.bitlocker_conversion_status = nil
	m.addbitlocker_conversion_status = nil
	delete(m.clearedFields, logicaldisk.FieldBitlockerConversionStatus)
}

// SetBitlockerEncryptionPercentage sets the "bitlocker_encryption_percentage" field.
func (m *LogicalDiskMutation) SetBitlockerEncryptionPercentage(i int32) {
	m.bitlocker_encryption_percentage = &i
	m.addbitlocker_encryption_percentage = nil
}

// BitlockerEncryptionPercentage returns the value of the "bitlocker_encryption_percentage" field in the mutation.
func (m *LogicalDiskMutation) BitlockerEncryptionPercentage() (r int32, exists bool) {
	v := m.bitlocker_encryption_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldBitlockerEncryptionPercentage returns the old "bitlocker_encryption_percentage" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldBitlockerEncryptionPercentage(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBitlockerEncryptionPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBitlockerEncryptionPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBitlockerEncryptionPercentage: %w", err)
	}
	return oldValue.BitlockerEncryptionPercentage, nil
}

// AddBitlockerEncryptionPercentage adds i to the "bitlocker_encryption_percentage" field.
func (m *LogicalDiskMutation) AddBitlockerEncryptionPercentage(i int32) {
	if m.addbitlocker_encryption_percentage != nil {
		*m.addbitlocker_encryption_percentage += i
	} else {
		m.addbitlocker_encryption_percentage = &i
	}
}

// AddedBitlockerEncryptionPercentage returns the value that was added to the "bitlocker_encryption_percentage" field in this mutation.
func (m *LogicalDiskMutation) AddedBitlockerEncryptionPercentage() (r int32, exists bool) {
	v := m.addbitlocker_encryption_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ClearBitlockerEncryptionPercentage clears the value of the "bitlocker_encryption_percentage" field.
func (m *LogicalDiskMutation) ClearBitlockerEncryptionPercentage() {
	m.bitlocker_encryption_percentage = nil
	m.addbitlocker_encryption_percentage = nil
	m.clearedFields[logicaldisk.FieldBitlockerEncryptionPercentage] = struct{}{}
}

// BitlockerEncryptionPercentageCleared returns if the "bitlocker_encryption_percentage" field was cleared in this mutation.
func (m *LogicalDiskMutation) BitlockerEncryptionPercentageCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldBitlockerEncryptionPercentage]
	return ok
}

// ResetBitlockerEncryptionPercentage resets all changes to the "bitlocker_encryption_percentage" field.
func (m *LogicalDiskMutation) ResetBitlockerEncryptionPercentage() {
	m.bitlocker_encryption_percentage = nil
	m.addbitlocker_encryption_percentage = nil
	delete(m.clearedFields, logicaldisk.FieldBitlockerEncryptionPercentage)
}

// SetBitlockerRecoveryKey sets the "bitlocker_recovery_key" field.
func (m *LogicalDiskMutation) SetBitlockerRecoveryKey(s string) {
	m.bitlocker_recovery_key = &s
}

// BitlockerRecoveryKey returns the value of the "bitlocker_recovery_key" field in the mutation.
func (m *LogicalDiskMutation) BitlockerRecoveryKey() (r string, exists bool) {
	v := m.bitlocker_recovery_key
	if v == nil {
		return
	}
	return *v, true
}

// OldBitlockerRecoveryKey returns the old "bitlocker_recovery_key" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldBitlockerRecoveryKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBitlockerRecoveryKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBitlockerRecoveryKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBitlockerRecoveryKey: %w", err)
	}
	return oldValue.BitlockerRecoveryKey, nil
}

// ClearBitlockerRecoveryKey clears the value of the "bitlocker_recovery_key" field.
func (m *LogicalDiskMutation) ClearBitlockerRecoveryKey() {
	m.bitlocker_recovery_key = nil
	m.clearedFields[logicaldisk.FieldBitlockerRecoveryKey] = struct{}{}
}

// BitlockerRecoveryKeyCleared returns if the "bitlocker_recovery_key" field was cleared in this mutation.
func (m *LogicalDiskMutation) BitlockerRecoveryKeyCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldBitlockerRecoveryKey]
	return ok
}

// ResetBitlockerRecoveryKey resets all changes to the "bitlocker_recovery_key" field.
func (m *LogicalDiskMutation) ResetBitlockerRecoveryKey() {
	m.bitlocker_recovery_key = nil
	delete(m.clearedFields, logicaldisk.FieldBitlockerRecoveryKey)
}

// SetBitlockerOperationInProgress sets the "bitlocker_operation_in_progress" field.
func (m *LogicalDiskMutation) SetBitlockerOperationInProgress(s string) {
	m.bitlocker_operation_in_progress = &s
}

// BitlockerOperationInProgress returns the value of the "bitlocker_operation_in_progress" field in the mutation.
func (m *LogicalDiskMutation) BitlockerOperationInProgress() (r string, exists bool) {
	v := m.bitlocker_operation_in_progress
	if v == nil {
		return
	}
	return *v, true
}

// OldBitlockerOperationInProgress returns the old "bitlocker_operation_in_progress" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldBitlockerOperationInProgress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBitlockerOperationInProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBitlockerOperationInProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBitlockerOperationInProgress: %w", err)
	}
	return oldValue.BitlockerOperationInProgress, nil
}

// ClearBitlockerOperationInProgress clears the value of the "bitlocker_operation_in_progress" field.
func (m *LogicalDiskMutation) ClearBitlockerOperationInProgress() {
	m.bitlocker_operation_in_progress = nil
	m.clearedFields[logicaldisk.FieldBitlockerOperationInProgress] = struct{}{}
}

// BitlockerOperationInProgressCleared returns if the "bitlocker_operation_in_progress" field was cleared in this mutation.
func (m *LogicalDiskMutation) BitlockerOperationInProgressCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldBitlockerOperationInProgress]
	return ok
}

// ResetBitlockerOperationInProgress resets all changes to the "bitlocker_operation_in_progress" field.
func (m *LogicalDiskMutation) ResetBitlockerOperationInProgress() {
	m.bitlocker_operation_in_progress = nil
	delete(m.clearedFields, logicaldisk.FieldBitlockerOperationInProgress)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *LogicalDiskMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *LogicalDiskMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *LogicalDiskMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *LogicalDiskMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *LogicalDiskMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *LogicalDiskMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the LogicalDiskMutation builder.
func (m *LogicalDiskMutation) Where(ps ...predicate.LogicalDisk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogicalDiskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogicalDiskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LogicalDisk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogicalDiskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogicalDiskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LogicalDisk).
func (m *LogicalDiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogicalDiskMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.label != nil {
		fields = append(fields, logicaldisk.FieldLabel)
	}
	if m.filesystem != nil {
		fields = append(fields, logicaldisk.FieldFilesystem)
	}
	if m.usage != nil {
		fields = append(fields, logicaldisk.FieldUsage)
	}
	if m.size_in_units != nil {
		fields = append(fields, logicaldisk.FieldSizeInUnits)
	}
	if m.remaining_space_in_units != nil {
		fields = append(fields, logicaldisk.FieldRemainingSpaceInUnits)
	}
	if m.volume_name != nil {
		fields = append(fields, logicaldisk.FieldVolumeName)
	}
	if m.bitlocker_status != nil {
		fields = append(fields, logicaldisk.FieldBitlockerStatus)
	}
	if m.volume_type != nil {
		fields = append(fields, logicaldisk.FieldVolumeType)
	}
	if m.bitlocker_conversion_status != nil {
		fields = append(fields, logicaldisk.FieldBitlockerConversionStatus)
	}
	if m.bitlocker_encryption_percentage != nil {
		fields = append(fields, logicaldisk.FieldBitlockerEncryptionPercentage)
	}
	if m.bitlocker_recovery_key != nil {
		fields = append(fields, logicaldisk.FieldBitlockerRecoveryKey)
	}
	if m.bitlocker_operation_in_progress != nil {
		fields = append(fields, logicaldisk.FieldBitlockerOperationInProgress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogicalDiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logicaldisk.FieldLabel:
		return m.Label()
	case logicaldisk.FieldFilesystem:
		return m.Filesystem()
	case logicaldisk.FieldUsage:
		return m.Usage()
	case logicaldisk.FieldSizeInUnits:
		return m.SizeInUnits()
	case logicaldisk.FieldRemainingSpaceInUnits:
		return m.RemainingSpaceInUnits()
	case logicaldisk.FieldVolumeName:
		return m.VolumeName()
	case logicaldisk.FieldBitlockerStatus:
		return m.BitlockerStatus()
	case logicaldisk.FieldVolumeType:
		return m.VolumeType()
	case logicaldisk.FieldBitlockerConversionStatus:
		return m.BitlockerConversionStatus()
	case logicaldisk.FieldBitlockerEncryptionPercentage:
		return m.BitlockerEncryptionPercentage()
	case logicaldisk.FieldBitlockerRecoveryKey:
		return m.BitlockerRecoveryKey()
	case logicaldisk.FieldBitlockerOperationInProgress:
		return m.BitlockerOperationInProgress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogicalDiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logicaldisk.FieldLabel:
		return m.OldLabel(ctx)
	case logicaldisk.FieldFilesystem:
		return m.OldFilesystem(ctx)
	case logicaldisk.FieldUsage:
		return m.OldUsage(ctx)
	case logicaldisk.FieldSizeInUnits:
		return m.OldSizeInUnits(ctx)
	case logicaldisk.FieldRemainingSpaceInUnits:
		return m.OldRemainingSpaceInUnits(ctx)
	case logicaldisk.FieldVolumeName:
		return m.OldVolumeName(ctx)
	case logicaldisk.FieldBitlockerStatus:
		return m.OldBitlockerStatus(ctx)
	case logicaldisk.FieldVolumeType:
		return m.OldVolumeType(ctx)
	case logicaldisk.FieldBitlockerConversionStatus:
		return m.OldBitlockerConversionStatus(ctx)
	case logicaldisk.FieldBitlockerEncryptionPercentage:
		return m.OldBitlockerEncryptionPercentage(ctx)
	case logicaldisk.FieldBitlockerRecoveryKey:
		return m.OldBitlockerRecoveryKey(ctx)
	case logicaldisk.FieldBitlockerOperationInProgress:
		return m.OldBitlockerOperationInProgress(ctx)
	}
	return nil, fmt.Errorf("unknown LogicalDisk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogicalDiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logicaldisk.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case logicaldisk.FieldFilesystem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilesystem(v)
		return nil
	case logicaldisk.FieldUsage:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsage(v)
		return nil
	case logicaldisk.FieldSizeInUnits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeInUnits(v)
		return nil
	case logicaldisk.FieldRemainingSpaceInUnits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingSpaceInUnits(v)
		return nil
	case logicaldisk.FieldVolumeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolumeName(v)
		return nil
	case logicaldisk.FieldBitlockerStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBitlockerStatus(v)
		return nil
	case logicaldisk.FieldVolumeType:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolumeType(v)
		return nil
	case logicaldisk.FieldBitlockerConversionStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBitlockerConversionStatus(v)
		return nil
	case logicaldisk.FieldBitlockerEncryptionPercentage:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBitlockerEncryptionPercentage(v)
		return nil
	case logicaldisk.FieldBitlockerRecoveryKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBitlockerRecoveryKey(v)
		return nil
	case logicaldisk.FieldBitlockerOperationInProgress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBitlockerOperationInProgress(v)
		return nil
	}
	return fmt.Errorf("unknown LogicalDisk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogicalDiskMutation) AddedFields() []string {
	var fields []string
	if m.addusage != nil {
		fields = append(fields, logicaldisk.FieldUsage)
	}
	if m.addvolume_type != nil {
		fields = append(fields, logicaldisk.FieldVolumeType)
	}
	if m.addbitlocker_conversion_status != nil {
		fields = append(fields, logicaldisk.FieldBitlockerConversionStatus)
	}
	if m.addbitlocker_encryption_percentage != nil {
		fields = append(fields, logicaldisk.FieldBitlockerEncryptionPercentage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogicalDiskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case logicaldisk.FieldUsage:
		return m.AddedUsage()
	case logicaldisk.FieldVolumeType:
		return m.AddedVolumeType()
	case logicaldisk.FieldBitlockerConversionStatus:
		return m.AddedBitlockerConversionStatus()
	case logicaldisk.FieldBitlockerEncryptionPercentage:
		return m.AddedBitlockerEncryptionPercentage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogicalDiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case logicaldisk.FieldUsage:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsage(v)
		return nil
	case logicaldisk.FieldVolumeType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolumeType(v)
		return nil
	case logicaldisk.FieldBitlockerConversionStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBitlockerConversionStatus(v)
		return nil
	case logicaldisk.FieldBitlockerEncryptionPercentage:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBitlockerEncryptionPercentage(v)
		return nil
	}
	return fmt.Errorf("unknown LogicalDisk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogicalDiskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logicaldisk.FieldFilesystem) {
		fields = append(fields, logicaldisk.FieldFilesystem)
	}
	if m.FieldCleared(logicaldisk.FieldSizeInUnits) {
		fields = append(fields, logicaldisk.FieldSizeInUnits)
	}
	if m.FieldCleared(logicaldisk.FieldRemainingSpaceInUnits) {
		fields = append(fields, logicaldisk.FieldRemainingSpaceInUnits)
	}
	if m.FieldCleared(logicaldisk.FieldVolumeName) {
		fields = append(fields, logicaldisk.FieldVolumeName)
	}
	if m.FieldCleared(logicaldisk.FieldBitlockerStatus) {
		fields = append(fields, logicaldisk.FieldBitlockerStatus)
	}
	if m.FieldCleared(logicaldisk.FieldVolumeType) {
		fields = append(fields, logicaldisk.FieldVolumeType)
	}
	if m.FieldCleared(logicaldisk.FieldBitlockerConversionStatus) {
		fields = append(fields, logicaldisk.FieldBitlockerConversionStatus)
	}
	if m.FieldCleared(logicaldisk.FieldBitlockerEncryptionPercentage) {
		fields = append(fields, logicaldisk.FieldBitlockerEncryptionPercentage)
	}
	if m.FieldCleared(logicaldisk.FieldBitlockerRecoveryKey) {
		fields = append(fields, logicaldisk.FieldBitlockerRecoveryKey)
	}
	if m.FieldCleared(logicaldisk.FieldBitlockerOperationInProgress) {
		fields = append(fields, logicaldisk.FieldBitlockerOperationInProgress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogicalDiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogicalDiskMutation) ClearField(name string) error {
	switch name {
	case logicaldisk.FieldFilesystem:
		m.ClearFilesystem()
		return nil
	case logicaldisk.FieldSizeInUnits:
		m.ClearSizeInUnits()
		return nil
	case logicaldisk.FieldRemainingSpaceInUnits:
		m.ClearRemainingSpaceInUnits()
		return nil
	case logicaldisk.FieldVolumeName:
		m.ClearVolumeName()
		return nil
	case logicaldisk.FieldBitlockerStatus:
		m.ClearBitlockerStatus()
		return nil
	case logicaldisk.FieldVolumeType:
		m.ClearVolumeType()
		return nil
	case logicaldisk.FieldBitlockerConversionStatus:
		m.ClearBitlockerConversionStatus()
		return nil
	case logicaldisk.FieldBitlockerEncryptionPercentage:
		m.ClearBitlockerEncryptionPercentage()
		return nil
	case logicaldisk.FieldBitlockerRecoveryKey:
		m.ClearBitlockerRecoveryKey()
		return nil
	case logicaldisk.FieldBitlockerOperationInProgress:
		m.ClearBitlockerOperationInProgress()
		return nil
	}
	return fmt.Errorf("unknown LogicalDisk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogicalDiskMutation) ResetField(name string) error {
	switch name {
	case logicaldisk.FieldLabel:
		m.ResetLabel()
		return nil
	case logicaldisk.FieldFilesystem:
		m.ResetFilesystem()
		return nil
	case logicaldisk.FieldUsage:
		m.ResetUsage()
		return nil
	case logicaldisk.FieldSizeInUnits:
		m.ResetSizeInUnits()
		return nil
	case logicaldisk.FieldRemainingSpaceInUnits:
		m.ResetRemainingSpaceInUnits()
		return nil
	case logicaldisk.FieldVolumeName:
		m.ResetVolumeName()
		return nil
	case logicaldisk.FieldBitlockerStatus:
		m.ResetBitlockerStatus()
		return nil
	case logicaldisk.FieldVolumeType:
		m.ResetVolumeType()
		return nil
	case logicaldisk.FieldBitlockerConversionStatus:
		m.ResetBitlockerConversionStatus()
		return nil
	case logicaldisk.FieldBitlockerEncryptionPercentage:
		m.ResetBitlockerEncryptionPercentage()
		return nil
	case logicaldisk.FieldBitlockerRecoveryKey:
		m.ResetBitlockerRecoveryKey()
		return nil
	case logicaldisk.FieldBitlockerOperationInProgress:
		m.ResetBitlockerOperationInProgress()
		return nil
	}
	return fmt.Errorf("unknown LogicalDisk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogicalDiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, logicaldisk.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogicalDiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case logicaldisk.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogicalDiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogicalDiskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogicalDiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, logicaldisk.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogicalDiskMutation) EdgeCleared(name string) bool {
	switch name {
	case logicaldisk.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogicalDiskMutation) ClearEdge(name string) error {
	switch name {
	case logicaldisk.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown LogicalDisk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogicalDiskMutation) ResetEdge(name string) error {
	switch name {
	case logicaldisk.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown LogicalDisk edge %s", name)
}

// MemorySlotMutation represents an operation that mutates the MemorySlot nodes in the graph.
type MemorySlotMutation struct {
	config
	op            Op
	typ           string
	id            *int
	slot          *string
	size          *string
	_type         *string
	serial_number *string
	part_number   *string
	speed         *string
	manufacturer  *string
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*MemorySlot, error)
	predicates    []predicate.MemorySlot
}

var _ ent.Mutation = (*MemorySlotMutation)(nil)

// memoryslotOption allows management of the mutation configuration using functional options.
type memoryslotOption func(*MemorySlotMutation)

// newMemorySlotMutation creates new mutation for the MemorySlot entity.
func newMemorySlotMutation(c config, op Op, opts ...memoryslotOption) *MemorySlotMutation {
	m := &MemorySlotMutation{
		config:        c,
		op:            op,
		typ:           TypeMemorySlot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemorySlotID sets the ID field of the mutation.
func withMemorySlotID(id int) memoryslotOption {
	return func(m *MemorySlotMutation) {
		var (
			err   error
			once  sync.Once
			value *MemorySlot
		)
		m.oldValue = func(ctx context.Context) (*MemorySlot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemorySlot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemorySlot sets the old MemorySlot of the mutation.
func withMemorySlot(node *MemorySlot) memoryslotOption {
	return func(m *MemorySlotMutation) {
		m.oldValue = func(context.Context) (*MemorySlot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemorySlotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemorySlotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemorySlotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemorySlotMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemorySlot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlot sets the "slot" field.
func (m *MemorySlotMutation) SetSlot(s string) {
	m.slot = &s
}

// Slot returns the value of the "slot" field in the mutation.
func (m *MemorySlotMutation) Slot() (r string, exists bool) {
	v := m.slot
	if v == nil {
		return
	}
	return *v, true
}

// OldSlot returns the old "slot" field's value of the MemorySlot entity.
// If the MemorySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemorySlotMutation) OldSlot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlot: %w", err)
	}
	return oldValue.Slot, nil
}

// ClearSlot clears the value of the "slot" field.
func (m *MemorySlotMutation) ClearSlot() {
	m.slot = nil
	m.clearedFields[memoryslot.FieldSlot] = struct{}{}
}

// SlotCleared returns if the "slot" field was cleared in this mutation.
func (m *MemorySlotMutation) SlotCleared() bool {
	_, ok := m.clearedFields[memoryslot.FieldSlot]
	return ok
}

// ResetSlot resets all changes to the "slot" field.
func (m *MemorySlotMutation) ResetSlot() {
	m.slot = nil
	delete(m.clearedFields, memoryslot.FieldSlot)
}

// SetSize sets the "size" field.
func (m *MemorySlotMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *MemorySlotMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the MemorySlot entity.
// If the MemorySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemorySlotMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ClearSize clears the value of the "size" field.
func (m *MemorySlotMutation) ClearSize() {
	m.size = nil
	m.clearedFields[memoryslot.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *MemorySlotMutation) SizeCleared() bool {
	_, ok := m.clearedFields[memoryslot.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *MemorySlotMutation) ResetSize() {
	m.size = nil
	delete(m.clearedFields, memoryslot.FieldSize)
}

// SetType sets the "type" field.
func (m *MemorySlotMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MemorySlotMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MemorySlot entity.
// If the MemorySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemorySlotMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *MemorySlotMutation) ClearType() {
	m._type = nil
	m.clearedFields[memoryslot.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *MemorySlotMutation) TypeCleared() bool {
	_, ok := m.clearedFields[memoryslot.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *MemorySlotMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, memoryslot.FieldType)
}

// SetSerialNumber sets the "serial_number" field.
func (m *MemorySlotMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *MemorySlotMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the MemorySlot entity.
// If the MemorySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemorySlotMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *MemorySlotMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[memoryslot.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *MemorySlotMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[memoryslot.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *MemorySlotMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, memoryslot.FieldSerialNumber)
}

// SetPartNumber sets the "part_number" field.
func (m *MemorySlotMutation) SetPartNumber(s string) {
	m.part_number = &s
}

// PartNumber returns the value of the "part_number" field in the mutation.
func (m *MemorySlotMutation) PartNumber() (r string, exists bool) {
	v := m.part_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPartNumber returns the old "part_number" field's value of the MemorySlot entity.
// If the MemorySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemorySlotMutation) OldPartNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPartNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPartNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartNumber: %w", err)
	}
	return oldValue.PartNumber, nil
}

// ClearPartNumber clears the value of the "part_number" field.
func (m *MemorySlotMutation) ClearPartNumber() {
	m.part_number = nil
	m.clearedFields[memoryslot.FieldPartNumber] = struct{}{}
}

// PartNumberCleared returns if the "part_number" field was cleared in this mutation.
func (m *MemorySlotMutation) PartNumberCleared() bool {
	_, ok := m.clearedFields[memoryslot.FieldPartNumber]
	return ok
}

// ResetPartNumber resets all changes to the "part_number" field.
func (m *MemorySlotMutation) ResetPartNumber() {
	m.part_number = nil
	delete(m.clearedFields, memoryslot.FieldPartNumber)
}

// SetSpeed sets the "speed" field.
func (m *MemorySlotMutation) SetSpeed(s string) {
	m.speed = &s
}

// Speed returns the value of the "speed" field in the mutation.
func (m *MemorySlotMutation) Speed() (r string, exists bool) {
	v := m.speed
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeed returns the old "speed" field's value of the MemorySlot entity.
// If the MemorySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemorySlotMutation) OldSpeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeed: %w", err)
	}
	return oldValue.Speed, nil
}

// ClearSpeed clears the value of the "speed" field.
func (m *MemorySlotMutation) ClearSpeed() {
	m.speed = nil
	m.clearedFields[memoryslot.FieldSpeed] = struct{}{}
}

// SpeedCleared returns if the "speed" field was cleared in this mutation.
func (m *MemorySlotMutation) SpeedCleared() bool {
	_, ok := m.clearedFields[memoryslot.FieldSpeed]
	return ok
}

// ResetSpeed resets all changes to the "speed" field.
func (m *MemorySlotMutation) ResetSpeed() {
	m.speed = nil
	delete(m.clearedFields, memoryslot.FieldSpeed)
}

// SetManufacturer sets the "manufacturer" field.
func (m *MemorySlotMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *MemorySlotMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the MemorySlot entity.
// If the MemorySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemorySlotMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *MemorySlotMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[memoryslot.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *MemorySlotMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[memoryslot.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *MemorySlotMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, memoryslot.FieldManufacturer)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *MemorySlotMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *MemorySlotMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *MemorySlotMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MemorySlotMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MemorySlotMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MemorySlotMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the MemorySlotMutation builder.
func (m *MemorySlotMutation) Where(ps ...predicate.MemorySlot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemorySlotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemorySlotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemorySlot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemorySlotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemorySlotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemorySlot).
func (m *MemorySlotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemorySlotMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.slot != nil {
		fields = append(fields, memoryslot.FieldSlot)
	}
	if m.size != nil {
		fields = append(fields, memoryslot.FieldSize)
	}
	if m._type != nil {
		fields = append(fields, memoryslot.FieldType)
	}
	if m.serial_number != nil {
		fields = append(fields, memoryslot.FieldSerialNumber)
	}
	if m.part_number != nil {
		fields = append(fields, memoryslot.FieldPartNumber)
	}
	if m.speed != nil {
		fields = append(fields, memoryslot.FieldSpeed)
	}
	if m.manufacturer != nil {
		fields = append(fields, memoryslot.FieldManufacturer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemorySlotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memoryslot.FieldSlot:
		return m.Slot()
	case memoryslot.FieldSize:
		return m.Size()
	case memoryslot.FieldType:
		return m.GetType()
	case memoryslot.FieldSerialNumber:
		return m.SerialNumber()
	case memoryslot.FieldPartNumber:
		return m.PartNumber()
	case memoryslot.FieldSpeed:
		return m.Speed()
	case memoryslot.FieldManufacturer:
		return m.Manufacturer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemorySlotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memoryslot.FieldSlot:
		return m.OldSlot(ctx)
	case memoryslot.FieldSize:
		return m.OldSize(ctx)
	case memoryslot.FieldType:
		return m.OldType(ctx)
	case memoryslot.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case memoryslot.FieldPartNumber:
		return m.OldPartNumber(ctx)
	case memoryslot.FieldSpeed:
		return m.OldSpeed(ctx)
	case memoryslot.FieldManufacturer:
		return m.OldManufacturer(ctx)
	}
	return nil, fmt.Errorf("unknown MemorySlot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemorySlotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memoryslot.FieldSlot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlot(v)
		return nil
	case memoryslot.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case memoryslot.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case memoryslot.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case memoryslot.FieldPartNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartNumber(v)
		return nil
	case memoryslot.FieldSpeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeed(v)
		return nil
	case memoryslot.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	}
	return fmt.Errorf("unknown MemorySlot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemorySlotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemorySlotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemorySlotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MemorySlot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemorySlotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memoryslot.FieldSlot) {
		fields = append(fields, memoryslot.FieldSlot)
	}
	if m.FieldCleared(memoryslot.FieldSize) {
		fields = append(fields, memoryslot.FieldSize)
	}
	if m.FieldCleared(memoryslot.FieldType) {
		fields = append(fields, memoryslot.FieldType)
	}
	if m.FieldCleared(memoryslot.FieldSerialNumber) {
		fields = append(fields, memoryslot.FieldSerialNumber)
	}
	if m.FieldCleared(memoryslot.FieldPartNumber) {
		fields = append(fields, memoryslot.FieldPartNumber)
	}
	if m.FieldCleared(memoryslot.FieldSpeed) {
		fields = append(fields, memoryslot.FieldSpeed)
	}
	if m.FieldCleared(memoryslot.FieldManufacturer) {
		fields = append(fields, memoryslot.FieldManufacturer)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemorySlotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemorySlotMutation) ClearField(name string) error {
	switch name {
	case memoryslot.FieldSlot:
		m.ClearSlot()
		return nil
	case memoryslot.FieldSize:
		m.ClearSize()
		return nil
	case memoryslot.FieldType:
		m.ClearType()
		return nil
	case memoryslot.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case memoryslot.FieldPartNumber:
		m.ClearPartNumber()
		return nil
	case memoryslot.FieldSpeed:
		m.ClearSpeed()
		return nil
	case memoryslot.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	}
	return fmt.Errorf("unknown MemorySlot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemorySlotMutation) ResetField(name string) error {
	switch name {
	case memoryslot.FieldSlot:
		m.ResetSlot()
		return nil
	case memoryslot.FieldSize:
		m.ResetSize()
		return nil
	case memoryslot.FieldType:
		m.ResetType()
		return nil
	case memoryslot.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case memoryslot.FieldPartNumber:
		m.ResetPartNumber()
		return nil
	case memoryslot.FieldSpeed:
		m.ResetSpeed()
		return nil
	case memoryslot.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	}
	return fmt.Errorf("unknown MemorySlot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemorySlotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, memoryslot.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemorySlotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memoryslot.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemorySlotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemorySlotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemorySlotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, memoryslot.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemorySlotMutation) EdgeCleared(name string) bool {
	switch name {
	case memoryslot.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemorySlotMutation) ClearEdge(name string) error {
	switch name {
	case memoryslot.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown MemorySlot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemorySlotMutation) ResetEdge(name string) error {
	switch name {
	case memoryslot.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown MemorySlot edge %s", name)
}

// MetadataMutation represents an operation that mutates the Metadata nodes in the graph.
type MetadataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	value         *string
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	org           *int
	clearedorg    bool
	done          bool
	oldValue      func(context.Context) (*Metadata, error)
	predicates    []predicate.Metadata
}

var _ ent.Mutation = (*MetadataMutation)(nil)

// metadataOption allows management of the mutation configuration using functional options.
type metadataOption func(*MetadataMutation)

// newMetadataMutation creates new mutation for the Metadata entity.
func newMetadataMutation(c config, op Op, opts ...metadataOption) *MetadataMutation {
	m := &MetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetadataID sets the ID field of the mutation.
func withMetadataID(id int) metadataOption {
	return func(m *MetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *Metadata
		)
		m.oldValue = func(ctx context.Context) (*Metadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetadata sets the old Metadata of the mutation.
func withMetadata(node *Metadata) metadataOption {
	return func(m *MetadataMutation) {
		m.oldValue = func(context.Context) (*Metadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetadataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetadataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Metadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *MetadataMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *MetadataMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *MetadataMutation) ResetValue() {
	m.value = nil
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *MetadataMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *MetadataMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *MetadataMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MetadataMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MetadataMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetOrgID sets the "org" edge to the OrgMetadata entity by id.
func (m *MetadataMutation) SetOrgID(id int) {
	m.org = &id
}

// ClearOrg clears the "org" edge to the OrgMetadata entity.
func (m *MetadataMutation) ClearOrg() {
	m.clearedorg = true
}

// OrgCleared reports if the "org" edge to the OrgMetadata entity was cleared.
func (m *MetadataMutation) OrgCleared() bool {
	return m.clearedorg
}

// OrgID returns the "org" edge ID in the mutation.
func (m *MetadataMutation) OrgID() (id int, exists bool) {
	if m.org != nil {
		return *m.org, true
	}
	return
}

// OrgIDs returns the "org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) OrgIDs() (ids []int) {
	if id := m.org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrg resets all changes to the "org" edge.
func (m *MetadataMutation) ResetOrg() {
	m.org = nil
	m.clearedorg = false
}

// Where appends a list predicates to the MetadataMutation builder.
func (m *MetadataMutation) Where(ps ...predicate.Metadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Metadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Metadata).
func (m *MetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetadataMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.value != nil {
		fields = append(fields, metadata.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metadata.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metadata.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Metadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metadata.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetadataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetadataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Metadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetadataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetadataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Metadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetadataMutation) ResetField(name string) error {
	switch name {
	case metadata.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, metadata.EdgeOwner)
	}
	if m.org != nil {
		edges = append(edges, metadata.EdgeOrg)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metadata.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case metadata.EdgeOrg:
		if id := m.org; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, metadata.EdgeOwner)
	}
	if m.clearedorg {
		edges = append(edges, metadata.EdgeOrg)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case metadata.EdgeOwner:
		return m.clearedowner
	case metadata.EdgeOrg:
		return m.clearedorg
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetadataMutation) ClearEdge(name string) error {
	switch name {
	case metadata.EdgeOwner:
		m.ClearOwner()
		return nil
	case metadata.EdgeOrg:
		m.ClearOrg()
		return nil
	}
	return fmt.Errorf("unknown Metadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetadataMutation) ResetEdge(name string) error {
	switch name {
	case metadata.EdgeOwner:
		m.ResetOwner()
		return nil
	case metadata.EdgeOrg:
		m.ResetOrg()
		return nil
	}
	return fmt.Errorf("unknown Metadata edge %s", name)
}

// MonitorMutation represents an operation that mutates the Monitor nodes in the graph.
type MonitorMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	manufacturer        *string
	model               *string
	serial              *string
	week_of_manufacture *string
	year_of_manufacture *string
	clearedFields       map[string]struct{}
	owner               *string
	clearedowner        bool
	done                bool
	oldValue            func(context.Context) (*Monitor, error)
	predicates          []predicate.Monitor
}

var _ ent.Mutation = (*MonitorMutation)(nil)

// monitorOption allows management of the mutation configuration using functional options.
type monitorOption func(*MonitorMutation)

// newMonitorMutation creates new mutation for the Monitor entity.
func newMonitorMutation(c config, op Op, opts ...monitorOption) *MonitorMutation {
	m := &MonitorMutation{
		config:        c,
		op:            op,
		typ:           TypeMonitor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMonitorID sets the ID field of the mutation.
func withMonitorID(id int) monitorOption {
	return func(m *MonitorMutation) {
		var (
			err   error
			once  sync.Once
			value *Monitor
		)
		m.oldValue = func(ctx context.Context) (*Monitor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Monitor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMonitor sets the old Monitor of the mutation.
func withMonitor(node *Monitor) monitorOption {
	return func(m *MonitorMutation) {
		m.oldValue = func(context.Context) (*Monitor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MonitorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MonitorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MonitorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MonitorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Monitor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetManufacturer sets the "manufacturer" field.
func (m *MonitorMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *MonitorMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Monitor entity.
// If the Monitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonitorMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *MonitorMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[monitor.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *MonitorMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[monitor.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *MonitorMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, monitor.FieldManufacturer)
}

// SetModel sets the "model" field.
func (m *MonitorMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *MonitorMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Monitor entity.
// If the Monitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonitorMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *MonitorMutation) ClearModel() {
	m.model = nil
	m.clearedFields[monitor.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *MonitorMutation) ModelCleared() bool {
	_, ok := m.clearedFields[monitor.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *MonitorMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, monitor.FieldModel)
}

// SetSerial sets the "serial" field.
func (m *MonitorMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *MonitorMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Monitor entity.
// If the Monitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonitorMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ClearSerial clears the value of the "serial" field.
func (m *MonitorMutation) ClearSerial() {
	m.serial = nil
	m.clearedFields[monitor.FieldSerial] = struct{}{}
}

// SerialCleared returns if the "serial" field was cleared in this mutation.
func (m *MonitorMutation) SerialCleared() bool {
	_, ok := m.clearedFields[monitor.FieldSerial]
	return ok
}

// ResetSerial resets all changes to the "serial" field.
func (m *MonitorMutation) ResetSerial() {
	m.serial = nil
	delete(m.clearedFields, monitor.FieldSerial)
}

// SetWeekOfManufacture sets the "week_of_manufacture" field.
func (m *MonitorMutation) SetWeekOfManufacture(s string) {
	m.week_of_manufacture = &s
}

// WeekOfManufacture returns the value of the "week_of_manufacture" field in the mutation.
func (m *MonitorMutation) WeekOfManufacture() (r string, exists bool) {
	v := m.week_of_manufacture
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekOfManufacture returns the old "week_of_manufacture" field's value of the Monitor entity.
// If the Monitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonitorMutation) OldWeekOfManufacture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeekOfManufacture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeekOfManufacture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekOfManufacture: %w", err)
	}
	return oldValue.WeekOfManufacture, nil
}

// ClearWeekOfManufacture clears the value of the "week_of_manufacture" field.
func (m *MonitorMutation) ClearWeekOfManufacture() {
	m.week_of_manufacture = nil
	m.clearedFields[monitor.FieldWeekOfManufacture] = struct{}{}
}

// WeekOfManufactureCleared returns if the "week_of_manufacture" field was cleared in this mutation.
func (m *MonitorMutation) WeekOfManufactureCleared() bool {
	_, ok := m.clearedFields[monitor.FieldWeekOfManufacture]
	return ok
}

// ResetWeekOfManufacture resets all changes to the "week_of_manufacture" field.
func (m *MonitorMutation) ResetWeekOfManufacture() {
	m.week_of_manufacture = nil
	delete(m.clearedFields, monitor.FieldWeekOfManufacture)
}

// SetYearOfManufacture sets the "year_of_manufacture" field.
func (m *MonitorMutation) SetYearOfManufacture(s string) {
	m.year_of_manufacture = &s
}

// YearOfManufacture returns the value of the "year_of_manufacture" field in the mutation.
func (m *MonitorMutation) YearOfManufacture() (r string, exists bool) {
	v := m.year_of_manufacture
	if v == nil {
		return
	}
	return *v, true
}

// OldYearOfManufacture returns the old "year_of_manufacture" field's value of the Monitor entity.
// If the Monitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonitorMutation) OldYearOfManufacture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYearOfManufacture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYearOfManufacture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYearOfManufacture: %w", err)
	}
	return oldValue.YearOfManufacture, nil
}

// ClearYearOfManufacture clears the value of the "year_of_manufacture" field.
func (m *MonitorMutation) ClearYearOfManufacture() {
	m.year_of_manufacture = nil
	m.clearedFields[monitor.FieldYearOfManufacture] = struct{}{}
}

// YearOfManufactureCleared returns if the "year_of_manufacture" field was cleared in this mutation.
func (m *MonitorMutation) YearOfManufactureCleared() bool {
	_, ok := m.clearedFields[monitor.FieldYearOfManufacture]
	return ok
}

// ResetYearOfManufacture resets all changes to the "year_of_manufacture" field.
func (m *MonitorMutation) ResetYearOfManufacture() {
	m.year_of_manufacture = nil
	delete(m.clearedFields, monitor.FieldYearOfManufacture)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *MonitorMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *MonitorMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *MonitorMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MonitorMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MonitorMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MonitorMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the MonitorMutation builder.
func (m *MonitorMutation) Where(ps ...predicate.Monitor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MonitorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MonitorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Monitor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MonitorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MonitorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Monitor).
func (m *MonitorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MonitorMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.manufacturer != nil {
		fields = append(fields, monitor.FieldManufacturer)
	}
	if m.model != nil {
		fields = append(fields, monitor.FieldModel)
	}
	if m.serial != nil {
		fields = append(fields, monitor.FieldSerial)
	}
	if m.week_of_manufacture != nil {
		fields = append(fields, monitor.FieldWeekOfManufacture)
	}
	if m.year_of_manufacture != nil {
		fields = append(fields, monitor.FieldYearOfManufacture)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MonitorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case monitor.FieldManufacturer:
		return m.Manufacturer()
	case monitor.FieldModel:
		return m.Model()
	case monitor.FieldSerial:
		return m.Serial()
	case monitor.FieldWeekOfManufacture:
		return m.WeekOfManufacture()
	case monitor.FieldYearOfManufacture:
		return m.YearOfManufacture()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MonitorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case monitor.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case monitor.FieldModel:
		return m.OldModel(ctx)
	case monitor.FieldSerial:
		return m.OldSerial(ctx)
	case monitor.FieldWeekOfManufacture:
		return m.OldWeekOfManufacture(ctx)
	case monitor.FieldYearOfManufacture:
		return m.OldYearOfManufacture(ctx)
	}
	return nil, fmt.Errorf("unknown Monitor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MonitorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case monitor.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case monitor.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case monitor.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case monitor.FieldWeekOfManufacture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekOfManufacture(v)
		return nil
	case monitor.FieldYearOfManufacture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYearOfManufacture(v)
		return nil
	}
	return fmt.Errorf("unknown Monitor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MonitorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MonitorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MonitorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Monitor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MonitorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(monitor.FieldManufacturer) {
		fields = append(fields, monitor.FieldManufacturer)
	}
	if m.FieldCleared(monitor.FieldModel) {
		fields = append(fields, monitor.FieldModel)
	}
	if m.FieldCleared(monitor.FieldSerial) {
		fields = append(fields, monitor.FieldSerial)
	}
	if m.FieldCleared(monitor.FieldWeekOfManufacture) {
		fields = append(fields, monitor.FieldWeekOfManufacture)
	}
	if m.FieldCleared(monitor.FieldYearOfManufacture) {
		fields = append(fields, monitor.FieldYearOfManufacture)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MonitorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MonitorMutation) ClearField(name string) error {
	switch name {
	case monitor.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	case monitor.FieldModel:
		m.ClearModel()
		return nil
	case monitor.FieldSerial:
		m.ClearSerial()
		return nil
	case monitor.FieldWeekOfManufacture:
		m.ClearWeekOfManufacture()
		return nil
	case monitor.FieldYearOfManufacture:
		m.ClearYearOfManufacture()
		return nil
	}
	return fmt.Errorf("unknown Monitor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MonitorMutation) ResetField(name string) error {
	switch name {
	case monitor.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case monitor.FieldModel:
		m.ResetModel()
		return nil
	case monitor.FieldSerial:
		m.ResetSerial()
		return nil
	case monitor.FieldWeekOfManufacture:
		m.ResetWeekOfManufacture()
		return nil
	case monitor.FieldYearOfManufacture:
		m.ResetYearOfManufacture()
		return nil
	}
	return fmt.Errorf("unknown Monitor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MonitorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, monitor.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MonitorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case monitor.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MonitorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MonitorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MonitorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, monitor.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MonitorMutation) EdgeCleared(name string) bool {
	switch name {
	case monitor.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MonitorMutation) ClearEdge(name string) error {
	switch name {
	case monitor.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Monitor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MonitorMutation) ResetEdge(name string) error {
	switch name {
	case monitor.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Monitor edge %s", name)
}

// NetbirdMutation represents an operation that mutates the Netbird nodes in the graph.
type NetbirdMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	version              *string
	installed            *bool
	service_status       *string
	ip                   *string
	profile              *string
	management_url       *string
	management_connected *bool
	signal_url           *string
	signal_connected     *bool
	ssh_enabled          *bool
	peers_total          *int
	addpeers_total       *int
	peers_connected      *int
	addpeers_connected   *int
	profiles_available   *string
	dns_server           *string
	clearedFields        map[string]struct{}
	owner                *string
	clearedowner         bool
	done                 bool
	oldValue             func(context.Context) (*Netbird, error)
	predicates           []predicate.Netbird
}

var _ ent.Mutation = (*NetbirdMutation)(nil)

// netbirdOption allows management of the mutation configuration using functional options.
type netbirdOption func(*NetbirdMutation)

// newNetbirdMutation creates new mutation for the Netbird entity.
func newNetbirdMutation(c config, op Op, opts ...netbirdOption) *NetbirdMutation {
	m := &NetbirdMutation{
		config:        c,
		op:            op,
		typ:           TypeNetbird,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetbirdID sets the ID field of the mutation.
func withNetbirdID(id int) netbirdOption {
	return func(m *NetbirdMutation) {
		var (
			err   error
			once  sync.Once
			value *Netbird
		)
		m.oldValue = func(ctx context.Context) (*Netbird, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Netbird.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetbird sets the old Netbird of the mutation.
func withNetbird(node *Netbird) netbirdOption {
	return func(m *NetbirdMutation) {
		m.oldValue = func(context.Context) (*Netbird, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetbirdMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetbirdMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetbirdMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetbirdMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Netbird.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *NetbirdMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *NetbirdMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *NetbirdMutation) ResetVersion() {
	m.version = nil
}

// SetInstalled sets the "installed" field.
func (m *NetbirdMutation) SetInstalled(b bool) {
	m.installed = &b
}

// Installed returns the value of the "installed" field in the mutation.
func (m *NetbirdMutation) Installed() (r bool, exists bool) {
	v := m.installed
	if v == nil {
		return
	}
	return *v, true
}

// OldInstalled returns the old "installed" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldInstalled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstalled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstalled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstalled: %w", err)
	}
	return oldValue.Installed, nil
}

// ResetInstalled resets all changes to the "installed" field.
func (m *NetbirdMutation) ResetInstalled() {
	m.installed = nil
}

// SetServiceStatus sets the "service_status" field.
func (m *NetbirdMutation) SetServiceStatus(s string) {
	m.service_status = &s
}

// ServiceStatus returns the value of the "service_status" field in the mutation.
func (m *NetbirdMutation) ServiceStatus() (r string, exists bool) {
	v := m.service_status
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceStatus returns the old "service_status" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldServiceStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceStatus: %w", err)
	}
	return oldValue.ServiceStatus, nil
}

// ResetServiceStatus resets all changes to the "service_status" field.
func (m *NetbirdMutation) ResetServiceStatus() {
	m.service_status = nil
}

// SetIP sets the "ip" field.
func (m *NetbirdMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *NetbirdMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *NetbirdMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[netbird.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *NetbirdMutation) IPCleared() bool {
	_, ok := m.clearedFields[netbird.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *NetbirdMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, netbird.FieldIP)
}

// SetProfile sets the "profile" field.
func (m *NetbirdMutation) SetProfile(s string) {
	m.profile = &s
}

// Profile returns the value of the "profile" field in the mutation.
func (m *NetbirdMutation) Profile() (r string, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldProfile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ClearProfile clears the value of the "profile" field.
func (m *NetbirdMutation) ClearProfile() {
	m.profile = nil
	m.clearedFields[netbird.FieldProfile] = struct{}{}
}

// ProfileCleared returns if the "profile" field was cleared in this mutation.
func (m *NetbirdMutation) ProfileCleared() bool {
	_, ok := m.clearedFields[netbird.FieldProfile]
	return ok
}

// ResetProfile resets all changes to the "profile" field.
func (m *NetbirdMutation) ResetProfile() {
	m.profile = nil
	delete(m.clearedFields, netbird.FieldProfile)
}

// SetManagementURL sets the "management_url" field.
func (m *NetbirdMutation) SetManagementURL(s string) {
	m.management_url = &s
}

// ManagementURL returns the value of the "management_url" field in the mutation.
func (m *NetbirdMutation) ManagementURL() (r string, exists bool) {
	v := m.management_url
	if v == nil {
		return
	}
	return *v, true
}

// OldManagementURL returns the old "management_url" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldManagementURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagementURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagementURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagementURL: %w", err)
	}
	return oldValue.ManagementURL, nil
}

// ClearManagementURL clears the value of the "management_url" field.
func (m *NetbirdMutation) ClearManagementURL() {
	m.management_url = nil
	m.clearedFields[netbird.FieldManagementURL] = struct{}{}
}

// ManagementURLCleared returns if the "management_url" field was cleared in this mutation.
func (m *NetbirdMutation) ManagementURLCleared() bool {
	_, ok := m.clearedFields[netbird.FieldManagementURL]
	return ok
}

// ResetManagementURL resets all changes to the "management_url" field.
func (m *NetbirdMutation) ResetManagementURL() {
	m.management_url = nil
	delete(m.clearedFields, netbird.FieldManagementURL)
}

// SetManagementConnected sets the "management_connected" field.
func (m *NetbirdMutation) SetManagementConnected(b bool) {
	m.management_connected = &b
}

// ManagementConnected returns the value of the "management_connected" field in the mutation.
func (m *NetbirdMutation) ManagementConnected() (r bool, exists bool) {
	v := m.management_connected
	if v == nil {
		return
	}
	return *v, true
}

// OldManagementConnected returns the old "management_connected" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldManagementConnected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagementConnected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagementConnected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagementConnected: %w", err)
	}
	return oldValue.ManagementConnected, nil
}

// ResetManagementConnected resets all changes to the "management_connected" field.
func (m *NetbirdMutation) ResetManagementConnected() {
	m.management_connected = nil
}

// SetSignalURL sets the "signal_url" field.
func (m *NetbirdMutation) SetSignalURL(s string) {
	m.signal_url = &s
}

// SignalURL returns the value of the "signal_url" field in the mutation.
func (m *NetbirdMutation) SignalURL() (r string, exists bool) {
	v := m.signal_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSignalURL returns the old "signal_url" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldSignalURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignalURL: %w", err)
	}
	return oldValue.SignalURL, nil
}

// ClearSignalURL clears the value of the "signal_url" field.
func (m *NetbirdMutation) ClearSignalURL() {
	m.signal_url = nil
	m.clearedFields[netbird.FieldSignalURL] = struct{}{}
}

// SignalURLCleared returns if the "signal_url" field was cleared in this mutation.
func (m *NetbirdMutation) SignalURLCleared() bool {
	_, ok := m.clearedFields[netbird.FieldSignalURL]
	return ok
}

// ResetSignalURL resets all changes to the "signal_url" field.
func (m *NetbirdMutation) ResetSignalURL() {
	m.signal_url = nil
	delete(m.clearedFields, netbird.FieldSignalURL)
}

// SetSignalConnected sets the "signal_connected" field.
func (m *NetbirdMutation) SetSignalConnected(b bool) {
	m.signal_connected = &b
}

// SignalConnected returns the value of the "signal_connected" field in the mutation.
func (m *NetbirdMutation) SignalConnected() (r bool, exists bool) {
	v := m.signal_connected
	if v == nil {
		return
	}
	return *v, true
}

// OldSignalConnected returns the old "signal_connected" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldSignalConnected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignalConnected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignalConnected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignalConnected: %w", err)
	}
	return oldValue.SignalConnected, nil
}

// ResetSignalConnected resets all changes to the "signal_connected" field.
func (m *NetbirdMutation) ResetSignalConnected() {
	m.signal_connected = nil
}

// SetSSHEnabled sets the "ssh_enabled" field.
func (m *NetbirdMutation) SetSSHEnabled(b bool) {
	m.ssh_enabled = &b
}

// SSHEnabled returns the value of the "ssh_enabled" field in the mutation.
func (m *NetbirdMutation) SSHEnabled() (r bool, exists bool) {
	v := m.ssh_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldSSHEnabled returns the old "ssh_enabled" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldSSHEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSHEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSHEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSHEnabled: %w", err)
	}
	return oldValue.SSHEnabled, nil
}

// ResetSSHEnabled resets all changes to the "ssh_enabled" field.
func (m *NetbirdMutation) ResetSSHEnabled() {
	m.ssh_enabled = nil
}

// SetPeersTotal sets the "peers_total" field.
func (m *NetbirdMutation) SetPeersTotal(i int) {
	m.peers_total = &i
	m.addpeers_total = nil
}

// PeersTotal returns the value of the "peers_total" field in the mutation.
func (m *NetbirdMutation) PeersTotal() (r int, exists bool) {
	v := m.peers_total
	if v == nil {
		return
	}
	return *v, true
}

// OldPeersTotal returns the old "peers_total" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldPeersTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeersTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeersTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeersTotal: %w", err)
	}
	return oldValue.PeersTotal, nil
}

// AddPeersTotal adds i to the "peers_total" field.
func (m *NetbirdMutation) AddPeersTotal(i int) {
	if m.addpeers_total != nil {
		*m.addpeers_total += i
	} else {
		m.addpeers_total = &i
	}
}

// AddedPeersTotal returns the value that was added to the "peers_total" field in this mutation.
func (m *NetbirdMutation) AddedPeersTotal() (r int, exists bool) {
	v := m.addpeers_total
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeersTotal clears the value of the "peers_total" field.
func (m *NetbirdMutation) ClearPeersTotal() {
	m.peers_total = nil
	m.addpeers_total = nil
	m.clearedFields[netbird.FieldPeersTotal] = struct{}{}
}

// PeersTotalCleared returns if the "peers_total" field was cleared in this mutation.
func (m *NetbirdMutation) PeersTotalCleared() bool {
	_, ok := m.clearedFields[netbird.FieldPeersTotal]
	return ok
}

// ResetPeersTotal resets all changes to the "peers_total" field.
func (m *NetbirdMutation) ResetPeersTotal() {
	m.peers_total = nil
	m.addpeers_total = nil
	delete(m.clearedFields, netbird.FieldPeersTotal)
}

// SetPeersConnected sets the "peers_connected" field.
func (m *NetbirdMutation) SetPeersConnected(i int) {
	m.peers_connected = &i
	m.addpeers_connected = nil
}

// PeersConnected returns the value of the "peers_connected" field in the mutation.
func (m *NetbirdMutation) PeersConnected() (r int, exists bool) {
	v := m.peers_connected
	if v == nil {
		return
	}
	return *v, true
}

// OldPeersConnected returns the old "peers_connected" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldPeersConnected(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeersConnected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeersConnected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeersConnected: %w", err)
	}
	return oldValue.PeersConnected, nil
}

// AddPeersConnected adds i to the "peers_connected" field.
func (m *NetbirdMutation) AddPeersConnected(i int) {
	if m.addpeers_connected != nil {
		*m.addpeers_connected += i
	} else {
		m.addpeers_connected = &i
	}
}

// AddedPeersConnected returns the value that was added to the "peers_connected" field in this mutation.
func (m *NetbirdMutation) AddedPeersConnected() (r int, exists bool) {
	v := m.addpeers_connected
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeersConnected clears the value of the "peers_connected" field.
func (m *NetbirdMutation) ClearPeersConnected() {
	m.peers_connected = nil
	m.addpeers_connected = nil
	m.clearedFields[netbird.FieldPeersConnected] = struct{}{}
}

// PeersConnectedCleared returns if the "peers_connected" field was cleared in this mutation.
func (m *NetbirdMutation) PeersConnectedCleared() bool {
	_, ok := m.clearedFields[netbird.FieldPeersConnected]
	return ok
}

// ResetPeersConnected resets all changes to the "peers_connected" field.
func (m *NetbirdMutation) ResetPeersConnected() {
	m.peers_connected = nil
	m.addpeers_connected = nil
	delete(m.clearedFields, netbird.FieldPeersConnected)
}

// SetProfilesAvailable sets the "profiles_available" field.
func (m *NetbirdMutation) SetProfilesAvailable(s string) {
	m.profiles_available = &s
}

// ProfilesAvailable returns the value of the "profiles_available" field in the mutation.
func (m *NetbirdMutation) ProfilesAvailable() (r string, exists bool) {
	v := m.profiles_available
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilesAvailable returns the old "profiles_available" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldProfilesAvailable(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilesAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilesAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilesAvailable: %w", err)
	}
	return oldValue.ProfilesAvailable, nil
}

// ClearProfilesAvailable clears the value of the "profiles_available" field.
func (m *NetbirdMutation) ClearProfilesAvailable() {
	m.profiles_available = nil
	m.clearedFields[netbird.FieldProfilesAvailable] = struct{}{}
}

// ProfilesAvailableCleared returns if the "profiles_available" field was cleared in this mutation.
func (m *NetbirdMutation) ProfilesAvailableCleared() bool {
	_, ok := m.clearedFields[netbird.FieldProfilesAvailable]
	return ok
}

// ResetProfilesAvailable resets all changes to the "profiles_available" field.
func (m *NetbirdMutation) ResetProfilesAvailable() {
	m.profiles_available = nil
	delete(m.clearedFields, netbird.FieldProfilesAvailable)
}

// SetDNSServer sets the "dns_server" field.
func (m *NetbirdMutation) SetDNSServer(s string) {
	m.dns_server = &s
}

// DNSServer returns the value of the "dns_server" field in the mutation.
func (m *NetbirdMutation) DNSServer() (r string, exists bool) {
	v := m.dns_server
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSServer returns the old "dns_server" field's value of the Netbird entity.
// If the Netbird object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdMutation) OldDNSServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSServer: %w", err)
	}
	return oldValue.DNSServer, nil
}

// ClearDNSServer clears the value of the "dns_server" field.
func (m *NetbirdMutation) ClearDNSServer() {
	m.dns_server = nil
	m.clearedFields[netbird.FieldDNSServer] = struct{}{}
}

// DNSServerCleared returns if the "dns_server" field was cleared in this mutation.
func (m *NetbirdMutation) DNSServerCleared() bool {
	_, ok := m.clearedFields[netbird.FieldDNSServer]
	return ok
}

// ResetDNSServer resets all changes to the "dns_server" field.
func (m *NetbirdMutation) ResetDNSServer() {
	m.dns_server = nil
	delete(m.clearedFields, netbird.FieldDNSServer)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *NetbirdMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *NetbirdMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *NetbirdMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NetbirdMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NetbirdMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NetbirdMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the NetbirdMutation builder.
func (m *NetbirdMutation) Where(ps ...predicate.Netbird) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetbirdMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetbirdMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Netbird, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetbirdMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetbirdMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Netbird).
func (m *NetbirdMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetbirdMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.version != nil {
		fields = append(fields, netbird.FieldVersion)
	}
	if m.installed != nil {
		fields = append(fields, netbird.FieldInstalled)
	}
	if m.service_status != nil {
		fields = append(fields, netbird.FieldServiceStatus)
	}
	if m.ip != nil {
		fields = append(fields, netbird.FieldIP)
	}
	if m.profile != nil {
		fields = append(fields, netbird.FieldProfile)
	}
	if m.management_url != nil {
		fields = append(fields, netbird.FieldManagementURL)
	}
	if m.management_connected != nil {
		fields = append(fields, netbird.FieldManagementConnected)
	}
	if m.signal_url != nil {
		fields = append(fields, netbird.FieldSignalURL)
	}
	if m.signal_connected != nil {
		fields = append(fields, netbird.FieldSignalConnected)
	}
	if m.ssh_enabled != nil {
		fields = append(fields, netbird.FieldSSHEnabled)
	}
	if m.peers_total != nil {
		fields = append(fields, netbird.FieldPeersTotal)
	}
	if m.peers_connected != nil {
		fields = append(fields, netbird.FieldPeersConnected)
	}
	if m.profiles_available != nil {
		fields = append(fields, netbird.FieldProfilesAvailable)
	}
	if m.dns_server != nil {
		fields = append(fields, netbird.FieldDNSServer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetbirdMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case netbird.FieldVersion:
		return m.Version()
	case netbird.FieldInstalled:
		return m.Installed()
	case netbird.FieldServiceStatus:
		return m.ServiceStatus()
	case netbird.FieldIP:
		return m.IP()
	case netbird.FieldProfile:
		return m.Profile()
	case netbird.FieldManagementURL:
		return m.ManagementURL()
	case netbird.FieldManagementConnected:
		return m.ManagementConnected()
	case netbird.FieldSignalURL:
		return m.SignalURL()
	case netbird.FieldSignalConnected:
		return m.SignalConnected()
	case netbird.FieldSSHEnabled:
		return m.SSHEnabled()
	case netbird.FieldPeersTotal:
		return m.PeersTotal()
	case netbird.FieldPeersConnected:
		return m.PeersConnected()
	case netbird.FieldProfilesAvailable:
		return m.ProfilesAvailable()
	case netbird.FieldDNSServer:
		return m.DNSServer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetbirdMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case netbird.FieldVersion:
		return m.OldVersion(ctx)
	case netbird.FieldInstalled:
		return m.OldInstalled(ctx)
	case netbird.FieldServiceStatus:
		return m.OldServiceStatus(ctx)
	case netbird.FieldIP:
		return m.OldIP(ctx)
	case netbird.FieldProfile:
		return m.OldProfile(ctx)
	case netbird.FieldManagementURL:
		return m.OldManagementURL(ctx)
	case netbird.FieldManagementConnected:
		return m.OldManagementConnected(ctx)
	case netbird.FieldSignalURL:
		return m.OldSignalURL(ctx)
	case netbird.FieldSignalConnected:
		return m.OldSignalConnected(ctx)
	case netbird.FieldSSHEnabled:
		return m.OldSSHEnabled(ctx)
	case netbird.FieldPeersTotal:
		return m.OldPeersTotal(ctx)
	case netbird.FieldPeersConnected:
		return m.OldPeersConnected(ctx)
	case netbird.FieldProfilesAvailable:
		return m.OldProfilesAvailable(ctx)
	case netbird.FieldDNSServer:
		return m.OldDNSServer(ctx)
	}
	return nil, fmt.Errorf("unknown Netbird field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetbirdMutation) SetField(name string, value ent.Value) error {
	switch name {
	case netbird.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case netbird.FieldInstalled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstalled(v)
		return nil
	case netbird.FieldServiceStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceStatus(v)
		return nil
	case netbird.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case netbird.FieldProfile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case netbird.FieldManagementURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagementURL(v)
		return nil
	case netbird.FieldManagementConnected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagementConnected(v)
		return nil
	case netbird.FieldSignalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignalURL(v)
		return nil
	case netbird.FieldSignalConnected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignalConnected(v)
		return nil
	case netbird.FieldSSHEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSHEnabled(v)
		return nil
	case netbird.FieldPeersTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeersTotal(v)
		return nil
	case netbird.FieldPeersConnected:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeersConnected(v)
		return nil
	case netbird.FieldProfilesAvailable:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilesAvailable(v)
		return nil
	case netbird.FieldDNSServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSServer(v)
		return nil
	}
	return fmt.Errorf("unknown Netbird field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetbirdMutation) AddedFields() []string {
	var fields []string
	if m.addpeers_total != nil {
		fields = append(fields, netbird.FieldPeersTotal)
	}
	if m.addpeers_connected != nil {
		fields = append(fields, netbird.FieldPeersConnected)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetbirdMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case netbird.FieldPeersTotal:
		return m.AddedPeersTotal()
	case netbird.FieldPeersConnected:
		return m.AddedPeersConnected()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetbirdMutation) AddField(name string, value ent.Value) error {
	switch name {
	case netbird.FieldPeersTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeersTotal(v)
		return nil
	case netbird.FieldPeersConnected:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeersConnected(v)
		return nil
	}
	return fmt.Errorf("unknown Netbird numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetbirdMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(netbird.FieldIP) {
		fields = append(fields, netbird.FieldIP)
	}
	if m.FieldCleared(netbird.FieldProfile) {
		fields = append(fields, netbird.FieldProfile)
	}
	if m.FieldCleared(netbird.FieldManagementURL) {
		fields = append(fields, netbird.FieldManagementURL)
	}
	if m.FieldCleared(netbird.FieldSignalURL) {
		fields = append(fields, netbird.FieldSignalURL)
	}
	if m.FieldCleared(netbird.FieldPeersTotal) {
		fields = append(fields, netbird.FieldPeersTotal)
	}
	if m.FieldCleared(netbird.FieldPeersConnected) {
		fields = append(fields, netbird.FieldPeersConnected)
	}
	if m.FieldCleared(netbird.FieldProfilesAvailable) {
		fields = append(fields, netbird.FieldProfilesAvailable)
	}
	if m.FieldCleared(netbird.FieldDNSServer) {
		fields = append(fields, netbird.FieldDNSServer)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetbirdMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetbirdMutation) ClearField(name string) error {
	switch name {
	case netbird.FieldIP:
		m.ClearIP()
		return nil
	case netbird.FieldProfile:
		m.ClearProfile()
		return nil
	case netbird.FieldManagementURL:
		m.ClearManagementURL()
		return nil
	case netbird.FieldSignalURL:
		m.ClearSignalURL()
		return nil
	case netbird.FieldPeersTotal:
		m.ClearPeersTotal()
		return nil
	case netbird.FieldPeersConnected:
		m.ClearPeersConnected()
		return nil
	case netbird.FieldProfilesAvailable:
		m.ClearProfilesAvailable()
		return nil
	case netbird.FieldDNSServer:
		m.ClearDNSServer()
		return nil
	}
	return fmt.Errorf("unknown Netbird nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetbirdMutation) ResetField(name string) error {
	switch name {
	case netbird.FieldVersion:
		m.ResetVersion()
		return nil
	case netbird.FieldInstalled:
		m.ResetInstalled()
		return nil
	case netbird.FieldServiceStatus:
		m.ResetServiceStatus()
		return nil
	case netbird.FieldIP:
		m.ResetIP()
		return nil
	case netbird.FieldProfile:
		m.ResetProfile()
		return nil
	case netbird.FieldManagementURL:
		m.ResetManagementURL()
		return nil
	case netbird.FieldManagementConnected:
		m.ResetManagementConnected()
		return nil
	case netbird.FieldSignalURL:
		m.ResetSignalURL()
		return nil
	case netbird.FieldSignalConnected:
		m.ResetSignalConnected()
		return nil
	case netbird.FieldSSHEnabled:
		m.ResetSSHEnabled()
		return nil
	case netbird.FieldPeersTotal:
		m.ResetPeersTotal()
		return nil
	case netbird.FieldPeersConnected:
		m.ResetPeersConnected()
		return nil
	case netbird.FieldProfilesAvailable:
		m.ResetProfilesAvailable()
		return nil
	case netbird.FieldDNSServer:
		m.ResetDNSServer()
		return nil
	}
	return fmt.Errorf("unknown Netbird field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetbirdMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, netbird.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetbirdMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case netbird.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetbirdMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetbirdMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetbirdMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, netbird.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetbirdMutation) EdgeCleared(name string) bool {
	switch name {
	case netbird.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetbirdMutation) ClearEdge(name string) error {
	switch name {
	case netbird.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Netbird unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetbirdMutation) ResetEdge(name string) error {
	switch name {
	case netbird.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Netbird edge %s", name)
}

// NetbirdSettingsMutation represents an operation that mutates the NetbirdSettings nodes in the graph.
type NetbirdSettingsMutation struct {
	config
	op             Op
	typ            string
	id             *int
	management_url *string
	access_token   *string
	clearedFields  map[string]struct{}
	tenant         map[int]struct{}
	removedtenant  map[int]struct{}
	clearedtenant  bool
	done           bool
	oldValue       func(context.Context) (*NetbirdSettings, error)
	predicates     []predicate.NetbirdSettings
}

var _ ent.Mutation = (*NetbirdSettingsMutation)(nil)

// netbirdsettingsOption allows management of the mutation configuration using functional options.
type netbirdsettingsOption func(*NetbirdSettingsMutation)

// newNetbirdSettingsMutation creates new mutation for the NetbirdSettings entity.
func newNetbirdSettingsMutation(c config, op Op, opts ...netbirdsettingsOption) *NetbirdSettingsMutation {
	m := &NetbirdSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeNetbirdSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetbirdSettingsID sets the ID field of the mutation.
func withNetbirdSettingsID(id int) netbirdsettingsOption {
	return func(m *NetbirdSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *NetbirdSettings
		)
		m.oldValue = func(ctx context.Context) (*NetbirdSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetbirdSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetbirdSettings sets the old NetbirdSettings of the mutation.
func withNetbirdSettings(node *NetbirdSettings) netbirdsettingsOption {
	return func(m *NetbirdSettingsMutation) {
		m.oldValue = func(context.Context) (*NetbirdSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetbirdSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetbirdSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetbirdSettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetbirdSettingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetbirdSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetManagementURL sets the "management_url" field.
func (m *NetbirdSettingsMutation) SetManagementURL(s string) {
	m.management_url = &s
}

// ManagementURL returns the value of the "management_url" field in the mutation.
func (m *NetbirdSettingsMutation) ManagementURL() (r string, exists bool) {
	v := m.management_url
	if v == nil {
		return
	}
	return *v, true
}

// OldManagementURL returns the old "management_url" field's value of the NetbirdSettings entity.
// If the NetbirdSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdSettingsMutation) OldManagementURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagementURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagementURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagementURL: %w", err)
	}
	return oldValue.ManagementURL, nil
}

// ClearManagementURL clears the value of the "management_url" field.
func (m *NetbirdSettingsMutation) ClearManagementURL() {
	m.management_url = nil
	m.clearedFields[netbirdsettings.FieldManagementURL] = struct{}{}
}

// ManagementURLCleared returns if the "management_url" field was cleared in this mutation.
func (m *NetbirdSettingsMutation) ManagementURLCleared() bool {
	_, ok := m.clearedFields[netbirdsettings.FieldManagementURL]
	return ok
}

// ResetManagementURL resets all changes to the "management_url" field.
func (m *NetbirdSettingsMutation) ResetManagementURL() {
	m.management_url = nil
	delete(m.clearedFields, netbirdsettings.FieldManagementURL)
}

// SetAccessToken sets the "access_token" field.
func (m *NetbirdSettingsMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *NetbirdSettingsMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the NetbirdSettings entity.
// If the NetbirdSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetbirdSettingsMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ClearAccessToken clears the value of the "access_token" field.
func (m *NetbirdSettingsMutation) ClearAccessToken() {
	m.access_token = nil
	m.clearedFields[netbirdsettings.FieldAccessToken] = struct{}{}
}

// AccessTokenCleared returns if the "access_token" field was cleared in this mutation.
func (m *NetbirdSettingsMutation) AccessTokenCleared() bool {
	_, ok := m.clearedFields[netbirdsettings.FieldAccessToken]
	return ok
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *NetbirdSettingsMutation) ResetAccessToken() {
	m.access_token = nil
	delete(m.clearedFields, netbirdsettings.FieldAccessToken)
}

// AddTenantIDs adds the "tenant" edge to the Tenant entity by ids.
func (m *NetbirdSettingsMutation) AddTenantIDs(ids ...int) {
	if m.tenant == nil {
		m.tenant = make(map[int]struct{})
	}
	for i := range ids {
		m.tenant[ids[i]] = struct{}{}
	}
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *NetbirdSettingsMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *NetbirdSettingsMutation) TenantCleared() bool {
	return m.clearedtenant
}

// RemoveTenantIDs removes the "tenant" edge to the Tenant entity by IDs.
func (m *NetbirdSettingsMutation) RemoveTenantIDs(ids ...int) {
	if m.removedtenant == nil {
		m.removedtenant = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tenant, ids[i])
		m.removedtenant[ids[i]] = struct{}{}
	}
}

// RemovedTenant returns the removed IDs of the "tenant" edge to the Tenant entity.
func (m *NetbirdSettingsMutation) RemovedTenantIDs() (ids []int) {
	for id := range m.removedtenant {
		ids = append(ids, id)
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
func (m *NetbirdSettingsMutation) TenantIDs() (ids []int) {
	for id := range m.tenant {
		ids = append(ids, id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *NetbirdSettingsMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
	m.removedtenant = nil
}

// Where appends a list predicates to the NetbirdSettingsMutation builder.
func (m *NetbirdSettingsMutation) Where(ps ...predicate.NetbirdSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetbirdSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetbirdSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetbirdSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetbirdSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetbirdSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetbirdSettings).
func (m *NetbirdSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetbirdSettingsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.management_url != nil {
		fields = append(fields, netbirdsettings.FieldManagementURL)
	}
	if m.access_token != nil {
		fields = append(fields, netbirdsettings.FieldAccessToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetbirdSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case netbirdsettings.FieldManagementURL:
		return m.ManagementURL()
	case netbirdsettings.FieldAccessToken:
		return m.AccessToken()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetbirdSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case netbirdsettings.FieldManagementURL:
		return m.OldManagementURL(ctx)
	case netbirdsettings.FieldAccessToken:
		return m.OldAccessToken(ctx)
	}
	return nil, fmt.Errorf("unknown NetbirdSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetbirdSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case netbirdsettings.FieldManagementURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagementURL(v)
		return nil
	case netbirdsettings.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	}
	return fmt.Errorf("unknown NetbirdSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetbirdSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetbirdSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetbirdSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetbirdSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetbirdSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(netbirdsettings.FieldManagementURL) {
		fields = append(fields, netbirdsettings.FieldManagementURL)
	}
	if m.FieldCleared(netbirdsettings.FieldAccessToken) {
		fields = append(fields, netbirdsettings.FieldAccessToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetbirdSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetbirdSettingsMutation) ClearField(name string) error {
	switch name {
	case netbirdsettings.FieldManagementURL:
		m.ClearManagementURL()
		return nil
	case netbirdsettings.FieldAccessToken:
		m.ClearAccessToken()
		return nil
	}
	return fmt.Errorf("unknown NetbirdSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetbirdSettingsMutation) ResetField(name string) error {
	switch name {
	case netbirdsettings.FieldManagementURL:
		m.ResetManagementURL()
		return nil
	case netbirdsettings.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	}
	return fmt.Errorf("unknown NetbirdSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetbirdSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, netbirdsettings.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetbirdSettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case netbirdsettings.EdgeTenant:
		ids := make([]ent.Value, 0, len(m.tenant))
		for id := range m.tenant {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetbirdSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtenant != nil {
		edges = append(edges, netbirdsettings.EdgeTenant)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetbirdSettingsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case netbirdsettings.EdgeTenant:
		ids := make([]ent.Value, 0, len(m.removedtenant))
		for id := range m.removedtenant {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetbirdSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, netbirdsettings.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetbirdSettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case netbirdsettings.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetbirdSettingsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NetbirdSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetbirdSettingsMutation) ResetEdge(name string) error {
	switch name {
	case netbirdsettings.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown NetbirdSettings edge %s", name)
}

// NetworkAdapterMutation represents an operation that mutates the NetworkAdapter nodes in the graph.
type NetworkAdapterMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	mac_address         *string
	addresses           *string
	subnet              *string
	default_gateway     *string
	dns_servers         *string
	dns_domain          *string
	dhcp_enabled        *bool
	dhcp_lease_obtained *time.Time
	dhcp_lease_expired  *time.Time
	speed               *string
	virtual             *bool
	clearedFields       map[string]struct{}
	owner               *string
	clearedowner        bool
	done                bool
	oldValue            func(context.Context) (*NetworkAdapter, error)
	predicates          []predicate.NetworkAdapter
}

var _ ent.Mutation = (*NetworkAdapterMutation)(nil)

// networkadapterOption allows management of the mutation configuration using functional options.
type networkadapterOption func(*NetworkAdapterMutation)

// newNetworkAdapterMutation creates new mutation for the NetworkAdapter entity.
func newNetworkAdapterMutation(c config, op Op, opts ...networkadapterOption) *NetworkAdapterMutation {
	m := &NetworkAdapterMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkAdapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkAdapterID sets the ID field of the mutation.
func withNetworkAdapterID(id int) networkadapterOption {
	return func(m *NetworkAdapterMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkAdapter
		)
		m.oldValue = func(ctx context.Context) (*NetworkAdapter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkAdapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkAdapter sets the old NetworkAdapter of the mutation.
func withNetworkAdapter(node *NetworkAdapter) networkadapterOption {
	return func(m *NetworkAdapterMutation) {
		m.oldValue = func(context.Context) (*NetworkAdapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkAdapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkAdapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkAdapterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkAdapterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkAdapter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NetworkAdapterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NetworkAdapterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NetworkAdapterMutation) ResetName() {
	m.name = nil
}

// SetMACAddress sets the "mac_address" field.
func (m *NetworkAdapterMutation) SetMACAddress(s string) {
	m.mac_address = &s
}

// MACAddress returns the value of the "mac_address" field in the mutation.
func (m *NetworkAdapterMutation) MACAddress() (r string, exists bool) {
	v := m.mac_address
	if v == nil {
		return
	}
	return *v, true
}

// OldMACAddress returns the old "mac_address" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldMACAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMACAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMACAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMACAddress: %w", err)
	}
	return oldValue.MACAddress, nil
}

// ResetMACAddress resets all changes to the "mac_address" field.
func (m *NetworkAdapterMutation) ResetMACAddress() {
	m.mac_address = nil
}

// SetAddresses sets the "addresses" field.
func (m *NetworkAdapterMutation) SetAddresses(s string) {
	m.addresses = &s
}

// Addresses returns the value of the "addresses" field in the mutation.
func (m *NetworkAdapterMutation) Addresses() (r string, exists bool) {
	v := m.addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldAddresses returns the old "addresses" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldAddresses(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddresses: %w", err)
	}
	return oldValue.Addresses, nil
}

// ResetAddresses resets all changes to the "addresses" field.
func (m *NetworkAdapterMutation) ResetAddresses() {
	m.addresses = nil
}

// SetSubnet sets the "subnet" field.
func (m *NetworkAdapterMutation) SetSubnet(s string) {
	m.subnet = &s
}

// Subnet returns the value of the "subnet" field in the mutation.
func (m *NetworkAdapterMutation) Subnet() (r string, exists bool) {
	v := m.subnet
	if v == nil {
		return
	}
	return *v, true
}

// OldSubnet returns the old "subnet" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldSubnet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubnet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubnet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubnet: %w", err)
	}
	return oldValue.Subnet, nil
}

// ClearSubnet clears the value of the "subnet" field.
func (m *NetworkAdapterMutation) ClearSubnet() {
	m.subnet = nil
	m.clearedFields[networkadapter.FieldSubnet] = struct{}{}
}

// SubnetCleared returns if the "subnet" field was cleared in this mutation.
func (m *NetworkAdapterMutation) SubnetCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldSubnet]
	return ok
}

// ResetSubnet resets all changes to the "subnet" field.
func (m *NetworkAdapterMutation) ResetSubnet() {
	m.subnet = nil
	delete(m.clearedFields, networkadapter.FieldSubnet)
}

// SetDefaultGateway sets the "default_gateway" field.
func (m *NetworkAdapterMutation) SetDefaultGateway(s string) {
	m.default_gateway = &s
}

// DefaultGateway returns the value of the "default_gateway" field in the mutation.
func (m *NetworkAdapterMutation) DefaultGateway() (r string, exists bool) {
	v := m.default_gateway
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultGateway returns the old "default_gateway" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldDefaultGateway(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultGateway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultGateway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultGateway: %w", err)
	}
	return oldValue.DefaultGateway, nil
}

// ClearDefaultGateway clears the value of the "default_gateway" field.
func (m *NetworkAdapterMutation) ClearDefaultGateway() {
	m.default_gateway = nil
	m.clearedFields[networkadapter.FieldDefaultGateway] = struct{}{}
}

// DefaultGatewayCleared returns if the "default_gateway" field was cleared in this mutation.
func (m *NetworkAdapterMutation) DefaultGatewayCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldDefaultGateway]
	return ok
}

// ResetDefaultGateway resets all changes to the "default_gateway" field.
func (m *NetworkAdapterMutation) ResetDefaultGateway() {
	m.default_gateway = nil
	delete(m.clearedFields, networkadapter.FieldDefaultGateway)
}

// SetDNSServers sets the "dns_servers" field.
func (m *NetworkAdapterMutation) SetDNSServers(s string) {
	m.dns_servers = &s
}

// DNSServers returns the value of the "dns_servers" field in the mutation.
func (m *NetworkAdapterMutation) DNSServers() (r string, exists bool) {
	v := m.dns_servers
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSServers returns the old "dns_servers" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldDNSServers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSServers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSServers: %w", err)
	}
	return oldValue.DNSServers, nil
}

// ClearDNSServers clears the value of the "dns_servers" field.
func (m *NetworkAdapterMutation) ClearDNSServers() {
	m.dns_servers = nil
	m.clearedFields[networkadapter.FieldDNSServers] = struct{}{}
}

// DNSServersCleared returns if the "dns_servers" field was cleared in this mutation.
func (m *NetworkAdapterMutation) DNSServersCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldDNSServers]
	return ok
}

// ResetDNSServers resets all changes to the "dns_servers" field.
func (m *NetworkAdapterMutation) ResetDNSServers() {
	m.dns_servers = nil
	delete(m.clearedFields, networkadapter.FieldDNSServers)
}

// SetDNSDomain sets the "dns_domain" field.
func (m *NetworkAdapterMutation) SetDNSDomain(s string) {
	m.dns_domain = &s
}

// DNSDomain returns the value of the "dns_domain" field in the mutation.
func (m *NetworkAdapterMutation) DNSDomain() (r string, exists bool) {
	v := m.dns_domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSDomain returns the old "dns_domain" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldDNSDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSDomain: %w", err)
	}
	return oldValue.DNSDomain, nil
}

// ClearDNSDomain clears the value of the "dns_domain" field.
func (m *NetworkAdapterMutation) ClearDNSDomain() {
	m.dns_domain = nil
	m.clearedFields[networkadapter.FieldDNSDomain] = struct{}{}
}

// DNSDomainCleared returns if the "dns_domain" field was cleared in this mutation.
func (m *NetworkAdapterMutation) DNSDomainCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldDNSDomain]
	return ok
}

// ResetDNSDomain resets all changes to the "dns_domain" field.
func (m *NetworkAdapterMutation) ResetDNSDomain() {
	m.dns_domain = nil
	delete(m.clearedFields, networkadapter.FieldDNSDomain)
}

// SetDhcpEnabled sets the "dhcp_enabled" field.
func (m *NetworkAdapterMutation) SetDhcpEnabled(b bool) {
	m.dhcp_enabled = &b
}

// DhcpEnabled returns the value of the "dhcp_enabled" field in the mutation.
func (m *NetworkAdapterMutation) DhcpEnabled() (r bool, exists bool) {
	v := m.dhcp_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDhcpEnabled returns the old "dhcp_enabled" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldDhcpEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDhcpEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDhcpEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDhcpEnabled: %w", err)
	}
	return oldValue.DhcpEnabled, nil
}

// ClearDhcpEnabled clears the value of the "dhcp_enabled" field.
func (m *NetworkAdapterMutation) ClearDhcpEnabled() {
	m.dhcp_enabled = nil
	m.clearedFields[networkadapter.FieldDhcpEnabled] = struct{}{}
}

// DhcpEnabledCleared returns if the "dhcp_enabled" field was cleared in this mutation.
func (m *NetworkAdapterMutation) DhcpEnabledCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldDhcpEnabled]
	return ok
}

// ResetDhcpEnabled resets all changes to the "dhcp_enabled" field.
func (m *NetworkAdapterMutation) ResetDhcpEnabled() {
	m.dhcp_enabled = nil
	delete(m.clearedFields, networkadapter.FieldDhcpEnabled)
}

// SetDhcpLeaseObtained sets the "dhcp_lease_obtained" field.
func (m *NetworkAdapterMutation) SetDhcpLeaseObtained(t time.Time) {
	m.dhcp_lease_obtained = &t
}

// DhcpLeaseObtained returns the value of the "dhcp_lease_obtained" field in the mutation.
func (m *NetworkAdapterMutation) DhcpLeaseObtained() (r time.Time, exists bool) {
	v := m.dhcp_lease_obtained
	if v == nil {
		return
	}
	return *v, true
}

// OldDhcpLeaseObtained returns the old "dhcp_lease_obtained" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldDhcpLeaseObtained(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDhcpLeaseObtained is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDhcpLeaseObtained requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDhcpLeaseObtained: %w", err)
	}
	return oldValue.DhcpLeaseObtained, nil
}

// ClearDhcpLeaseObtained clears the value of the "dhcp_lease_obtained" field.
func (m *NetworkAdapterMutation) ClearDhcpLeaseObtained() {
	m.dhcp_lease_obtained = nil
	m.clearedFields[networkadapter.FieldDhcpLeaseObtained] = struct{}{}
}

// DhcpLeaseObtainedCleared returns if the "dhcp_lease_obtained" field was cleared in this mutation.
func (m *NetworkAdapterMutation) DhcpLeaseObtainedCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldDhcpLeaseObtained]
	return ok
}

// ResetDhcpLeaseObtained resets all changes to the "dhcp_lease_obtained" field.
func (m *NetworkAdapterMutation) ResetDhcpLeaseObtained() {
	m.dhcp_lease_obtained = nil
	delete(m.clearedFields, networkadapter.FieldDhcpLeaseObtained)
}

// SetDhcpLeaseExpired sets the "dhcp_lease_expired" field.
func (m *NetworkAdapterMutation) SetDhcpLeaseExpired(t time.Time) {
	m.dhcp_lease_expired = &t
}

// DhcpLeaseExpired returns the value of the "dhcp_lease_expired" field in the mutation.
func (m *NetworkAdapterMutation) DhcpLeaseExpired() (r time.Time, exists bool) {
	v := m.dhcp_lease_expired
	if v == nil {
		return
	}
	return *v, true
}

// OldDhcpLeaseExpired returns the old "dhcp_lease_expired" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldDhcpLeaseExpired(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDhcpLeaseExpired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDhcpLeaseExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDhcpLeaseExpired: %w", err)
	}
	return oldValue.DhcpLeaseExpired, nil
}

// ClearDhcpLeaseExpired clears the value of the "dhcp_lease_expired" field.
func (m *NetworkAdapterMutation) ClearDhcpLeaseExpired() {
	m.dhcp_lease_expired = nil
	m.clearedFields[networkadapter.FieldDhcpLeaseExpired] = struct{}{}
}

// DhcpLeaseExpiredCleared returns if the "dhcp_lease_expired" field was cleared in this mutation.
func (m *NetworkAdapterMutation) DhcpLeaseExpiredCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldDhcpLeaseExpired]
	return ok
}

// ResetDhcpLeaseExpired resets all changes to the "dhcp_lease_expired" field.
func (m *NetworkAdapterMutation) ResetDhcpLeaseExpired() {
	m.dhcp_lease_expired = nil
	delete(m.clearedFields, networkadapter.FieldDhcpLeaseExpired)
}

// SetSpeed sets the "speed" field.
func (m *NetworkAdapterMutation) SetSpeed(s string) {
	m.speed = &s
}

// Speed returns the value of the "speed" field in the mutation.
func (m *NetworkAdapterMutation) Speed() (r string, exists bool) {
	v := m.speed
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeed returns the old "speed" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldSpeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeed: %w", err)
	}
	return oldValue.Speed, nil
}

// ResetSpeed resets all changes to the "speed" field.
func (m *NetworkAdapterMutation) ResetSpeed() {
	m.speed = nil
}

// SetVirtual sets the "virtual" field.
func (m *NetworkAdapterMutation) SetVirtual(b bool) {
	m.virtual = &b
}

// Virtual returns the value of the "virtual" field in the mutation.
func (m *NetworkAdapterMutation) Virtual() (r bool, exists bool) {
	v := m.virtual
	if v == nil {
		return
	}
	return *v, true
}

// OldVirtual returns the old "virtual" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldVirtual(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVirtual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVirtual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVirtual: %w", err)
	}
	return oldValue.Virtual, nil
}

// ClearVirtual clears the value of the "virtual" field.
func (m *NetworkAdapterMutation) ClearVirtual() {
	m.virtual = nil
	m.clearedFields[networkadapter.FieldVirtual] = struct{}{}
}

// VirtualCleared returns if the "virtual" field was cleared in this mutation.
func (m *NetworkAdapterMutation) VirtualCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldVirtual]
	return ok
}

// ResetVirtual resets all changes to the "virtual" field.
func (m *NetworkAdapterMutation) ResetVirtual() {
	m.virtual = nil
	delete(m.clearedFields, networkadapter.FieldVirtual)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *NetworkAdapterMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *NetworkAdapterMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *NetworkAdapterMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NetworkAdapterMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NetworkAdapterMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NetworkAdapterMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the NetworkAdapterMutation builder.
func (m *NetworkAdapterMutation) Where(ps ...predicate.NetworkAdapter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkAdapterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkAdapterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkAdapter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkAdapterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkAdapterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkAdapter).
func (m *NetworkAdapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkAdapterMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, networkadapter.FieldName)
	}
	if m.mac_address != nil {
		fields = append(fields, networkadapter.FieldMACAddress)
	}
	if m.addresses != nil {
		fields = append(fields, networkadapter.FieldAddresses)
	}
	if m.subnet != nil {
		fields = append(fields, networkadapter.FieldSubnet)
	}
	if m.default_gateway != nil {
		fields = append(fields, networkadapter.FieldDefaultGateway)
	}
	if m.dns_servers != nil {
		fields = append(fields, networkadapter.FieldDNSServers)
	}
	if m.dns_domain != nil {
		fields = append(fields, networkadapter.FieldDNSDomain)
	}
	if m.dhcp_enabled != nil {
		fields = append(fields, networkadapter.FieldDhcpEnabled)
	}
	if m.dhcp_lease_obtained != nil {
		fields = append(fields, networkadapter.FieldDhcpLeaseObtained)
	}
	if m.dhcp_lease_expired != nil {
		fields = append(fields, networkadapter.FieldDhcpLeaseExpired)
	}
	if m.speed != nil {
		fields = append(fields, networkadapter.FieldSpeed)
	}
	if m.virtual != nil {
		fields = append(fields, networkadapter.FieldVirtual)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkAdapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networkadapter.FieldName:
		return m.Name()
	case networkadapter.FieldMACAddress:
		return m.MACAddress()
	case networkadapter.FieldAddresses:
		return m.Addresses()
	case networkadapter.FieldSubnet:
		return m.Subnet()
	case networkadapter.FieldDefaultGateway:
		return m.DefaultGateway()
	case networkadapter.FieldDNSServers:
		return m.DNSServers()
	case networkadapter.FieldDNSDomain:
		return m.DNSDomain()
	case networkadapter.FieldDhcpEnabled:
		return m.DhcpEnabled()
	case networkadapter.FieldDhcpLeaseObtained:
		return m.DhcpLeaseObtained()
	case networkadapter.FieldDhcpLeaseExpired:
		return m.DhcpLeaseExpired()
	case networkadapter.FieldSpeed:
		return m.Speed()
	case networkadapter.FieldVirtual:
		return m.Virtual()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkAdapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networkadapter.FieldName:
		return m.OldName(ctx)
	case networkadapter.FieldMACAddress:
		return m.OldMACAddress(ctx)
	case networkadapter.FieldAddresses:
		return m.OldAddresses(ctx)
	case networkadapter.FieldSubnet:
		return m.OldSubnet(ctx)
	case networkadapter.FieldDefaultGateway:
		return m.OldDefaultGateway(ctx)
	case networkadapter.FieldDNSServers:
		return m.OldDNSServers(ctx)
	case networkadapter.FieldDNSDomain:
		return m.OldDNSDomain(ctx)
	case networkadapter.FieldDhcpEnabled:
		return m.OldDhcpEnabled(ctx)
	case networkadapter.FieldDhcpLeaseObtained:
		return m.OldDhcpLeaseObtained(ctx)
	case networkadapter.FieldDhcpLeaseExpired:
		return m.OldDhcpLeaseExpired(ctx)
	case networkadapter.FieldSpeed:
		return m.OldSpeed(ctx)
	case networkadapter.FieldVirtual:
		return m.OldVirtual(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkAdapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkAdapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networkadapter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case networkadapter.FieldMACAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMACAddress(v)
		return nil
	case networkadapter.FieldAddresses:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddresses(v)
		return nil
	case networkadapter.FieldSubnet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubnet(v)
		return nil
	case networkadapter.FieldDefaultGateway:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultGateway(v)
		return nil
	case networkadapter.FieldDNSServers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSServers(v)
		return nil
	case networkadapter.FieldDNSDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSDomain(v)
		return nil
	case networkadapter.FieldDhcpEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDhcpEnabled(v)
		return nil
	case networkadapter.FieldDhcpLeaseObtained:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDhcpLeaseObtained(v)
		return nil
	case networkadapter.FieldDhcpLeaseExpired:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDhcpLeaseExpired(v)
		return nil
	case networkadapter.FieldSpeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeed(v)
		return nil
	case networkadapter.FieldVirtual:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVirtual(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkAdapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkAdapterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkAdapterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkAdapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkAdapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkAdapterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(networkadapter.FieldSubnet) {
		fields = append(fields, networkadapter.FieldSubnet)
	}
	if m.FieldCleared(networkadapter.FieldDefaultGateway) {
		fields = append(fields, networkadapter.FieldDefaultGateway)
	}
	if m.FieldCleared(networkadapter.FieldDNSServers) {
		fields = append(fields, networkadapter.FieldDNSServers)
	}
	if m.FieldCleared(networkadapter.FieldDNSDomain) {
		fields = append(fields, networkadapter.FieldDNSDomain)
	}
	if m.FieldCleared(networkadapter.FieldDhcpEnabled) {
		fields = append(fields, networkadapter.FieldDhcpEnabled)
	}
	if m.FieldCleared(networkadapter.FieldDhcpLeaseObtained) {
		fields = append(fields, networkadapter.FieldDhcpLeaseObtained)
	}
	if m.FieldCleared(networkadapter.FieldDhcpLeaseExpired) {
		fields = append(fields, networkadapter.FieldDhcpLeaseExpired)
	}
	if m.FieldCleared(networkadapter.FieldVirtual) {
		fields = append(fields, networkadapter.FieldVirtual)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkAdapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkAdapterMutation) ClearField(name string) error {
	switch name {
	case networkadapter.FieldSubnet:
		m.ClearSubnet()
		return nil
	case networkadapter.FieldDefaultGateway:
		m.ClearDefaultGateway()
		return nil
	case networkadapter.FieldDNSServers:
		m.ClearDNSServers()
		return nil
	case networkadapter.FieldDNSDomain:
		m.ClearDNSDomain()
		return nil
	case networkadapter.FieldDhcpEnabled:
		m.ClearDhcpEnabled()
		return nil
	case networkadapter.FieldDhcpLeaseObtained:
		m.ClearDhcpLeaseObtained()
		return nil
	case networkadapter.FieldDhcpLeaseExpired:
		m.ClearDhcpLeaseExpired()
		return nil
	case networkadapter.FieldVirtual:
		m.ClearVirtual()
		return nil
	}
	return fmt.Errorf("unknown NetworkAdapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkAdapterMutation) ResetField(name string) error {
	switch name {
	case networkadapter.FieldName:
		m.ResetName()
		return nil
	case networkadapter.FieldMACAddress:
		m.ResetMACAddress()
		return nil
	case networkadapter.FieldAddresses:
		m.ResetAddresses()
		return nil
	case networkadapter.FieldSubnet:
		m.ResetSubnet()
		return nil
	case networkadapter.FieldDefaultGateway:
		m.ResetDefaultGateway()
		return nil
	case networkadapter.FieldDNSServers:
		m.ResetDNSServers()
		return nil
	case networkadapter.FieldDNSDomain:
		m.ResetDNSDomain()
		return nil
	case networkadapter.FieldDhcpEnabled:
		m.ResetDhcpEnabled()
		return nil
	case networkadapter.FieldDhcpLeaseObtained:
		m.ResetDhcpLeaseObtained()
		return nil
	case networkadapter.FieldDhcpLeaseExpired:
		m.ResetDhcpLeaseExpired()
		return nil
	case networkadapter.FieldSpeed:
		m.ResetSpeed()
		return nil
	case networkadapter.FieldVirtual:
		m.ResetVirtual()
		return nil
	}
	return fmt.Errorf("unknown NetworkAdapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkAdapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, networkadapter.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkAdapterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networkadapter.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkAdapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkAdapterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkAdapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, networkadapter.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkAdapterMutation) EdgeCleared(name string) bool {
	switch name {
	case networkadapter.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkAdapterMutation) ClearEdge(name string) error {
	switch name {
	case networkadapter.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown NetworkAdapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkAdapterMutation) ResetEdge(name string) error {
	switch name {
	case networkadapter.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown NetworkAdapter edge %s", name)
}

// OperatingSystemMutation represents an operation that mutates the OperatingSystem nodes in the graph.
type OperatingSystemMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_type            *string
	version          *string
	description      *string
	edition          *string
	install_date     *time.Time
	arch             *string
	username         *string
	last_bootup_time *time.Time
	domain           *string
	clearedFields    map[string]struct{}
	owner            *string
	clearedowner     bool
	done             bool
	oldValue         func(context.Context) (*OperatingSystem, error)
	predicates       []predicate.OperatingSystem
}

var _ ent.Mutation = (*OperatingSystemMutation)(nil)

// operatingsystemOption allows management of the mutation configuration using functional options.
type operatingsystemOption func(*OperatingSystemMutation)

// newOperatingSystemMutation creates new mutation for the OperatingSystem entity.
func newOperatingSystemMutation(c config, op Op, opts ...operatingsystemOption) *OperatingSystemMutation {
	m := &OperatingSystemMutation{
		config:        c,
		op:            op,
		typ:           TypeOperatingSystem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperatingSystemID sets the ID field of the mutation.
func withOperatingSystemID(id int) operatingsystemOption {
	return func(m *OperatingSystemMutation) {
		var (
			err   error
			once  sync.Once
			value *OperatingSystem
		)
		m.oldValue = func(ctx context.Context) (*OperatingSystem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OperatingSystem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperatingSystem sets the old OperatingSystem of the mutation.
func withOperatingSystem(node *OperatingSystem) operatingsystemOption {
	return func(m *OperatingSystemMutation) {
		m.oldValue = func(context.Context) (*OperatingSystem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperatingSystemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperatingSystemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OperatingSystemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OperatingSystemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OperatingSystem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *OperatingSystemMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *OperatingSystemMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *OperatingSystemMutation) ClearType() {
	m._type = nil
	m.clearedFields[operatingsystem.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *OperatingSystemMutation) TypeCleared() bool {
	_, ok := m.clearedFields[operatingsystem.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *OperatingSystemMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, operatingsystem.FieldType)
}

// SetVersion sets the "version" field.
func (m *OperatingSystemMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *OperatingSystemMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *OperatingSystemMutation) ResetVersion() {
	m.version = nil
}

// SetDescription sets the "description" field.
func (m *OperatingSystemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OperatingSystemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *OperatingSystemMutation) ResetDescription() {
	m.description = nil
}

// SetEdition sets the "edition" field.
func (m *OperatingSystemMutation) SetEdition(s string) {
	m.edition = &s
}

// Edition returns the value of the "edition" field in the mutation.
func (m *OperatingSystemMutation) Edition() (r string, exists bool) {
	v := m.edition
	if v == nil {
		return
	}
	return *v, true
}

// OldEdition returns the old "edition" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldEdition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEdition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEdition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEdition: %w", err)
	}
	return oldValue.Edition, nil
}

// ClearEdition clears the value of the "edition" field.
func (m *OperatingSystemMutation) ClearEdition() {
	m.edition = nil
	m.clearedFields[operatingsystem.FieldEdition] = struct{}{}
}

// EditionCleared returns if the "edition" field was cleared in this mutation.
func (m *OperatingSystemMutation) EditionCleared() bool {
	_, ok := m.clearedFields[operatingsystem.FieldEdition]
	return ok
}

// ResetEdition resets all changes to the "edition" field.
func (m *OperatingSystemMutation) ResetEdition() {
	m.edition = nil
	delete(m.clearedFields, operatingsystem.FieldEdition)
}

// SetInstallDate sets the "install_date" field.
func (m *OperatingSystemMutation) SetInstallDate(t time.Time) {
	m.install_date = &t
}

// InstallDate returns the value of the "install_date" field in the mutation.
func (m *OperatingSystemMutation) InstallDate() (r time.Time, exists bool) {
	v := m.install_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallDate returns the old "install_date" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldInstallDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallDate: %w", err)
	}
	return oldValue.InstallDate, nil
}

// ClearInstallDate clears the value of the "install_date" field.
func (m *OperatingSystemMutation) ClearInstallDate() {
	m.install_date = nil
	m.clearedFields[operatingsystem.FieldInstallDate] = struct{}{}
}

// InstallDateCleared returns if the "install_date" field was cleared in this mutation.
func (m *OperatingSystemMutation) InstallDateCleared() bool {
	_, ok := m.clearedFields[operatingsystem.FieldInstallDate]
	return ok
}

// ResetInstallDate resets all changes to the "install_date" field.
func (m *OperatingSystemMutation) ResetInstallDate() {
	m.install_date = nil
	delete(m.clearedFields, operatingsystem.FieldInstallDate)
}

// SetArch sets the "arch" field.
func (m *OperatingSystemMutation) SetArch(s string) {
	m.arch = &s
}

// Arch returns the value of the "arch" field in the mutation.
func (m *OperatingSystemMutation) Arch() (r string, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ClearArch clears the value of the "arch" field.
func (m *OperatingSystemMutation) ClearArch() {
	m.arch = nil
	m.clearedFields[operatingsystem.FieldArch] = struct{}{}
}

// ArchCleared returns if the "arch" field was cleared in this mutation.
func (m *OperatingSystemMutation) ArchCleared() bool {
	_, ok := m.clearedFields[operatingsystem.FieldArch]
	return ok
}

// ResetArch resets all changes to the "arch" field.
func (m *OperatingSystemMutation) ResetArch() {
	m.arch = nil
	delete(m.clearedFields, operatingsystem.FieldArch)
}

// SetUsername sets the "username" field.
func (m *OperatingSystemMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *OperatingSystemMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *OperatingSystemMutation) ResetUsername() {
	m.username = nil
}

// SetLastBootupTime sets the "last_bootup_time" field.
func (m *OperatingSystemMutation) SetLastBootupTime(t time.Time) {
	m.last_bootup_time = &t
}

// LastBootupTime returns the value of the "last_bootup_time" field in the mutation.
func (m *OperatingSystemMutation) LastBootupTime() (r time.Time, exists bool) {
	v := m.last_bootup_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastBootupTime returns the old "last_bootup_time" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldLastBootupTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastBootupTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastBootupTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastBootupTime: %w", err)
	}
	return oldValue.LastBootupTime, nil
}

// ClearLastBootupTime clears the value of the "last_bootup_time" field.
func (m *OperatingSystemMutation) ClearLastBootupTime() {
	m.last_bootup_time = nil
	m.clearedFields[operatingsystem.FieldLastBootupTime] = struct{}{}
}

// LastBootupTimeCleared returns if the "last_bootup_time" field was cleared in this mutation.
func (m *OperatingSystemMutation) LastBootupTimeCleared() bool {
	_, ok := m.clearedFields[operatingsystem.FieldLastBootupTime]
	return ok
}

// ResetLastBootupTime resets all changes to the "last_bootup_time" field.
func (m *OperatingSystemMutation) ResetLastBootupTime() {
	m.last_bootup_time = nil
	delete(m.clearedFields, operatingsystem.FieldLastBootupTime)
}

// SetDomain sets the "domain" field.
func (m *OperatingSystemMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *OperatingSystemMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *OperatingSystemMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[operatingsystem.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *OperatingSystemMutation) DomainCleared() bool {
	_, ok := m.clearedFields[operatingsystem.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *OperatingSystemMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, operatingsystem.FieldDomain)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *OperatingSystemMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *OperatingSystemMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *OperatingSystemMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *OperatingSystemMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OperatingSystemMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *OperatingSystemMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the OperatingSystemMutation builder.
func (m *OperatingSystemMutation) Where(ps ...predicate.OperatingSystem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OperatingSystemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OperatingSystemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OperatingSystem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OperatingSystemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OperatingSystemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OperatingSystem).
func (m *OperatingSystemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OperatingSystemMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._type != nil {
		fields = append(fields, operatingsystem.FieldType)
	}
	if m.version != nil {
		fields = append(fields, operatingsystem.FieldVersion)
	}
	if m.description != nil {
		fields = append(fields, operatingsystem.FieldDescription)
	}
	if m.edition != nil {
		fields = append(fields, operatingsystem.FieldEdition)
	}
	if m.install_date != nil {
		fields = append(fields, operatingsystem.FieldInstallDate)
	}
	if m.arch != nil {
		fields = append(fields, operatingsystem.FieldArch)
	}
	if m.username != nil {
		fields = append(fields, operatingsystem.FieldUsername)
	}
	if m.last_bootup_time != nil {
		fields = append(fields, operatingsystem.FieldLastBootupTime)
	}
	if m.domain != nil {
		fields = append(fields, operatingsystem.FieldDomain)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OperatingSystemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operatingsystem.FieldType:
		return m.GetType()
	case operatingsystem.FieldVersion:
		return m.Version()
	case operatingsystem.FieldDescription:
		return m.Description()
	case operatingsystem.FieldEdition:
		return m.Edition()
	case operatingsystem.FieldInstallDate:
		return m.InstallDate()
	case operatingsystem.FieldArch:
		return m.Arch()
	case operatingsystem.FieldUsername:
		return m.Username()
	case operatingsystem.FieldLastBootupTime:
		return m.LastBootupTime()
	case operatingsystem.FieldDomain:
		return m.Domain()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OperatingSystemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operatingsystem.FieldType:
		return m.OldType(ctx)
	case operatingsystem.FieldVersion:
		return m.OldVersion(ctx)
	case operatingsystem.FieldDescription:
		return m.OldDescription(ctx)
	case operatingsystem.FieldEdition:
		return m.OldEdition(ctx)
	case operatingsystem.FieldInstallDate:
		return m.OldInstallDate(ctx)
	case operatingsystem.FieldArch:
		return m.OldArch(ctx)
	case operatingsystem.FieldUsername:
		return m.OldUsername(ctx)
	case operatingsystem.FieldLastBootupTime:
		return m.OldLastBootupTime(ctx)
	case operatingsystem.FieldDomain:
		return m.OldDomain(ctx)
	}
	return nil, fmt.Errorf("unknown OperatingSystem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperatingSystemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operatingsystem.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case operatingsystem.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case operatingsystem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case operatingsystem.FieldEdition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEdition(v)
		return nil
	case operatingsystem.FieldInstallDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallDate(v)
		return nil
	case operatingsystem.FieldArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	case operatingsystem.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case operatingsystem.FieldLastBootupTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastBootupTime(v)
		return nil
	case operatingsystem.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	}
	return fmt.Errorf("unknown OperatingSystem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OperatingSystemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OperatingSystemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperatingSystemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OperatingSystem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OperatingSystemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(operatingsystem.FieldType) {
		fields = append(fields, operatingsystem.FieldType)
	}
	if m.FieldCleared(operatingsystem.FieldEdition) {
		fields = append(fields, operatingsystem.FieldEdition)
	}
	if m.FieldCleared(operatingsystem.FieldInstallDate) {
		fields = append(fields, operatingsystem.FieldInstallDate)
	}
	if m.FieldCleared(operatingsystem.FieldArch) {
		fields = append(fields, operatingsystem.FieldArch)
	}
	if m.FieldCleared(operatingsystem.FieldLastBootupTime) {
		fields = append(fields, operatingsystem.FieldLastBootupTime)
	}
	if m.FieldCleared(operatingsystem.FieldDomain) {
		fields = append(fields, operatingsystem.FieldDomain)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OperatingSystemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperatingSystemMutation) ClearField(name string) error {
	switch name {
	case operatingsystem.FieldType:
		m.ClearType()
		return nil
	case operatingsystem.FieldEdition:
		m.ClearEdition()
		return nil
	case operatingsystem.FieldInstallDate:
		m.ClearInstallDate()
		return nil
	case operatingsystem.FieldArch:
		m.ClearArch()
		return nil
	case operatingsystem.FieldLastBootupTime:
		m.ClearLastBootupTime()
		return nil
	case operatingsystem.FieldDomain:
		m.ClearDomain()
		return nil
	}
	return fmt.Errorf("unknown OperatingSystem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OperatingSystemMutation) ResetField(name string) error {
	switch name {
	case operatingsystem.FieldType:
		m.ResetType()
		return nil
	case operatingsystem.FieldVersion:
		m.ResetVersion()
		return nil
	case operatingsystem.FieldDescription:
		m.ResetDescription()
		return nil
	case operatingsystem.FieldEdition:
		m.ResetEdition()
		return nil
	case operatingsystem.FieldInstallDate:
		m.ResetInstallDate()
		return nil
	case operatingsystem.FieldArch:
		m.ResetArch()
		return nil
	case operatingsystem.FieldUsername:
		m.ResetUsername()
		return nil
	case operatingsystem.FieldLastBootupTime:
		m.ResetLastBootupTime()
		return nil
	case operatingsystem.FieldDomain:
		m.ResetDomain()
		return nil
	}
	return fmt.Errorf("unknown OperatingSystem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OperatingSystemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, operatingsystem.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OperatingSystemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case operatingsystem.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OperatingSystemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OperatingSystemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OperatingSystemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, operatingsystem.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OperatingSystemMutation) EdgeCleared(name string) bool {
	switch name {
	case operatingsystem.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OperatingSystemMutation) ClearEdge(name string) error {
	switch name {
	case operatingsystem.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown OperatingSystem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OperatingSystemMutation) ResetEdge(name string) error {
	switch name {
	case operatingsystem.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown OperatingSystem edge %s", name)
}

// OrgMetadataMutation represents an operation that mutates the OrgMetadata nodes in the graph.
type OrgMetadataMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	description     *string
	clearedFields   map[string]struct{}
	metadata        map[int]struct{}
	removedmetadata map[int]struct{}
	clearedmetadata bool
	tenant          *int
	clearedtenant   bool
	done            bool
	oldValue        func(context.Context) (*OrgMetadata, error)
	predicates      []predicate.OrgMetadata
}

var _ ent.Mutation = (*OrgMetadataMutation)(nil)

// orgmetadataOption allows management of the mutation configuration using functional options.
type orgmetadataOption func(*OrgMetadataMutation)

// newOrgMetadataMutation creates new mutation for the OrgMetadata entity.
func newOrgMetadataMutation(c config, op Op, opts ...orgmetadataOption) *OrgMetadataMutation {
	m := &OrgMetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgMetadataID sets the ID field of the mutation.
func withOrgMetadataID(id int) orgmetadataOption {
	return func(m *OrgMetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgMetadata
		)
		m.oldValue = func(ctx context.Context) (*OrgMetadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgMetadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgMetadata sets the old OrgMetadata of the mutation.
func withOrgMetadata(node *OrgMetadata) orgmetadataOption {
	return func(m *OrgMetadataMutation) {
		m.oldValue = func(context.Context) (*OrgMetadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgMetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgMetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgMetadataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgMetadataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgMetadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OrgMetadataMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrgMetadataMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrgMetadata entity.
// If the OrgMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMetadataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrgMetadataMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *OrgMetadataMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrgMetadataMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OrgMetadata entity.
// If the OrgMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMetadataMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrgMetadataMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[orgmetadata.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrgMetadataMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[orgmetadata.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrgMetadataMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, orgmetadata.FieldDescription)
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *OrgMetadataMutation) AddMetadatumIDs(ids ...int) {
	if m.metadata == nil {
		m.metadata = make(map[int]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *OrgMetadataMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *OrgMetadataMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *OrgMetadataMutation) RemoveMetadatumIDs(ids ...int) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *OrgMetadataMutation) RemovedMetadataIDs() (ids []int) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *OrgMetadataMutation) MetadataIDs() (ids []int) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *OrgMetadataMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *OrgMetadataMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OrgMetadataMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OrgMetadataMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *OrgMetadataMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OrgMetadataMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OrgMetadataMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the OrgMetadataMutation builder.
func (m *OrgMetadataMutation) Where(ps ...predicate.OrgMetadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgMetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgMetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgMetadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgMetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgMetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgMetadata).
func (m *OrgMetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgMetadataMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, orgmetadata.FieldName)
	}
	if m.description != nil {
		fields = append(fields, orgmetadata.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgMetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgmetadata.FieldName:
		return m.Name()
	case orgmetadata.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgMetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgmetadata.FieldName:
		return m.OldName(ctx)
	case orgmetadata.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown OrgMetadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgmetadata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orgmetadata.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown OrgMetadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgMetadataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgMetadataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrgMetadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgMetadataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgmetadata.FieldDescription) {
		fields = append(fields, orgmetadata.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgMetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgMetadataMutation) ClearField(name string) error {
	switch name {
	case orgmetadata.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown OrgMetadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgMetadataMutation) ResetField(name string) error {
	switch name {
	case orgmetadata.FieldName:
		m.ResetName()
		return nil
	case orgmetadata.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown OrgMetadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgMetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, orgmetadata.EdgeMetadata)
	}
	if m.tenant != nil {
		edges = append(edges, orgmetadata.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgMetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgmetadata.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case orgmetadata.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgMetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmetadata != nil {
		edges = append(edges, orgmetadata.EdgeMetadata)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgMetadataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orgmetadata.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgMetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, orgmetadata.EdgeMetadata)
	}
	if m.clearedtenant {
		edges = append(edges, orgmetadata.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgMetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case orgmetadata.EdgeMetadata:
		return m.clearedmetadata
	case orgmetadata.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgMetadataMutation) ClearEdge(name string) error {
	switch name {
	case orgmetadata.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown OrgMetadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgMetadataMutation) ResetEdge(name string) error {
	switch name {
	case orgmetadata.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case orgmetadata.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown OrgMetadata edge %s", name)
}

// PhysicalDiskMutation represents an operation that mutates the PhysicalDisk nodes in the graph.
type PhysicalDiskMutation struct {
	config
	op            Op
	typ           string
	id            *int
	device_id     *string
	model         *string
	serial_number *string
	size_in_units *string
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*PhysicalDisk, error)
	predicates    []predicate.PhysicalDisk
}

var _ ent.Mutation = (*PhysicalDiskMutation)(nil)

// physicaldiskOption allows management of the mutation configuration using functional options.
type physicaldiskOption func(*PhysicalDiskMutation)

// newPhysicalDiskMutation creates new mutation for the PhysicalDisk entity.
func newPhysicalDiskMutation(c config, op Op, opts ...physicaldiskOption) *PhysicalDiskMutation {
	m := &PhysicalDiskMutation{
		config:        c,
		op:            op,
		typ:           TypePhysicalDisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPhysicalDiskID sets the ID field of the mutation.
func withPhysicalDiskID(id int) physicaldiskOption {
	return func(m *PhysicalDiskMutation) {
		var (
			err   error
			once  sync.Once
			value *PhysicalDisk
		)
		m.oldValue = func(ctx context.Context) (*PhysicalDisk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PhysicalDisk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPhysicalDisk sets the old PhysicalDisk of the mutation.
func withPhysicalDisk(node *PhysicalDisk) physicaldiskOption {
	return func(m *PhysicalDiskMutation) {
		m.oldValue = func(context.Context) (*PhysicalDisk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PhysicalDiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PhysicalDiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PhysicalDiskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PhysicalDiskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PhysicalDisk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeviceID sets the "device_id" field.
func (m *PhysicalDiskMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *PhysicalDiskMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the PhysicalDisk entity.
// If the PhysicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhysicalDiskMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *PhysicalDiskMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetModel sets the "model" field.
func (m *PhysicalDiskMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *PhysicalDiskMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the PhysicalDisk entity.
// If the PhysicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhysicalDiskMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *PhysicalDiskMutation) ClearModel() {
	m.model = nil
	m.clearedFields[physicaldisk.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *PhysicalDiskMutation) ModelCleared() bool {
	_, ok := m.clearedFields[physicaldisk.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *PhysicalDiskMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, physicaldisk.FieldModel)
}

// SetSerialNumber sets the "serial_number" field.
func (m *PhysicalDiskMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *PhysicalDiskMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the PhysicalDisk entity.
// If the PhysicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhysicalDiskMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *PhysicalDiskMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[physicaldisk.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *PhysicalDiskMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[physicaldisk.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *PhysicalDiskMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, physicaldisk.FieldSerialNumber)
}

// SetSizeInUnits sets the "size_in_units" field.
func (m *PhysicalDiskMutation) SetSizeInUnits(s string) {
	m.size_in_units = &s
}

// SizeInUnits returns the value of the "size_in_units" field in the mutation.
func (m *PhysicalDiskMutation) SizeInUnits() (r string, exists bool) {
	v := m.size_in_units
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeInUnits returns the old "size_in_units" field's value of the PhysicalDisk entity.
// If the PhysicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhysicalDiskMutation) OldSizeInUnits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeInUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeInUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeInUnits: %w", err)
	}
	return oldValue.SizeInUnits, nil
}

// ClearSizeInUnits clears the value of the "size_in_units" field.
func (m *PhysicalDiskMutation) ClearSizeInUnits() {
	m.size_in_units = nil
	m.clearedFields[physicaldisk.FieldSizeInUnits] = struct{}{}
}

// SizeInUnitsCleared returns if the "size_in_units" field was cleared in this mutation.
func (m *PhysicalDiskMutation) SizeInUnitsCleared() bool {
	_, ok := m.clearedFields[physicaldisk.FieldSizeInUnits]
	return ok
}

// ResetSizeInUnits resets all changes to the "size_in_units" field.
func (m *PhysicalDiskMutation) ResetSizeInUnits() {
	m.size_in_units = nil
	delete(m.clearedFields, physicaldisk.FieldSizeInUnits)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *PhysicalDiskMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *PhysicalDiskMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *PhysicalDiskMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PhysicalDiskMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PhysicalDiskMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PhysicalDiskMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the PhysicalDiskMutation builder.
func (m *PhysicalDiskMutation) Where(ps ...predicate.PhysicalDisk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PhysicalDiskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PhysicalDiskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PhysicalDisk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PhysicalDiskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PhysicalDiskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PhysicalDisk).
func (m *PhysicalDiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PhysicalDiskMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.device_id != nil {
		fields = append(fields, physicaldisk.FieldDeviceID)
	}
	if m.model != nil {
		fields = append(fields, physicaldisk.FieldModel)
	}
	if m.serial_number != nil {
		fields = append(fields, physicaldisk.FieldSerialNumber)
	}
	if m.size_in_units != nil {
		fields = append(fields, physicaldisk.FieldSizeInUnits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PhysicalDiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case physicaldisk.FieldDeviceID:
		return m.DeviceID()
	case physicaldisk.FieldModel:
		return m.Model()
	case physicaldisk.FieldSerialNumber:
		return m.SerialNumber()
	case physicaldisk.FieldSizeInUnits:
		return m.SizeInUnits()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PhysicalDiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case physicaldisk.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case physicaldisk.FieldModel:
		return m.OldModel(ctx)
	case physicaldisk.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case physicaldisk.FieldSizeInUnits:
		return m.OldSizeInUnits(ctx)
	}
	return nil, fmt.Errorf("unknown PhysicalDisk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhysicalDiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case physicaldisk.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case physicaldisk.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case physicaldisk.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case physicaldisk.FieldSizeInUnits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeInUnits(v)
		return nil
	}
	return fmt.Errorf("unknown PhysicalDisk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PhysicalDiskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PhysicalDiskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhysicalDiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PhysicalDisk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PhysicalDiskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(physicaldisk.FieldModel) {
		fields = append(fields, physicaldisk.FieldModel)
	}
	if m.FieldCleared(physicaldisk.FieldSerialNumber) {
		fields = append(fields, physicaldisk.FieldSerialNumber)
	}
	if m.FieldCleared(physicaldisk.FieldSizeInUnits) {
		fields = append(fields, physicaldisk.FieldSizeInUnits)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PhysicalDiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PhysicalDiskMutation) ClearField(name string) error {
	switch name {
	case physicaldisk.FieldModel:
		m.ClearModel()
		return nil
	case physicaldisk.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case physicaldisk.FieldSizeInUnits:
		m.ClearSizeInUnits()
		return nil
	}
	return fmt.Errorf("unknown PhysicalDisk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PhysicalDiskMutation) ResetField(name string) error {
	switch name {
	case physicaldisk.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case physicaldisk.FieldModel:
		m.ResetModel()
		return nil
	case physicaldisk.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case physicaldisk.FieldSizeInUnits:
		m.ResetSizeInUnits()
		return nil
	}
	return fmt.Errorf("unknown PhysicalDisk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PhysicalDiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, physicaldisk.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PhysicalDiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case physicaldisk.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PhysicalDiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PhysicalDiskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PhysicalDiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, physicaldisk.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PhysicalDiskMutation) EdgeCleared(name string) bool {
	switch name {
	case physicaldisk.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PhysicalDiskMutation) ClearEdge(name string) error {
	switch name {
	case physicaldisk.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown PhysicalDisk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PhysicalDiskMutation) ResetEdge(name string) error {
	switch name {
	case physicaldisk.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown PhysicalDisk edge %s", name)
}

// PrinterMutation represents an operation that mutates the Printer nodes in the graph.
type PrinterMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	port          *string
	is_default    *bool
	is_network    *bool
	is_shared     *bool
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Printer, error)
	predicates    []predicate.Printer
}

var _ ent.Mutation = (*PrinterMutation)(nil)

// printerOption allows management of the mutation configuration using functional options.
type printerOption func(*PrinterMutation)

// newPrinterMutation creates new mutation for the Printer entity.
func newPrinterMutation(c config, op Op, opts ...printerOption) *PrinterMutation {
	m := &PrinterMutation{
		config:        c,
		op:            op,
		typ:           TypePrinter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrinterID sets the ID field of the mutation.
func withPrinterID(id int) printerOption {
	return func(m *PrinterMutation) {
		var (
			err   error
			once  sync.Once
			value *Printer
		)
		m.oldValue = func(ctx context.Context) (*Printer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Printer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrinter sets the old Printer of the mutation.
func withPrinter(node *Printer) printerOption {
	return func(m *PrinterMutation) {
		m.oldValue = func(context.Context) (*Printer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrinterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrinterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrinterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrinterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Printer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PrinterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PrinterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PrinterMutation) ResetName() {
	m.name = nil
}

// SetPort sets the "port" field.
func (m *PrinterMutation) SetPort(s string) {
	m.port = &s
}

// Port returns the value of the "port" field in the mutation.
func (m *PrinterMutation) Port() (r string, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldPort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// ClearPort clears the value of the "port" field.
func (m *PrinterMutation) ClearPort() {
	m.port = nil
	m.clearedFields[printer.FieldPort] = struct{}{}
}

// PortCleared returns if the "port" field was cleared in this mutation.
func (m *PrinterMutation) PortCleared() bool {
	_, ok := m.clearedFields[printer.FieldPort]
	return ok
}

// ResetPort resets all changes to the "port" field.
func (m *PrinterMutation) ResetPort() {
	m.port = nil
	delete(m.clearedFields, printer.FieldPort)
}

// SetIsDefault sets the "is_default" field.
func (m *PrinterMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *PrinterMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "is_default" field.
func (m *PrinterMutation) ClearIsDefault() {
	m.is_default = nil
	m.clearedFields[printer.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "is_default" field was cleared in this mutation.
func (m *PrinterMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[printer.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *PrinterMutation) ResetIsDefault() {
	m.is_default = nil
	delete(m.clearedFields, printer.FieldIsDefault)
}

// SetIsNetwork sets the "is_network" field.
func (m *PrinterMutation) SetIsNetwork(b bool) {
	m.is_network = &b
}

// IsNetwork returns the value of the "is_network" field in the mutation.
func (m *PrinterMutation) IsNetwork() (r bool, exists bool) {
	v := m.is_network
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNetwork returns the old "is_network" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldIsNetwork(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNetwork: %w", err)
	}
	return oldValue.IsNetwork, nil
}

// ClearIsNetwork clears the value of the "is_network" field.
func (m *PrinterMutation) ClearIsNetwork() {
	m.is_network = nil
	m.clearedFields[printer.FieldIsNetwork] = struct{}{}
}

// IsNetworkCleared returns if the "is_network" field was cleared in this mutation.
func (m *PrinterMutation) IsNetworkCleared() bool {
	_, ok := m.clearedFields[printer.FieldIsNetwork]
	return ok
}

// ResetIsNetwork resets all changes to the "is_network" field.
func (m *PrinterMutation) ResetIsNetwork() {
	m.is_network = nil
	delete(m.clearedFields, printer.FieldIsNetwork)
}

// SetIsShared sets the "is_shared" field.
func (m *PrinterMutation) SetIsShared(b bool) {
	m.is_shared = &b
}

// IsShared returns the value of the "is_shared" field in the mutation.
func (m *PrinterMutation) IsShared() (r bool, exists bool) {
	v := m.is_shared
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShared returns the old "is_shared" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldIsShared(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShared is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShared requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShared: %w", err)
	}
	return oldValue.IsShared, nil
}

// ClearIsShared clears the value of the "is_shared" field.
func (m *PrinterMutation) ClearIsShared() {
	m.is_shared = nil
	m.clearedFields[printer.FieldIsShared] = struct{}{}
}

// IsSharedCleared returns if the "is_shared" field was cleared in this mutation.
func (m *PrinterMutation) IsSharedCleared() bool {
	_, ok := m.clearedFields[printer.FieldIsShared]
	return ok
}

// ResetIsShared resets all changes to the "is_shared" field.
func (m *PrinterMutation) ResetIsShared() {
	m.is_shared = nil
	delete(m.clearedFields, printer.FieldIsShared)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *PrinterMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *PrinterMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *PrinterMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PrinterMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PrinterMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PrinterMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the PrinterMutation builder.
func (m *PrinterMutation) Where(ps ...predicate.Printer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrinterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrinterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Printer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrinterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrinterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Printer).
func (m *PrinterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrinterMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, printer.FieldName)
	}
	if m.port != nil {
		fields = append(fields, printer.FieldPort)
	}
	if m.is_default != nil {
		fields = append(fields, printer.FieldIsDefault)
	}
	if m.is_network != nil {
		fields = append(fields, printer.FieldIsNetwork)
	}
	if m.is_shared != nil {
		fields = append(fields, printer.FieldIsShared)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrinterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case printer.FieldName:
		return m.Name()
	case printer.FieldPort:
		return m.Port()
	case printer.FieldIsDefault:
		return m.IsDefault()
	case printer.FieldIsNetwork:
		return m.IsNetwork()
	case printer.FieldIsShared:
		return m.IsShared()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrinterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case printer.FieldName:
		return m.OldName(ctx)
	case printer.FieldPort:
		return m.OldPort(ctx)
	case printer.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case printer.FieldIsNetwork:
		return m.OldIsNetwork(ctx)
	case printer.FieldIsShared:
		return m.OldIsShared(ctx)
	}
	return nil, fmt.Errorf("unknown Printer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrinterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case printer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case printer.FieldPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case printer.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case printer.FieldIsNetwork:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNetwork(v)
		return nil
	case printer.FieldIsShared:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShared(v)
		return nil
	}
	return fmt.Errorf("unknown Printer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrinterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrinterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrinterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Printer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrinterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(printer.FieldPort) {
		fields = append(fields, printer.FieldPort)
	}
	if m.FieldCleared(printer.FieldIsDefault) {
		fields = append(fields, printer.FieldIsDefault)
	}
	if m.FieldCleared(printer.FieldIsNetwork) {
		fields = append(fields, printer.FieldIsNetwork)
	}
	if m.FieldCleared(printer.FieldIsShared) {
		fields = append(fields, printer.FieldIsShared)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrinterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrinterMutation) ClearField(name string) error {
	switch name {
	case printer.FieldPort:
		m.ClearPort()
		return nil
	case printer.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	case printer.FieldIsNetwork:
		m.ClearIsNetwork()
		return nil
	case printer.FieldIsShared:
		m.ClearIsShared()
		return nil
	}
	return fmt.Errorf("unknown Printer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrinterMutation) ResetField(name string) error {
	switch name {
	case printer.FieldName:
		m.ResetName()
		return nil
	case printer.FieldPort:
		m.ResetPort()
		return nil
	case printer.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case printer.FieldIsNetwork:
		m.ResetIsNetwork()
		return nil
	case printer.FieldIsShared:
		m.ResetIsShared()
		return nil
	}
	return fmt.Errorf("unknown Printer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrinterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, printer.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrinterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case printer.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrinterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrinterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrinterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, printer.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrinterMutation) EdgeCleared(name string) bool {
	switch name {
	case printer.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrinterMutation) ClearEdge(name string) error {
	switch name {
	case printer.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Printer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrinterMutation) ResetEdge(name string) error {
	switch name {
	case printer.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Printer edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	apply_to_all  *bool
	_type         *profile.Type
	clearedFields map[string]struct{}
	tags          map[int]struct{}
	removedtags   map[int]struct{}
	clearedtags   bool
	tasks         map[int]struct{}
	removedtasks  map[int]struct{}
	clearedtasks  bool
	issues        map[int]struct{}
	removedissues map[int]struct{}
	clearedissues bool
	site          *int
	clearedsite   bool
	done          bool
	oldValue      func(context.Context) (*Profile, error)
	predicates    []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id int) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProfileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProfileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProfileMutation) ResetName() {
	m.name = nil
}

// SetApplyToAll sets the "apply_to_all" field.
func (m *ProfileMutation) SetApplyToAll(b bool) {
	m.apply_to_all = &b
}

// ApplyToAll returns the value of the "apply_to_all" field in the mutation.
func (m *ProfileMutation) ApplyToAll() (r bool, exists bool) {
	v := m.apply_to_all
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyToAll returns the old "apply_to_all" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldApplyToAll(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplyToAll is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplyToAll requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyToAll: %w", err)
	}
	return oldValue.ApplyToAll, nil
}

// ResetApplyToAll resets all changes to the "apply_to_all" field.
func (m *ProfileMutation) ResetApplyToAll() {
	m.apply_to_all = nil
}

// SetType sets the "type" field.
func (m *ProfileMutation) SetType(pr profile.Type) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProfileMutation) GetType() (r profile.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldType(ctx context.Context) (v profile.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ProfileMutation) ClearType() {
	m._type = nil
	m.clearedFields[profile.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ProfileMutation) TypeCleared() bool {
	_, ok := m.clearedFields[profile.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ProfileMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, profile.FieldType)
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ProfileMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ProfileMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ProfileMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ProfileMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ProfileMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ProfileMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ProfileMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ProfileMutation) AddTaskIDs(ids ...int) {
	if m.tasks == nil {
		m.tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ProfileMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ProfileMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ProfileMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ProfileMutation) RemovedTasksIDs() (ids []int) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ProfileMutation) TasksIDs() (ids []int) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ProfileMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddIssueIDs adds the "issues" edge to the ProfileIssue entity by ids.
func (m *ProfileMutation) AddIssueIDs(ids ...int) {
	if m.issues == nil {
		m.issues = make(map[int]struct{})
	}
	for i := range ids {
		m.issues[ids[i]] = struct{}{}
	}
}

// ClearIssues clears the "issues" edge to the ProfileIssue entity.
func (m *ProfileMutation) ClearIssues() {
	m.clearedissues = true
}

// IssuesCleared reports if the "issues" edge to the ProfileIssue entity was cleared.
func (m *ProfileMutation) IssuesCleared() bool {
	return m.clearedissues
}

// RemoveIssueIDs removes the "issues" edge to the ProfileIssue entity by IDs.
func (m *ProfileMutation) RemoveIssueIDs(ids ...int) {
	if m.removedissues == nil {
		m.removedissues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.issues, ids[i])
		m.removedissues[ids[i]] = struct{}{}
	}
}

// RemovedIssues returns the removed IDs of the "issues" edge to the ProfileIssue entity.
func (m *ProfileMutation) RemovedIssuesIDs() (ids []int) {
	for id := range m.removedissues {
		ids = append(ids, id)
	}
	return
}

// IssuesIDs returns the "issues" edge IDs in the mutation.
func (m *ProfileMutation) IssuesIDs() (ids []int) {
	for id := range m.issues {
		ids = append(ids, id)
	}
	return
}

// ResetIssues resets all changes to the "issues" edge.
func (m *ProfileMutation) ResetIssues() {
	m.issues = nil
	m.clearedissues = false
	m.removedissues = nil
}

// SetSiteID sets the "site" edge to the Site entity by id.
func (m *ProfileMutation) SetSiteID(id int) {
	m.site = &id
}

// ClearSite clears the "site" edge to the Site entity.
func (m *ProfileMutation) ClearSite() {
	m.clearedsite = true
}

// SiteCleared reports if the "site" edge to the Site entity was cleared.
func (m *ProfileMutation) SiteCleared() bool {
	return m.clearedsite
}

// SiteID returns the "site" edge ID in the mutation.
func (m *ProfileMutation) SiteID() (id int, exists bool) {
	if m.site != nil {
		return *m.site, true
	}
	return
}

// SiteIDs returns the "site" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SiteID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) SiteIDs() (ids []int) {
	if id := m.site; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSite resets all changes to the "site" edge.
func (m *ProfileMutation) ResetSite() {
	m.site = nil
	m.clearedsite = false
}

// Where appends a list predicates to the ProfileMutation builder.
func (m *ProfileMutation) Where(ps ...predicate.Profile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Profile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, profile.FieldName)
	}
	if m.apply_to_all != nil {
		fields = append(fields, profile.FieldApplyToAll)
	}
	if m._type != nil {
		fields = append(fields, profile.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldName:
		return m.Name()
	case profile.FieldApplyToAll:
		return m.ApplyToAll()
	case profile.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldName:
		return m.OldName(ctx)
	case profile.FieldApplyToAll:
		return m.OldApplyToAll(ctx)
	case profile.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case profile.FieldApplyToAll:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyToAll(v)
		return nil
	case profile.FieldType:
		v, ok := value.(profile.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(profile.FieldType) {
		fields = append(fields, profile.FieldType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	switch name {
	case profile.FieldType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldName:
		m.ResetName()
		return nil
	case profile.FieldApplyToAll:
		m.ResetApplyToAll()
		return nil
	case profile.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tags != nil {
		edges = append(edges, profile.EdgeTags)
	}
	if m.tasks != nil {
		edges = append(edges, profile.EdgeTasks)
	}
	if m.issues != nil {
		edges = append(edges, profile.EdgeIssues)
	}
	if m.site != nil {
		edges = append(edges, profile.EdgeSite)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.issues))
		for id := range m.issues {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeSite:
		if id := m.site; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtags != nil {
		edges = append(edges, profile.EdgeTags)
	}
	if m.removedtasks != nil {
		edges = append(edges, profile.EdgeTasks)
	}
	if m.removedissues != nil {
		edges = append(edges, profile.EdgeIssues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeIssues:
		ids := make([]ent.Value, 0, len(m.removedissues))
		for id := range m.removedissues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtags {
		edges = append(edges, profile.EdgeTags)
	}
	if m.clearedtasks {
		edges = append(edges, profile.EdgeTasks)
	}
	if m.clearedissues {
		edges = append(edges, profile.EdgeIssues)
	}
	if m.clearedsite {
		edges = append(edges, profile.EdgeSite)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeTags:
		return m.clearedtags
	case profile.EdgeTasks:
		return m.clearedtasks
	case profile.EdgeIssues:
		return m.clearedissues
	case profile.EdgeSite:
		return m.clearedsite
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	case profile.EdgeSite:
		m.ClearSite()
		return nil
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeTags:
		m.ResetTags()
		return nil
	case profile.EdgeTasks:
		m.ResetTasks()
		return nil
	case profile.EdgeIssues:
		m.ResetIssues()
		return nil
	case profile.EdgeSite:
		m.ResetSite()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// ProfileIssueMutation represents an operation that mutates the ProfileIssue nodes in the graph.
type ProfileIssueMutation struct {
	config
	op             Op
	typ            string
	id             *int
	error          *string
	when           *time.Time
	clearedFields  map[string]struct{}
	profile        *int
	clearedprofile bool
	agents         *string
	clearedagents  bool
	done           bool
	oldValue       func(context.Context) (*ProfileIssue, error)
	predicates     []predicate.ProfileIssue
}

var _ ent.Mutation = (*ProfileIssueMutation)(nil)

// profileissueOption allows management of the mutation configuration using functional options.
type profileissueOption func(*ProfileIssueMutation)

// newProfileIssueMutation creates new mutation for the ProfileIssue entity.
func newProfileIssueMutation(c config, op Op, opts ...profileissueOption) *ProfileIssueMutation {
	m := &ProfileIssueMutation{
		config:        c,
		op:            op,
		typ:           TypeProfileIssue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileIssueID sets the ID field of the mutation.
func withProfileIssueID(id int) profileissueOption {
	return func(m *ProfileIssueMutation) {
		var (
			err   error
			once  sync.Once
			value *ProfileIssue
		)
		m.oldValue = func(ctx context.Context) (*ProfileIssue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProfileIssue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfileIssue sets the old ProfileIssue of the mutation.
func withProfileIssue(node *ProfileIssue) profileissueOption {
	return func(m *ProfileIssueMutation) {
		m.oldValue = func(context.Context) (*ProfileIssue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileIssueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileIssueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileIssueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileIssueMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProfileIssue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetError sets the "error" field.
func (m *ProfileIssueMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *ProfileIssueMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the ProfileIssue entity.
// If the ProfileIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileIssueMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *ProfileIssueMutation) ClearError() {
	m.error = nil
	m.clearedFields[profileissue.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *ProfileIssueMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[profileissue.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *ProfileIssueMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, profileissue.FieldError)
}

// SetWhen sets the "when" field.
func (m *ProfileIssueMutation) SetWhen(t time.Time) {
	m.when = &t
}

// When returns the value of the "when" field in the mutation.
func (m *ProfileIssueMutation) When() (r time.Time, exists bool) {
	v := m.when
	if v == nil {
		return
	}
	return *v, true
}

// OldWhen returns the old "when" field's value of the ProfileIssue entity.
// If the ProfileIssue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileIssueMutation) OldWhen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhen: %w", err)
	}
	return oldValue.When, nil
}

// ClearWhen clears the value of the "when" field.
func (m *ProfileIssueMutation) ClearWhen() {
	m.when = nil
	m.clearedFields[profileissue.FieldWhen] = struct{}{}
}

// WhenCleared returns if the "when" field was cleared in this mutation.
func (m *ProfileIssueMutation) WhenCleared() bool {
	_, ok := m.clearedFields[profileissue.FieldWhen]
	return ok
}

// ResetWhen resets all changes to the "when" field.
func (m *ProfileIssueMutation) ResetWhen() {
	m.when = nil
	delete(m.clearedFields, profileissue.FieldWhen)
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *ProfileIssueMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *ProfileIssueMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *ProfileIssueMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *ProfileIssueMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *ProfileIssueMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *ProfileIssueMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// SetAgentsID sets the "agents" edge to the Agent entity by id.
func (m *ProfileIssueMutation) SetAgentsID(id string) {
	m.agents = &id
}

// ClearAgents clears the "agents" edge to the Agent entity.
func (m *ProfileIssueMutation) ClearAgents() {
	m.clearedagents = true
}

// AgentsCleared reports if the "agents" edge to the Agent entity was cleared.
func (m *ProfileIssueMutation) AgentsCleared() bool {
	return m.clearedagents
}

// AgentsID returns the "agents" edge ID in the mutation.
func (m *ProfileIssueMutation) AgentsID() (id string, exists bool) {
	if m.agents != nil {
		return *m.agents, true
	}
	return
}

// AgentsIDs returns the "agents" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentsID instead. It exists only for internal usage by the builders.
func (m *ProfileIssueMutation) AgentsIDs() (ids []string) {
	if id := m.agents; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgents resets all changes to the "agents" edge.
func (m *ProfileIssueMutation) ResetAgents() {
	m.agents = nil
	m.clearedagents = false
}

// Where appends a list predicates to the ProfileIssueMutation builder.
func (m *ProfileIssueMutation) Where(ps ...predicate.ProfileIssue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileIssueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileIssueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProfileIssue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileIssueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileIssueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProfileIssue).
func (m *ProfileIssueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileIssueMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.error != nil {
		fields = append(fields, profileissue.FieldError)
	}
	if m.when != nil {
		fields = append(fields, profileissue.FieldWhen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileIssueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profileissue.FieldError:
		return m.Error()
	case profileissue.FieldWhen:
		return m.When()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileIssueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profileissue.FieldError:
		return m.OldError(ctx)
	case profileissue.FieldWhen:
		return m.OldWhen(ctx)
	}
	return nil, fmt.Errorf("unknown ProfileIssue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileIssueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profileissue.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case profileissue.FieldWhen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhen(v)
		return nil
	}
	return fmt.Errorf("unknown ProfileIssue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileIssueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileIssueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileIssueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProfileIssue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileIssueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(profileissue.FieldError) {
		fields = append(fields, profileissue.FieldError)
	}
	if m.FieldCleared(profileissue.FieldWhen) {
		fields = append(fields, profileissue.FieldWhen)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileIssueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileIssueMutation) ClearField(name string) error {
	switch name {
	case profileissue.FieldError:
		m.ClearError()
		return nil
	case profileissue.FieldWhen:
		m.ClearWhen()
		return nil
	}
	return fmt.Errorf("unknown ProfileIssue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileIssueMutation) ResetField(name string) error {
	switch name {
	case profileissue.FieldError:
		m.ResetError()
		return nil
	case profileissue.FieldWhen:
		m.ResetWhen()
		return nil
	}
	return fmt.Errorf("unknown ProfileIssue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileIssueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.profile != nil {
		edges = append(edges, profileissue.EdgeProfile)
	}
	if m.agents != nil {
		edges = append(edges, profileissue.EdgeAgents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileIssueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profileissue.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case profileissue.EdgeAgents:
		if id := m.agents; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileIssueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileIssueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileIssueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprofile {
		edges = append(edges, profileissue.EdgeProfile)
	}
	if m.clearedagents {
		edges = append(edges, profileissue.EdgeAgents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileIssueMutation) EdgeCleared(name string) bool {
	switch name {
	case profileissue.EdgeProfile:
		return m.clearedprofile
	case profileissue.EdgeAgents:
		return m.clearedagents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileIssueMutation) ClearEdge(name string) error {
	switch name {
	case profileissue.EdgeProfile:
		m.ClearProfile()
		return nil
	case profileissue.EdgeAgents:
		m.ClearAgents()
		return nil
	}
	return fmt.Errorf("unknown ProfileIssue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileIssueMutation) ResetEdge(name string) error {
	switch name {
	case profileissue.EdgeProfile:
		m.ResetProfile()
		return nil
	case profileissue.EdgeAgents:
		m.ResetAgents()
		return nil
	}
	return fmt.Errorf("unknown ProfileIssue edge %s", name)
}

// RecoveryCodeMutation represents an operation that mutates the RecoveryCode nodes in the graph.
type RecoveryCodeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	code          *string
	used          *bool
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*RecoveryCode, error)
	predicates    []predicate.RecoveryCode
}

var _ ent.Mutation = (*RecoveryCodeMutation)(nil)

// recoverycodeOption allows management of the mutation configuration using functional options.
type recoverycodeOption func(*RecoveryCodeMutation)

// newRecoveryCodeMutation creates new mutation for the RecoveryCode entity.
func newRecoveryCodeMutation(c config, op Op, opts ...recoverycodeOption) *RecoveryCodeMutation {
	m := &RecoveryCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeRecoveryCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecoveryCodeID sets the ID field of the mutation.
func withRecoveryCodeID(id int) recoverycodeOption {
	return func(m *RecoveryCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *RecoveryCode
		)
		m.oldValue = func(ctx context.Context) (*RecoveryCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecoveryCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecoveryCode sets the old RecoveryCode of the mutation.
func withRecoveryCode(node *RecoveryCode) recoverycodeOption {
	return func(m *RecoveryCodeMutation) {
		m.oldValue = func(context.Context) (*RecoveryCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecoveryCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecoveryCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecoveryCodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecoveryCodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecoveryCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *RecoveryCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RecoveryCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the RecoveryCode entity.
// If the RecoveryCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecoveryCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RecoveryCodeMutation) ResetCode() {
	m.code = nil
}

// SetUsed sets the "used" field.
func (m *RecoveryCodeMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *RecoveryCodeMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the RecoveryCode entity.
// If the RecoveryCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecoveryCodeMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ResetUsed resets all changes to the "used" field.
func (m *RecoveryCodeMutation) ResetUsed() {
	m.used = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *RecoveryCodeMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *RecoveryCodeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RecoveryCodeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *RecoveryCodeMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RecoveryCodeMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RecoveryCodeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the RecoveryCodeMutation builder.
func (m *RecoveryCodeMutation) Where(ps ...predicate.RecoveryCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecoveryCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecoveryCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecoveryCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecoveryCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecoveryCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecoveryCode).
func (m *RecoveryCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecoveryCodeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.code != nil {
		fields = append(fields, recoverycode.FieldCode)
	}
	if m.used != nil {
		fields = append(fields, recoverycode.FieldUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecoveryCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recoverycode.FieldCode:
		return m.Code()
	case recoverycode.FieldUsed:
		return m.Used()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecoveryCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recoverycode.FieldCode:
		return m.OldCode(ctx)
	case recoverycode.FieldUsed:
		return m.OldUsed(ctx)
	}
	return nil, fmt.Errorf("unknown RecoveryCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecoveryCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recoverycode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case recoverycode.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	}
	return fmt.Errorf("unknown RecoveryCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecoveryCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecoveryCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecoveryCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RecoveryCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecoveryCodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecoveryCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecoveryCodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RecoveryCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecoveryCodeMutation) ResetField(name string) error {
	switch name {
	case recoverycode.FieldCode:
		m.ResetCode()
		return nil
	case recoverycode.FieldUsed:
		m.ResetUsed()
		return nil
	}
	return fmt.Errorf("unknown RecoveryCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecoveryCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, recoverycode.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecoveryCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recoverycode.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecoveryCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecoveryCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecoveryCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, recoverycode.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecoveryCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case recoverycode.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecoveryCodeMutation) ClearEdge(name string) error {
	switch name {
	case recoverycode.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown RecoveryCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecoveryCodeMutation) ResetEdge(name string) error {
	switch name {
	case recoverycode.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown RecoveryCode edge %s", name)
}

// ReleaseMutation represents an operation that mutates the Release nodes in the graph.
type ReleaseMutation struct {
	config
	op            Op
	typ           string
	id            *int
	release_type  *release.ReleaseType
	version       *string
	channel       *string
	summary       *string
	release_notes *string
	file_url      *string
	checksum      *string
	is_critical   *bool
	release_date  *time.Time
	os            *string
	arch          *string
	clearedFields map[string]struct{}
	agents        map[string]struct{}
	removedagents map[string]struct{}
	clearedagents bool
	done          bool
	oldValue      func(context.Context) (*Release, error)
	predicates    []predicate.Release
}

var _ ent.Mutation = (*ReleaseMutation)(nil)

// releaseOption allows management of the mutation configuration using functional options.
type releaseOption func(*ReleaseMutation)

// newReleaseMutation creates new mutation for the Release entity.
func newReleaseMutation(c config, op Op, opts ...releaseOption) *ReleaseMutation {
	m := &ReleaseMutation{
		config:        c,
		op:            op,
		typ:           TypeRelease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseID sets the ID field of the mutation.
func withReleaseID(id int) releaseOption {
	return func(m *ReleaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Release
		)
		m.oldValue = func(ctx context.Context) (*Release, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Release.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRelease sets the old Release of the mutation.
func withRelease(node *Release) releaseOption {
	return func(m *ReleaseMutation) {
		m.oldValue = func(context.Context) (*Release, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReleaseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Release.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReleaseType sets the "release_type" field.
func (m *ReleaseMutation) SetReleaseType(rt release.ReleaseType) {
	m.release_type = &rt
}

// ReleaseType returns the value of the "release_type" field in the mutation.
func (m *ReleaseMutation) ReleaseType() (r release.ReleaseType, exists bool) {
	v := m.release_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseType returns the old "release_type" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldReleaseType(ctx context.Context) (v release.ReleaseType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseType: %w", err)
	}
	return oldValue.ReleaseType, nil
}

// ClearReleaseType clears the value of the "release_type" field.
func (m *ReleaseMutation) ClearReleaseType() {
	m.release_type = nil
	m.clearedFields[release.FieldReleaseType] = struct{}{}
}

// ReleaseTypeCleared returns if the "release_type" field was cleared in this mutation.
func (m *ReleaseMutation) ReleaseTypeCleared() bool {
	_, ok := m.clearedFields[release.FieldReleaseType]
	return ok
}

// ResetReleaseType resets all changes to the "release_type" field.
func (m *ReleaseMutation) ResetReleaseType() {
	m.release_type = nil
	delete(m.clearedFields, release.FieldReleaseType)
}

// SetVersion sets the "version" field.
func (m *ReleaseMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ReleaseMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ReleaseMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[release.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ReleaseMutation) VersionCleared() bool {
	_, ok := m.clearedFields[release.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ReleaseMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, release.FieldVersion)
}

// SetChannel sets the "channel" field.
func (m *ReleaseMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *ReleaseMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ClearChannel clears the value of the "channel" field.
func (m *ReleaseMutation) ClearChannel() {
	m.channel = nil
	m.clearedFields[release.FieldChannel] = struct{}{}
}

// ChannelCleared returns if the "channel" field was cleared in this mutation.
func (m *ReleaseMutation) ChannelCleared() bool {
	_, ok := m.clearedFields[release.FieldChannel]
	return ok
}

// ResetChannel resets all changes to the "channel" field.
func (m *ReleaseMutation) ResetChannel() {
	m.channel = nil
	delete(m.clearedFields, release.FieldChannel)
}

// SetSummary sets the "summary" field.
func (m *ReleaseMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *ReleaseMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *ReleaseMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[release.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *ReleaseMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[release.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *ReleaseMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, release.FieldSummary)
}

// SetReleaseNotes sets the "release_notes" field.
func (m *ReleaseMutation) SetReleaseNotes(s string) {
	m.release_notes = &s
}

// ReleaseNotes returns the value of the "release_notes" field in the mutation.
func (m *ReleaseMutation) ReleaseNotes() (r string, exists bool) {
	v := m.release_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseNotes returns the old "release_notes" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldReleaseNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseNotes: %w", err)
	}
	return oldValue.ReleaseNotes, nil
}

// ClearReleaseNotes clears the value of the "release_notes" field.
func (m *ReleaseMutation) ClearReleaseNotes() {
	m.release_notes = nil
	m.clearedFields[release.FieldReleaseNotes] = struct{}{}
}

// ReleaseNotesCleared returns if the "release_notes" field was cleared in this mutation.
func (m *ReleaseMutation) ReleaseNotesCleared() bool {
	_, ok := m.clearedFields[release.FieldReleaseNotes]
	return ok
}

// ResetReleaseNotes resets all changes to the "release_notes" field.
func (m *ReleaseMutation) ResetReleaseNotes() {
	m.release_notes = nil
	delete(m.clearedFields, release.FieldReleaseNotes)
}

// SetFileURL sets the "file_url" field.
func (m *ReleaseMutation) SetFileURL(s string) {
	m.file_url = &s
}

// FileURL returns the value of the "file_url" field in the mutation.
func (m *ReleaseMutation) FileURL() (r string, exists bool) {
	v := m.file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFileURL returns the old "file_url" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileURL: %w", err)
	}
	return oldValue.FileURL, nil
}

// ClearFileURL clears the value of the "file_url" field.
func (m *ReleaseMutation) ClearFileURL() {
	m.file_url = nil
	m.clearedFields[release.FieldFileURL] = struct{}{}
}

// FileURLCleared returns if the "file_url" field was cleared in this mutation.
func (m *ReleaseMutation) FileURLCleared() bool {
	_, ok := m.clearedFields[release.FieldFileURL]
	return ok
}

// ResetFileURL resets all changes to the "file_url" field.
func (m *ReleaseMutation) ResetFileURL() {
	m.file_url = nil
	delete(m.clearedFields, release.FieldFileURL)
}

// SetChecksum sets the "checksum" field.
func (m *ReleaseMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *ReleaseMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ClearChecksum clears the value of the "checksum" field.
func (m *ReleaseMutation) ClearChecksum() {
	m.checksum = nil
	m.clearedFields[release.FieldChecksum] = struct{}{}
}

// ChecksumCleared returns if the "checksum" field was cleared in this mutation.
func (m *ReleaseMutation) ChecksumCleared() bool {
	_, ok := m.clearedFields[release.FieldChecksum]
	return ok
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *ReleaseMutation) ResetChecksum() {
	m.checksum = nil
	delete(m.clearedFields, release.FieldChecksum)
}

// SetIsCritical sets the "is_critical" field.
func (m *ReleaseMutation) SetIsCritical(b bool) {
	m.is_critical = &b
}

// IsCritical returns the value of the "is_critical" field in the mutation.
func (m *ReleaseMutation) IsCritical() (r bool, exists bool) {
	v := m.is_critical
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCritical returns the old "is_critical" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldIsCritical(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCritical is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCritical requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCritical: %w", err)
	}
	return oldValue.IsCritical, nil
}

// ClearIsCritical clears the value of the "is_critical" field.
func (m *ReleaseMutation) ClearIsCritical() {
	m.is_critical = nil
	m.clearedFields[release.FieldIsCritical] = struct{}{}
}

// IsCriticalCleared returns if the "is_critical" field was cleared in this mutation.
func (m *ReleaseMutation) IsCriticalCleared() bool {
	_, ok := m.clearedFields[release.FieldIsCritical]
	return ok
}

// ResetIsCritical resets all changes to the "is_critical" field.
func (m *ReleaseMutation) ResetIsCritical() {
	m.is_critical = nil
	delete(m.clearedFields, release.FieldIsCritical)
}

// SetReleaseDate sets the "release_date" field.
func (m *ReleaseMutation) SetReleaseDate(t time.Time) {
	m.release_date = &t
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *ReleaseMutation) ReleaseDate() (r time.Time, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldReleaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ClearReleaseDate clears the value of the "release_date" field.
func (m *ReleaseMutation) ClearReleaseDate() {
	m.release_date = nil
	m.clearedFields[release.FieldReleaseDate] = struct{}{}
}

// ReleaseDateCleared returns if the "release_date" field was cleared in this mutation.
func (m *ReleaseMutation) ReleaseDateCleared() bool {
	_, ok := m.clearedFields[release.FieldReleaseDate]
	return ok
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *ReleaseMutation) ResetReleaseDate() {
	m.release_date = nil
	delete(m.clearedFields, release.FieldReleaseDate)
}

// SetOs sets the "os" field.
func (m *ReleaseMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *ReleaseMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ClearOs clears the value of the "os" field.
func (m *ReleaseMutation) ClearOs() {
	m.os = nil
	m.clearedFields[release.FieldOs] = struct{}{}
}

// OsCleared returns if the "os" field was cleared in this mutation.
func (m *ReleaseMutation) OsCleared() bool {
	_, ok := m.clearedFields[release.FieldOs]
	return ok
}

// ResetOs resets all changes to the "os" field.
func (m *ReleaseMutation) ResetOs() {
	m.os = nil
	delete(m.clearedFields, release.FieldOs)
}

// SetArch sets the "arch" field.
func (m *ReleaseMutation) SetArch(s string) {
	m.arch = &s
}

// Arch returns the value of the "arch" field in the mutation.
func (m *ReleaseMutation) Arch() (r string, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ClearArch clears the value of the "arch" field.
func (m *ReleaseMutation) ClearArch() {
	m.arch = nil
	m.clearedFields[release.FieldArch] = struct{}{}
}

// ArchCleared returns if the "arch" field was cleared in this mutation.
func (m *ReleaseMutation) ArchCleared() bool {
	_, ok := m.clearedFields[release.FieldArch]
	return ok
}

// ResetArch resets all changes to the "arch" field.
func (m *ReleaseMutation) ResetArch() {
	m.arch = nil
	delete(m.clearedFields, release.FieldArch)
}

// AddAgentIDs adds the "agents" edge to the Agent entity by ids.
func (m *ReleaseMutation) AddAgentIDs(ids ...string) {
	if m.agents == nil {
		m.agents = make(map[string]struct{})
	}
	for i := range ids {
		m.agents[ids[i]] = struct{}{}
	}
}

// ClearAgents clears the "agents" edge to the Agent entity.
func (m *ReleaseMutation) ClearAgents() {
	m.clearedagents = true
}

// AgentsCleared reports if the "agents" edge to the Agent entity was cleared.
func (m *ReleaseMutation) AgentsCleared() bool {
	return m.clearedagents
}

// RemoveAgentIDs removes the "agents" edge to the Agent entity by IDs.
func (m *ReleaseMutation) RemoveAgentIDs(ids ...string) {
	if m.removedagents == nil {
		m.removedagents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.agents, ids[i])
		m.removedagents[ids[i]] = struct{}{}
	}
}

// RemovedAgents returns the removed IDs of the "agents" edge to the Agent entity.
func (m *ReleaseMutation) RemovedAgentsIDs() (ids []string) {
	for id := range m.removedagents {
		ids = append(ids, id)
	}
	return
}

// AgentsIDs returns the "agents" edge IDs in the mutation.
func (m *ReleaseMutation) AgentsIDs() (ids []string) {
	for id := range m.agents {
		ids = append(ids, id)
	}
	return
}

// ResetAgents resets all changes to the "agents" edge.
func (m *ReleaseMutation) ResetAgents() {
	m.agents = nil
	m.clearedagents = false
	m.removedagents = nil
}

// Where appends a list predicates to the ReleaseMutation builder.
func (m *ReleaseMutation) Where(ps ...predicate.Release) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReleaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReleaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Release, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReleaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReleaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Release).
func (m *ReleaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.release_type != nil {
		fields = append(fields, release.FieldReleaseType)
	}
	if m.version != nil {
		fields = append(fields, release.FieldVersion)
	}
	if m.channel != nil {
		fields = append(fields, release.FieldChannel)
	}
	if m.summary != nil {
		fields = append(fields, release.FieldSummary)
	}
	if m.release_notes != nil {
		fields = append(fields, release.FieldReleaseNotes)
	}
	if m.file_url != nil {
		fields = append(fields, release.FieldFileURL)
	}
	if m.checksum != nil {
		fields = append(fields, release.FieldChecksum)
	}
	if m.is_critical != nil {
		fields = append(fields, release.FieldIsCritical)
	}
	if m.release_date != nil {
		fields = append(fields, release.FieldReleaseDate)
	}
	if m.os != nil {
		fields = append(fields, release.FieldOs)
	}
	if m.arch != nil {
		fields = append(fields, release.FieldArch)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case release.FieldReleaseType:
		return m.ReleaseType()
	case release.FieldVersion:
		return m.Version()
	case release.FieldChannel:
		return m.Channel()
	case release.FieldSummary:
		return m.Summary()
	case release.FieldReleaseNotes:
		return m.ReleaseNotes()
	case release.FieldFileURL:
		return m.FileURL()
	case release.FieldChecksum:
		return m.Checksum()
	case release.FieldIsCritical:
		return m.IsCritical()
	case release.FieldReleaseDate:
		return m.ReleaseDate()
	case release.FieldOs:
		return m.Os()
	case release.FieldArch:
		return m.Arch()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case release.FieldReleaseType:
		return m.OldReleaseType(ctx)
	case release.FieldVersion:
		return m.OldVersion(ctx)
	case release.FieldChannel:
		return m.OldChannel(ctx)
	case release.FieldSummary:
		return m.OldSummary(ctx)
	case release.FieldReleaseNotes:
		return m.OldReleaseNotes(ctx)
	case release.FieldFileURL:
		return m.OldFileURL(ctx)
	case release.FieldChecksum:
		return m.OldChecksum(ctx)
	case release.FieldIsCritical:
		return m.OldIsCritical(ctx)
	case release.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case release.FieldOs:
		return m.OldOs(ctx)
	case release.FieldArch:
		return m.OldArch(ctx)
	}
	return nil, fmt.Errorf("unknown Release field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case release.FieldReleaseType:
		v, ok := value.(release.ReleaseType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseType(v)
		return nil
	case release.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case release.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case release.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case release.FieldReleaseNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseNotes(v)
		return nil
	case release.FieldFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileURL(v)
		return nil
	case release.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case release.FieldIsCritical:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCritical(v)
		return nil
	case release.FieldReleaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case release.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case release.FieldArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Release numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(release.FieldReleaseType) {
		fields = append(fields, release.FieldReleaseType)
	}
	if m.FieldCleared(release.FieldVersion) {
		fields = append(fields, release.FieldVersion)
	}
	if m.FieldCleared(release.FieldChannel) {
		fields = append(fields, release.FieldChannel)
	}
	if m.FieldCleared(release.FieldSummary) {
		fields = append(fields, release.FieldSummary)
	}
	if m.FieldCleared(release.FieldReleaseNotes) {
		fields = append(fields, release.FieldReleaseNotes)
	}
	if m.FieldCleared(release.FieldFileURL) {
		fields = append(fields, release.FieldFileURL)
	}
	if m.FieldCleared(release.FieldChecksum) {
		fields = append(fields, release.FieldChecksum)
	}
	if m.FieldCleared(release.FieldIsCritical) {
		fields = append(fields, release.FieldIsCritical)
	}
	if m.FieldCleared(release.FieldReleaseDate) {
		fields = append(fields, release.FieldReleaseDate)
	}
	if m.FieldCleared(release.FieldOs) {
		fields = append(fields, release.FieldOs)
	}
	if m.FieldCleared(release.FieldArch) {
		fields = append(fields, release.FieldArch)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseMutation) ClearField(name string) error {
	switch name {
	case release.FieldReleaseType:
		m.ClearReleaseType()
		return nil
	case release.FieldVersion:
		m.ClearVersion()
		return nil
	case release.FieldChannel:
		m.ClearChannel()
		return nil
	case release.FieldSummary:
		m.ClearSummary()
		return nil
	case release.FieldReleaseNotes:
		m.ClearReleaseNotes()
		return nil
	case release.FieldFileURL:
		m.ClearFileURL()
		return nil
	case release.FieldChecksum:
		m.ClearChecksum()
		return nil
	case release.FieldIsCritical:
		m.ClearIsCritical()
		return nil
	case release.FieldReleaseDate:
		m.ClearReleaseDate()
		return nil
	case release.FieldOs:
		m.ClearOs()
		return nil
	case release.FieldArch:
		m.ClearArch()
		return nil
	}
	return fmt.Errorf("unknown Release nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseMutation) ResetField(name string) error {
	switch name {
	case release.FieldReleaseType:
		m.ResetReleaseType()
		return nil
	case release.FieldVersion:
		m.ResetVersion()
		return nil
	case release.FieldChannel:
		m.ResetChannel()
		return nil
	case release.FieldSummary:
		m.ResetSummary()
		return nil
	case release.FieldReleaseNotes:
		m.ResetReleaseNotes()
		return nil
	case release.FieldFileURL:
		m.ResetFileURL()
		return nil
	case release.FieldChecksum:
		m.ResetChecksum()
		return nil
	case release.FieldIsCritical:
		m.ResetIsCritical()
		return nil
	case release.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case release.FieldOs:
		m.ResetOs()
		return nil
	case release.FieldArch:
		m.ResetArch()
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.agents != nil {
		edges = append(edges, release.EdgeAgents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.agents))
		for id := range m.agents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedagents != nil {
		edges = append(edges, release.EdgeAgents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.removedagents))
		for id := range m.removedagents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedagents {
		edges = append(edges, release.EdgeAgents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseMutation) EdgeCleared(name string) bool {
	switch name {
	case release.EdgeAgents:
		return m.clearedagents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Release unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseMutation) ResetEdge(name string) error {
	switch name {
	case release.EdgeAgents:
		m.ResetAgents()
		return nil
	}
	return fmt.Errorf("unknown Release edge %s", name)
}

// RevocationMutation represents an operation that mutates the Revocation nodes in the graph.
type RevocationMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	reason        *int
	addreason     *int
	info          *string
	expiry        *time.Time
	revoked       *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Revocation, error)
	predicates    []predicate.Revocation
}

var _ ent.Mutation = (*RevocationMutation)(nil)

// revocationOption allows management of the mutation configuration using functional options.
type revocationOption func(*RevocationMutation)

// newRevocationMutation creates new mutation for the Revocation entity.
func newRevocationMutation(c config, op Op, opts ...revocationOption) *RevocationMutation {
	m := &RevocationMutation{
		config:        c,
		op:            op,
		typ:           TypeRevocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRevocationID sets the ID field of the mutation.
func withRevocationID(id int64) revocationOption {
	return func(m *RevocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Revocation
		)
		m.oldValue = func(ctx context.Context) (*Revocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Revocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRevocation sets the old Revocation of the mutation.
func withRevocation(node *Revocation) revocationOption {
	return func(m *RevocationMutation) {
		m.oldValue = func(context.Context) (*Revocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RevocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RevocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Revocation entities.
func (m *RevocationMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RevocationMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RevocationMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Revocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReason sets the "reason" field.
func (m *RevocationMutation) SetReason(i int) {
	m.reason = &i
	m.addreason = nil
}

// Reason returns the value of the "reason" field in the mutation.
func (m *RevocationMutation) Reason() (r int, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Revocation entity.
// If the Revocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevocationMutation) OldReason(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// AddReason adds i to the "reason" field.
func (m *RevocationMutation) AddReason(i int) {
	if m.addreason != nil {
		*m.addreason += i
	} else {
		m.addreason = &i
	}
}

// AddedReason returns the value that was added to the "reason" field in this mutation.
func (m *RevocationMutation) AddedReason() (r int, exists bool) {
	v := m.addreason
	if v == nil {
		return
	}
	return *v, true
}

// ClearReason clears the value of the "reason" field.
func (m *RevocationMutation) ClearReason() {
	m.reason = nil
	m.addreason = nil
	m.clearedFields[revocation.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *RevocationMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[revocation.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *RevocationMutation) ResetReason() {
	m.reason = nil
	m.addreason = nil
	delete(m.clearedFields, revocation.FieldReason)
}

// SetInfo sets the "info" field.
func (m *RevocationMutation) SetInfo(s string) {
	m.info = &s
}

// Info returns the value of the "info" field in the mutation.
func (m *RevocationMutation) Info() (r string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the Revocation entity.
// If the Revocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevocationMutation) OldInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ClearInfo clears the value of the "info" field.
func (m *RevocationMutation) ClearInfo() {
	m.info = nil
	m.clearedFields[revocation.FieldInfo] = struct{}{}
}

// InfoCleared returns if the "info" field was cleared in this mutation.
func (m *RevocationMutation) InfoCleared() bool {
	_, ok := m.clearedFields[revocation.FieldInfo]
	return ok
}

// ResetInfo resets all changes to the "info" field.
func (m *RevocationMutation) ResetInfo() {
	m.info = nil
	delete(m.clearedFields, revocation.FieldInfo)
}

// SetExpiry sets the "expiry" field.
func (m *RevocationMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *RevocationMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Revocation entity.
// If the Revocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevocationMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ClearExpiry clears the value of the "expiry" field.
func (m *RevocationMutation) ClearExpiry() {
	m.expiry = nil
	m.clearedFields[revocation.FieldExpiry] = struct{}{}
}

// ExpiryCleared returns if the "expiry" field was cleared in this mutation.
func (m *RevocationMutation) ExpiryCleared() bool {
	_, ok := m.clearedFields[revocation.FieldExpiry]
	return ok
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *RevocationMutation) ResetExpiry() {
	m.expiry = nil
	delete(m.clearedFields, revocation.FieldExpiry)
}

// SetRevoked sets the "revoked" field.
func (m *RevocationMutation) SetRevoked(t time.Time) {
	m.revoked = &t
}

// Revoked returns the value of the "revoked" field in the mutation.
func (m *RevocationMutation) Revoked() (r time.Time, exists bool) {
	v := m.revoked
	if v == nil {
		return
	}
	return *v, true
}

// OldRevoked returns the old "revoked" field's value of the Revocation entity.
// If the Revocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevocationMutation) OldRevoked(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevoked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevoked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevoked: %w", err)
	}
	return oldValue.Revoked, nil
}

// ResetRevoked resets all changes to the "revoked" field.
func (m *RevocationMutation) ResetRevoked() {
	m.revoked = nil
}

// Where appends a list predicates to the RevocationMutation builder.
func (m *RevocationMutation) Where(ps ...predicate.Revocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RevocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RevocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Revocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RevocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RevocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Revocation).
func (m *RevocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RevocationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.reason != nil {
		fields = append(fields, revocation.FieldReason)
	}
	if m.info != nil {
		fields = append(fields, revocation.FieldInfo)
	}
	if m.expiry != nil {
		fields = append(fields, revocation.FieldExpiry)
	}
	if m.revoked != nil {
		fields = append(fields, revocation.FieldRevoked)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RevocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case revocation.FieldReason:
		return m.Reason()
	case revocation.FieldInfo:
		return m.Info()
	case revocation.FieldExpiry:
		return m.Expiry()
	case revocation.FieldRevoked:
		return m.Revoked()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RevocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case revocation.FieldReason:
		return m.OldReason(ctx)
	case revocation.FieldInfo:
		return m.OldInfo(ctx)
	case revocation.FieldExpiry:
		return m.OldExpiry(ctx)
	case revocation.FieldRevoked:
		return m.OldRevoked(ctx)
	}
	return nil, fmt.Errorf("unknown Revocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case revocation.FieldReason:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case revocation.FieldInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case revocation.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case revocation.FieldRevoked:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevoked(v)
		return nil
	}
	return fmt.Errorf("unknown Revocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RevocationMutation) AddedFields() []string {
	var fields []string
	if m.addreason != nil {
		fields = append(fields, revocation.FieldReason)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RevocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case revocation.FieldReason:
		return m.AddedReason()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case revocation.FieldReason:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReason(v)
		return nil
	}
	return fmt.Errorf("unknown Revocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RevocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(revocation.FieldReason) {
		fields = append(fields, revocation.FieldReason)
	}
	if m.FieldCleared(revocation.FieldInfo) {
		fields = append(fields, revocation.FieldInfo)
	}
	if m.FieldCleared(revocation.FieldExpiry) {
		fields = append(fields, revocation.FieldExpiry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RevocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RevocationMutation) ClearField(name string) error {
	switch name {
	case revocation.FieldReason:
		m.ClearReason()
		return nil
	case revocation.FieldInfo:
		m.ClearInfo()
		return nil
	case revocation.FieldExpiry:
		m.ClearExpiry()
		return nil
	}
	return fmt.Errorf("unknown Revocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RevocationMutation) ResetField(name string) error {
	switch name {
	case revocation.FieldReason:
		m.ResetReason()
		return nil
	case revocation.FieldInfo:
		m.ResetInfo()
		return nil
	case revocation.FieldExpiry:
		m.ResetExpiry()
		return nil
	case revocation.FieldRevoked:
		m.ResetRevoked()
		return nil
	}
	return fmt.Errorf("unknown Revocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RevocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RevocationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RevocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RevocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RevocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RevocationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RevocationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Revocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RevocationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Revocation edge %s", name)
}

// RustdeskMutation represents an operation that mutates the Rustdesk nodes in the graph.
type RustdeskMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	custom_rendezvous_server     *string
	relay_server                 *string
	api_server                   *string
	key                          *string
	use_permanent_password       *bool
	whitelist                    *string
	direct_ip_access             *bool
	verification_method          *rustdesk.VerificationMethod
	temporary_password_length    *int
	addtemporary_password_length *int
	clearedFields                map[string]struct{}
	tenant                       map[int]struct{}
	removedtenant                map[int]struct{}
	clearedtenant                bool
	done                         bool
	oldValue                     func(context.Context) (*Rustdesk, error)
	predicates                   []predicate.Rustdesk
}

var _ ent.Mutation = (*RustdeskMutation)(nil)

// rustdeskOption allows management of the mutation configuration using functional options.
type rustdeskOption func(*RustdeskMutation)

// newRustdeskMutation creates new mutation for the Rustdesk entity.
func newRustdeskMutation(c config, op Op, opts ...rustdeskOption) *RustdeskMutation {
	m := &RustdeskMutation{
		config:        c,
		op:            op,
		typ:           TypeRustdesk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRustdeskID sets the ID field of the mutation.
func withRustdeskID(id int) rustdeskOption {
	return func(m *RustdeskMutation) {
		var (
			err   error
			once  sync.Once
			value *Rustdesk
		)
		m.oldValue = func(ctx context.Context) (*Rustdesk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rustdesk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRustdesk sets the old Rustdesk of the mutation.
func withRustdesk(node *Rustdesk) rustdeskOption {
	return func(m *RustdeskMutation) {
		m.oldValue = func(context.Context) (*Rustdesk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RustdeskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RustdeskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RustdeskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RustdeskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rustdesk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCustomRendezvousServer sets the "custom_rendezvous_server" field.
func (m *RustdeskMutation) SetCustomRendezvousServer(s string) {
	m.custom_rendezvous_server = &s
}

// CustomRendezvousServer returns the value of the "custom_rendezvous_server" field in the mutation.
func (m *RustdeskMutation) CustomRendezvousServer() (r string, exists bool) {
	v := m.custom_rendezvous_server
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomRendezvousServer returns the old "custom_rendezvous_server" field's value of the Rustdesk entity.
// If the Rustdesk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RustdeskMutation) OldCustomRendezvousServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomRendezvousServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomRendezvousServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomRendezvousServer: %w", err)
	}
	return oldValue.CustomRendezvousServer, nil
}

// ClearCustomRendezvousServer clears the value of the "custom_rendezvous_server" field.
func (m *RustdeskMutation) ClearCustomRendezvousServer() {
	m.custom_rendezvous_server = nil
	m.clearedFields[rustdesk.FieldCustomRendezvousServer] = struct{}{}
}

// CustomRendezvousServerCleared returns if the "custom_rendezvous_server" field was cleared in this mutation.
func (m *RustdeskMutation) CustomRendezvousServerCleared() bool {
	_, ok := m.clearedFields[rustdesk.FieldCustomRendezvousServer]
	return ok
}

// ResetCustomRendezvousServer resets all changes to the "custom_rendezvous_server" field.
func (m *RustdeskMutation) ResetCustomRendezvousServer() {
	m.custom_rendezvous_server = nil
	delete(m.clearedFields, rustdesk.FieldCustomRendezvousServer)
}

// SetRelayServer sets the "relay_server" field.
func (m *RustdeskMutation) SetRelayServer(s string) {
	m.relay_server = &s
}

// RelayServer returns the value of the "relay_server" field in the mutation.
func (m *RustdeskMutation) RelayServer() (r string, exists bool) {
	v := m.relay_server
	if v == nil {
		return
	}
	return *v, true
}

// OldRelayServer returns the old "relay_server" field's value of the Rustdesk entity.
// If the Rustdesk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RustdeskMutation) OldRelayServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelayServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelayServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelayServer: %w", err)
	}
	return oldValue.RelayServer, nil
}

// ClearRelayServer clears the value of the "relay_server" field.
func (m *RustdeskMutation) ClearRelayServer() {
	m.relay_server = nil
	m.clearedFields[rustdesk.FieldRelayServer] = struct{}{}
}

// RelayServerCleared returns if the "relay_server" field was cleared in this mutation.
func (m *RustdeskMutation) RelayServerCleared() bool {
	_, ok := m.clearedFields[rustdesk.FieldRelayServer]
	return ok
}

// ResetRelayServer resets all changes to the "relay_server" field.
func (m *RustdeskMutation) ResetRelayServer() {
	m.relay_server = nil
	delete(m.clearedFields, rustdesk.FieldRelayServer)
}

// SetAPIServer sets the "api_server" field.
func (m *RustdeskMutation) SetAPIServer(s string) {
	m.api_server = &s
}

// APIServer returns the value of the "api_server" field in the mutation.
func (m *RustdeskMutation) APIServer() (r string, exists bool) {
	v := m.api_server
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIServer returns the old "api_server" field's value of the Rustdesk entity.
// If the Rustdesk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RustdeskMutation) OldAPIServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIServer: %w", err)
	}
	return oldValue.APIServer, nil
}

// ClearAPIServer clears the value of the "api_server" field.
func (m *RustdeskMutation) ClearAPIServer() {
	m.api_server = nil
	m.clearedFields[rustdesk.FieldAPIServer] = struct{}{}
}

// APIServerCleared returns if the "api_server" field was cleared in this mutation.
func (m *RustdeskMutation) APIServerCleared() bool {
	_, ok := m.clearedFields[rustdesk.FieldAPIServer]
	return ok
}

// ResetAPIServer resets all changes to the "api_server" field.
func (m *RustdeskMutation) ResetAPIServer() {
	m.api_server = nil
	delete(m.clearedFields, rustdesk.FieldAPIServer)
}

// SetKey sets the "key" field.
func (m *RustdeskMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *RustdeskMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Rustdesk entity.
// If the Rustdesk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RustdeskMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ClearKey clears the value of the "key" field.
func (m *RustdeskMutation) ClearKey() {
	m.key = nil
	m.clearedFields[rustdesk.FieldKey] = struct{}{}
}

// KeyCleared returns if the "key" field was cleared in this mutation.
func (m *RustdeskMutation) KeyCleared() bool {
	_, ok := m.clearedFields[rustdesk.FieldKey]
	return ok
}

// ResetKey resets all changes to the "key" field.
func (m *RustdeskMutation) ResetKey() {
	m.key = nil
	delete(m.clearedFields, rustdesk.FieldKey)
}

// SetUsePermanentPassword sets the "use_permanent_password" field.
func (m *RustdeskMutation) SetUsePermanentPassword(b bool) {
	m.use_permanent_password = &b
}

// UsePermanentPassword returns the value of the "use_permanent_password" field in the mutation.
func (m *RustdeskMutation) UsePermanentPassword() (r bool, exists bool) {
	v := m.use_permanent_password
	if v == nil {
		return
	}
	return *v, true
}

// OldUsePermanentPassword returns the old "use_permanent_password" field's value of the Rustdesk entity.
// If the Rustdesk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RustdeskMutation) OldUsePermanentPassword(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsePermanentPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsePermanentPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsePermanentPassword: %w", err)
	}
	return oldValue.UsePermanentPassword, nil
}

// ClearUsePermanentPassword clears the value of the "use_permanent_password" field.
func (m *RustdeskMutation) ClearUsePermanentPassword() {
	m.use_permanent_password = nil
	m.clearedFields[rustdesk.FieldUsePermanentPassword] = struct{}{}
}

// UsePermanentPasswordCleared returns if the "use_permanent_password" field was cleared in this mutation.
func (m *RustdeskMutation) UsePermanentPasswordCleared() bool {
	_, ok := m.clearedFields[rustdesk.FieldUsePermanentPassword]
	return ok
}

// ResetUsePermanentPassword resets all changes to the "use_permanent_password" field.
func (m *RustdeskMutation) ResetUsePermanentPassword() {
	m.use_permanent_password = nil
	delete(m.clearedFields, rustdesk.FieldUsePermanentPassword)
}

// SetWhitelist sets the "whitelist" field.
func (m *RustdeskMutation) SetWhitelist(s string) {
	m.whitelist = &s
}

// Whitelist returns the value of the "whitelist" field in the mutation.
func (m *RustdeskMutation) Whitelist() (r string, exists bool) {
	v := m.whitelist
	if v == nil {
		return
	}
	return *v, true
}

// OldWhitelist returns the old "whitelist" field's value of the Rustdesk entity.
// If the Rustdesk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RustdeskMutation) OldWhitelist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhitelist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhitelist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhitelist: %w", err)
	}
	return oldValue.Whitelist, nil
}

// ClearWhitelist clears the value of the "whitelist" field.
func (m *RustdeskMutation) ClearWhitelist() {
	m.whitelist = nil
	m.clearedFields[rustdesk.FieldWhitelist] = struct{}{}
}

// WhitelistCleared returns if the "whitelist" field was cleared in this mutation.
func (m *RustdeskMutation) WhitelistCleared() bool {
	_, ok := m.clearedFields[rustdesk.FieldWhitelist]
	return ok
}

// ResetWhitelist resets all changes to the "whitelist" field.
func (m *RustdeskMutation) ResetWhitelist() {
	m.whitelist = nil
	delete(m.clearedFields, rustdesk.FieldWhitelist)
}

// SetDirectIPAccess sets the "direct_ip_access" field.
func (m *RustdeskMutation) SetDirectIPAccess(b bool) {
	m.direct_ip_access = &b
}

// DirectIPAccess returns the value of the "direct_ip_access" field in the mutation.
func (m *RustdeskMutation) DirectIPAccess() (r bool, exists bool) {
	v := m.direct_ip_access
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectIPAccess returns the old "direct_ip_access" field's value of the Rustdesk entity.
// If the Rustdesk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RustdeskMutation) OldDirectIPAccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectIPAccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectIPAccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectIPAccess: %w", err)
	}
	return oldValue.DirectIPAccess, nil
}

// ClearDirectIPAccess clears the value of the "direct_ip_access" field.
func (m *RustdeskMutation) ClearDirectIPAccess() {
	m.direct_ip_access = nil
	m.clearedFields[rustdesk.FieldDirectIPAccess] = struct{}{}
}

// DirectIPAccessCleared returns if the "direct_ip_access" field was cleared in this mutation.
func (m *RustdeskMutation) DirectIPAccessCleared() bool {
	_, ok := m.clearedFields[rustdesk.FieldDirectIPAccess]
	return ok
}

// ResetDirectIPAccess resets all changes to the "direct_ip_access" field.
func (m *RustdeskMutation) ResetDirectIPAccess() {
	m.direct_ip_access = nil
	delete(m.clearedFields, rustdesk.FieldDirectIPAccess)
}

// SetVerificationMethod sets the "verification_method" field.
func (m *RustdeskMutation) SetVerificationMethod(rm rustdesk.VerificationMethod) {
	m.verification_method = &rm
}

// VerificationMethod returns the value of the "verification_method" field in the mutation.
func (m *RustdeskMutation) VerificationMethod() (r rustdesk.VerificationMethod, exists bool) {
	v := m.verification_method
	if v == nil {
		return
	}
	return *v, true
}

// OldVerificationMethod returns the old "verification_method" field's value of the Rustdesk entity.
// If the Rustdesk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RustdeskMutation) OldVerificationMethod(ctx context.Context) (v rustdesk.VerificationMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerificationMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerificationMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerificationMethod: %w", err)
	}
	return oldValue.VerificationMethod, nil
}

// ClearVerificationMethod clears the value of the "verification_method" field.
func (m *RustdeskMutation) ClearVerificationMethod() {
	m.verification_method = nil
	m.clearedFields[rustdesk.FieldVerificationMethod] = struct{}{}
}

// VerificationMethodCleared returns if the "verification_method" field was cleared in this mutation.
func (m *RustdeskMutation) VerificationMethodCleared() bool {
	_, ok := m.clearedFields[rustdesk.FieldVerificationMethod]
	return ok
}

// ResetVerificationMethod resets all changes to the "verification_method" field.
func (m *RustdeskMutation) ResetVerificationMethod() {
	m.verification_method = nil
	delete(m.clearedFields, rustdesk.FieldVerificationMethod)
}

// SetTemporaryPasswordLength sets the "temporary_password_length" field.
func (m *RustdeskMutation) SetTemporaryPasswordLength(i int) {
	m.temporary_password_length = &i
	m.addtemporary_password_length = nil
}

// TemporaryPasswordLength returns the value of the "temporary_password_length" field in the mutation.
func (m *RustdeskMutation) TemporaryPasswordLength() (r int, exists bool) {
	v := m.temporary_password_length
	if v == nil {
		return
	}
	return *v, true
}

// OldTemporaryPasswordLength returns the old "temporary_password_length" field's value of the Rustdesk entity.
// If the Rustdesk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RustdeskMutation) OldTemporaryPasswordLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemporaryPasswordLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemporaryPasswordLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemporaryPasswordLength: %w", err)
	}
	return oldValue.TemporaryPasswordLength, nil
}

// AddTemporaryPasswordLength adds i to the "temporary_password_length" field.
func (m *RustdeskMutation) AddTemporaryPasswordLength(i int) {
	if m.addtemporary_password_length != nil {
		*m.addtemporary_password_length += i
	} else {
		m.addtemporary_password_length = &i
	}
}

// AddedTemporaryPasswordLength returns the value that was added to the "temporary_password_length" field in this mutation.
func (m *RustdeskMutation) AddedTemporaryPasswordLength() (r int, exists bool) {
	v := m.addtemporary_password_length
	if v == nil {
		return
	}
	return *v, true
}

// ClearTemporaryPasswordLength clears the value of the "temporary_password_length" field.
func (m *RustdeskMutation) ClearTemporaryPasswordLength() {
	m.temporary_password_length = nil
	m.addtemporary_password_length = nil
	m.clearedFields[rustdesk.FieldTemporaryPasswordLength] = struct{}{}
}

// TemporaryPasswordLengthCleared returns if the "temporary_password_length" field was cleared in this mutation.
func (m *RustdeskMutation) TemporaryPasswordLengthCleared() bool {
	_, ok := m.clearedFields[rustdesk.FieldTemporaryPasswordLength]
	return ok
}

// ResetTemporaryPasswordLength resets all changes to the "temporary_password_length" field.
func (m *RustdeskMutation) ResetTemporaryPasswordLength() {
	m.temporary_password_length = nil
	m.addtemporary_password_length = nil
	delete(m.clearedFields, rustdesk.FieldTemporaryPasswordLength)
}

// AddTenantIDs adds the "tenant" edge to the Tenant entity by ids.
func (m *RustdeskMutation) AddTenantIDs(ids ...int) {
	if m.tenant == nil {
		m.tenant = make(map[int]struct{})
	}
	for i := range ids {
		m.tenant[ids[i]] = struct{}{}
	}
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *RustdeskMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *RustdeskMutation) TenantCleared() bool {
	return m.clearedtenant
}

// RemoveTenantIDs removes the "tenant" edge to the Tenant entity by IDs.
func (m *RustdeskMutation) RemoveTenantIDs(ids ...int) {
	if m.removedtenant == nil {
		m.removedtenant = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tenant, ids[i])
		m.removedtenant[ids[i]] = struct{}{}
	}
}

// RemovedTenant returns the removed IDs of the "tenant" edge to the Tenant entity.
func (m *RustdeskMutation) RemovedTenantIDs() (ids []int) {
	for id := range m.removedtenant {
		ids = append(ids, id)
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
func (m *RustdeskMutation) TenantIDs() (ids []int) {
	for id := range m.tenant {
		ids = append(ids, id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *RustdeskMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
	m.removedtenant = nil
}

// Where appends a list predicates to the RustdeskMutation builder.
func (m *RustdeskMutation) Where(ps ...predicate.Rustdesk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RustdeskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RustdeskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Rustdesk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RustdeskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RustdeskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Rustdesk).
func (m *RustdeskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RustdeskMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.custom_rendezvous_server != nil {
		fields = append(fields, rustdesk.FieldCustomRendezvousServer)
	}
	if m.relay_server != nil {
		fields = append(fields, rustdesk.FieldRelayServer)
	}
	if m.api_server != nil {
		fields = append(fields, rustdesk.FieldAPIServer)
	}
	if m.key != nil {
		fields = append(fields, rustdesk.FieldKey)
	}
	if m.use_permanent_password != nil {
		fields = append(fields, rustdesk.FieldUsePermanentPassword)
	}
	if m.whitelist != nil {
		fields = append(fields, rustdesk.FieldWhitelist)
	}
	if m.direct_ip_access != nil {
		fields = append(fields, rustdesk.FieldDirectIPAccess)
	}
	if m.verification_method != nil {
		fields = append(fields, rustdesk.FieldVerificationMethod)
	}
	if m.temporary_password_length != nil {
		fields = append(fields, rustdesk.FieldTemporaryPasswordLength)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RustdeskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rustdesk.FieldCustomRendezvousServer:
		return m.CustomRendezvousServer()
	case rustdesk.FieldRelayServer:
		return m.RelayServer()
	case rustdesk.FieldAPIServer:
		return m.APIServer()
	case rustdesk.FieldKey:
		return m.Key()
	case rustdesk.FieldUsePermanentPassword:
		return m.UsePermanentPassword()
	case rustdesk.FieldWhitelist:
		return m.Whitelist()
	case rustdesk.FieldDirectIPAccess:
		return m.DirectIPAccess()
	case rustdesk.FieldVerificationMethod:
		return m.VerificationMethod()
	case rustdesk.FieldTemporaryPasswordLength:
		return m.TemporaryPasswordLength()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RustdeskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rustdesk.FieldCustomRendezvousServer:
		return m.OldCustomRendezvousServer(ctx)
	case rustdesk.FieldRelayServer:
		return m.OldRelayServer(ctx)
	case rustdesk.FieldAPIServer:
		return m.OldAPIServer(ctx)
	case rustdesk.FieldKey:
		return m.OldKey(ctx)
	case rustdesk.FieldUsePermanentPassword:
		return m.OldUsePermanentPassword(ctx)
	case rustdesk.FieldWhitelist:
		return m.OldWhitelist(ctx)
	case rustdesk.FieldDirectIPAccess:
		return m.OldDirectIPAccess(ctx)
	case rustdesk.FieldVerificationMethod:
		return m.OldVerificationMethod(ctx)
	case rustdesk.FieldTemporaryPasswordLength:
		return m.OldTemporaryPasswordLength(ctx)
	}
	return nil, fmt.Errorf("unknown Rustdesk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RustdeskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rustdesk.FieldCustomRendezvousServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomRendezvousServer(v)
		return nil
	case rustdesk.FieldRelayServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelayServer(v)
		return nil
	case rustdesk.FieldAPIServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIServer(v)
		return nil
	case rustdesk.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case rustdesk.FieldUsePermanentPassword:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsePermanentPassword(v)
		return nil
	case rustdesk.FieldWhitelist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhitelist(v)
		return nil
	case rustdesk.FieldDirectIPAccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectIPAccess(v)
		return nil
	case rustdesk.FieldVerificationMethod:
		v, ok := value.(rustdesk.VerificationMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerificationMethod(v)
		return nil
	case rustdesk.FieldTemporaryPasswordLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemporaryPasswordLength(v)
		return nil
	}
	return fmt.Errorf("unknown Rustdesk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RustdeskMutation) AddedFields() []string {
	var fields []string
	if m.addtemporary_password_length != nil {
		fields = append(fields, rustdesk.FieldTemporaryPasswordLength)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RustdeskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rustdesk.FieldTemporaryPasswordLength:
		return m.AddedTemporaryPasswordLength()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RustdeskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rustdesk.FieldTemporaryPasswordLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemporaryPasswordLength(v)
		return nil
	}
	return fmt.Errorf("unknown Rustdesk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RustdeskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rustdesk.FieldCustomRendezvousServer) {
		fields = append(fields, rustdesk.FieldCustomRendezvousServer)
	}
	if m.FieldCleared(rustdesk.FieldRelayServer) {
		fields = append(fields, rustdesk.FieldRelayServer)
	}
	if m.FieldCleared(rustdesk.FieldAPIServer) {
		fields = append(fields, rustdesk.FieldAPIServer)
	}
	if m.FieldCleared(rustdesk.FieldKey) {
		fields = append(fields, rustdesk.FieldKey)
	}
	if m.FieldCleared(rustdesk.FieldUsePermanentPassword) {
		fields = append(fields, rustdesk.FieldUsePermanentPassword)
	}
	if m.FieldCleared(rustdesk.FieldWhitelist) {
		fields = append(fields, rustdesk.FieldWhitelist)
	}
	if m.FieldCleared(rustdesk.FieldDirectIPAccess) {
		fields = append(fields, rustdesk.FieldDirectIPAccess)
	}
	if m.FieldCleared(rustdesk.FieldVerificationMethod) {
		fields = append(fields, rustdesk.FieldVerificationMethod)
	}
	if m.FieldCleared(rustdesk.FieldTemporaryPasswordLength) {
		fields = append(fields, rustdesk.FieldTemporaryPasswordLength)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RustdeskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RustdeskMutation) ClearField(name string) error {
	switch name {
	case rustdesk.FieldCustomRendezvousServer:
		m.ClearCustomRendezvousServer()
		return nil
	case rustdesk.FieldRelayServer:
		m.ClearRelayServer()
		return nil
	case rustdesk.FieldAPIServer:
		m.ClearAPIServer()
		return nil
	case rustdesk.FieldKey:
		m.ClearKey()
		return nil
	case rustdesk.FieldUsePermanentPassword:
		m.ClearUsePermanentPassword()
		return nil
	case rustdesk.FieldWhitelist:
		m.ClearWhitelist()
		return nil
	case rustdesk.FieldDirectIPAccess:
		m.ClearDirectIPAccess()
		return nil
	case rustdesk.FieldVerificationMethod:
		m.ClearVerificationMethod()
		return nil
	case rustdesk.FieldTemporaryPasswordLength:
		m.ClearTemporaryPasswordLength()
		return nil
	}
	return fmt.Errorf("unknown Rustdesk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RustdeskMutation) ResetField(name string) error {
	switch name {
	case rustdesk.FieldCustomRendezvousServer:
		m.ResetCustomRendezvousServer()
		return nil
	case rustdesk.FieldRelayServer:
		m.ResetRelayServer()
		return nil
	case rustdesk.FieldAPIServer:
		m.ResetAPIServer()
		return nil
	case rustdesk.FieldKey:
		m.ResetKey()
		return nil
	case rustdesk.FieldUsePermanentPassword:
		m.ResetUsePermanentPassword()
		return nil
	case rustdesk.FieldWhitelist:
		m.ResetWhitelist()
		return nil
	case rustdesk.FieldDirectIPAccess:
		m.ResetDirectIPAccess()
		return nil
	case rustdesk.FieldVerificationMethod:
		m.ResetVerificationMethod()
		return nil
	case rustdesk.FieldTemporaryPasswordLength:
		m.ResetTemporaryPasswordLength()
		return nil
	}
	return fmt.Errorf("unknown Rustdesk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RustdeskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, rustdesk.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RustdeskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rustdesk.EdgeTenant:
		ids := make([]ent.Value, 0, len(m.tenant))
		for id := range m.tenant {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RustdeskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtenant != nil {
		edges = append(edges, rustdesk.EdgeTenant)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RustdeskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rustdesk.EdgeTenant:
		ids := make([]ent.Value, 0, len(m.removedtenant))
		for id := range m.removedtenant {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RustdeskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, rustdesk.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RustdeskMutation) EdgeCleared(name string) bool {
	switch name {
	case rustdesk.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RustdeskMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Rustdesk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RustdeskMutation) ResetEdge(name string) error {
	switch name {
	case rustdesk.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Rustdesk edge %s", name)
}

// ServerMutation represents an operation that mutates the Server nodes in the graph.
type ServerMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	hostname                      *string
	arch                          *string
	os                            *string
	version                       *string
	channel                       *server.Channel
	update_status                 *server.UpdateStatus
	update_message                *string
	update_when                   *time.Time
	nats_component                *bool
	ocsp_component                *bool
	console_component             *bool
	agent_worker_component        *bool
	notification_worker_component *bool
	cert_manager_worker_component *bool
	clearedFields                 map[string]struct{}
	done                          bool
	oldValue                      func(context.Context) (*Server, error)
	predicates                    []predicate.Server
}

var _ ent.Mutation = (*ServerMutation)(nil)

// serverOption allows management of the mutation configuration using functional options.
type serverOption func(*ServerMutation)

// newServerMutation creates new mutation for the Server entity.
func newServerMutation(c config, op Op, opts ...serverOption) *ServerMutation {
	m := &ServerMutation{
		config:        c,
		op:            op,
		typ:           TypeServer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerID sets the ID field of the mutation.
func withServerID(id int) serverOption {
	return func(m *ServerMutation) {
		var (
			err   error
			once  sync.Once
			value *Server
		)
		m.oldValue = func(ctx context.Context) (*Server, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Server.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServer sets the old Server of the mutation.
func withServer(node *Server) serverOption {
	return func(m *ServerMutation) {
		m.oldValue = func(context.Context) (*Server, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Server.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHostname sets the "hostname" field.
func (m *ServerMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *ServerMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *ServerMutation) ResetHostname() {
	m.hostname = nil
}

// SetArch sets the "arch" field.
func (m *ServerMutation) SetArch(s string) {
	m.arch = &s
}

// Arch returns the value of the "arch" field in the mutation.
func (m *ServerMutation) Arch() (r string, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ResetArch resets all changes to the "arch" field.
func (m *ServerMutation) ResetArch() {
	m.arch = nil
}

// SetOs sets the "os" field.
func (m *ServerMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *ServerMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *ServerMutation) ResetOs() {
	m.os = nil
}

// SetVersion sets the "version" field.
func (m *ServerMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ServerMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ServerMutation) ResetVersion() {
	m.version = nil
}

// SetChannel sets the "channel" field.
func (m *ServerMutation) SetChannel(s server.Channel) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *ServerMutation) Channel() (r server.Channel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldChannel(ctx context.Context) (v server.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *ServerMutation) ResetChannel() {
	m.channel = nil
}

// SetUpdateStatus sets the "update_status" field.
func (m *ServerMutation) SetUpdateStatus(ss server.UpdateStatus) {
	m.update_status = &ss
}

// UpdateStatus returns the value of the "update_status" field in the mutation.
func (m *ServerMutation) UpdateStatus() (r server.UpdateStatus, exists bool) {
	v := m.update_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateStatus returns the old "update_status" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldUpdateStatus(ctx context.Context) (v server.UpdateStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateStatus: %w", err)
	}
	return oldValue.UpdateStatus, nil
}

// ClearUpdateStatus clears the value of the "update_status" field.
func (m *ServerMutation) ClearUpdateStatus() {
	m.update_status = nil
	m.clearedFields[server.FieldUpdateStatus] = struct{}{}
}

// UpdateStatusCleared returns if the "update_status" field was cleared in this mutation.
func (m *ServerMutation) UpdateStatusCleared() bool {
	_, ok := m.clearedFields[server.FieldUpdateStatus]
	return ok
}

// ResetUpdateStatus resets all changes to the "update_status" field.
func (m *ServerMutation) ResetUpdateStatus() {
	m.update_status = nil
	delete(m.clearedFields, server.FieldUpdateStatus)
}

// SetUpdateMessage sets the "update_message" field.
func (m *ServerMutation) SetUpdateMessage(s string) {
	m.update_message = &s
}

// UpdateMessage returns the value of the "update_message" field in the mutation.
func (m *ServerMutation) UpdateMessage() (r string, exists bool) {
	v := m.update_message
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateMessage returns the old "update_message" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldUpdateMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateMessage: %w", err)
	}
	return oldValue.UpdateMessage, nil
}

// ClearUpdateMessage clears the value of the "update_message" field.
func (m *ServerMutation) ClearUpdateMessage() {
	m.update_message = nil
	m.clearedFields[server.FieldUpdateMessage] = struct{}{}
}

// UpdateMessageCleared returns if the "update_message" field was cleared in this mutation.
func (m *ServerMutation) UpdateMessageCleared() bool {
	_, ok := m.clearedFields[server.FieldUpdateMessage]
	return ok
}

// ResetUpdateMessage resets all changes to the "update_message" field.
func (m *ServerMutation) ResetUpdateMessage() {
	m.update_message = nil
	delete(m.clearedFields, server.FieldUpdateMessage)
}

// SetUpdateWhen sets the "update_when" field.
func (m *ServerMutation) SetUpdateWhen(t time.Time) {
	m.update_when = &t
}

// UpdateWhen returns the value of the "update_when" field in the mutation.
func (m *ServerMutation) UpdateWhen() (r time.Time, exists bool) {
	v := m.update_when
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateWhen returns the old "update_when" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldUpdateWhen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateWhen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateWhen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateWhen: %w", err)
	}
	return oldValue.UpdateWhen, nil
}

// ClearUpdateWhen clears the value of the "update_when" field.
func (m *ServerMutation) ClearUpdateWhen() {
	m.update_when = nil
	m.clearedFields[server.FieldUpdateWhen] = struct{}{}
}

// UpdateWhenCleared returns if the "update_when" field was cleared in this mutation.
func (m *ServerMutation) UpdateWhenCleared() bool {
	_, ok := m.clearedFields[server.FieldUpdateWhen]
	return ok
}

// ResetUpdateWhen resets all changes to the "update_when" field.
func (m *ServerMutation) ResetUpdateWhen() {
	m.update_when = nil
	delete(m.clearedFields, server.FieldUpdateWhen)
}

// SetNatsComponent sets the "nats_component" field.
func (m *ServerMutation) SetNatsComponent(b bool) {
	m.nats_component = &b
}

// NatsComponent returns the value of the "nats_component" field in the mutation.
func (m *ServerMutation) NatsComponent() (r bool, exists bool) {
	v := m.nats_component
	if v == nil {
		return
	}
	return *v, true
}

// OldNatsComponent returns the old "nats_component" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldNatsComponent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNatsComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNatsComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNatsComponent: %w", err)
	}
	return oldValue.NatsComponent, nil
}

// ClearNatsComponent clears the value of the "nats_component" field.
func (m *ServerMutation) ClearNatsComponent() {
	m.nats_component = nil
	m.clearedFields[server.FieldNatsComponent] = struct{}{}
}

// NatsComponentCleared returns if the "nats_component" field was cleared in this mutation.
func (m *ServerMutation) NatsComponentCleared() bool {
	_, ok := m.clearedFields[server.FieldNatsComponent]
	return ok
}

// ResetNatsComponent resets all changes to the "nats_component" field.
func (m *ServerMutation) ResetNatsComponent() {
	m.nats_component = nil
	delete(m.clearedFields, server.FieldNatsComponent)
}

// SetOcspComponent sets the "ocsp_component" field.
func (m *ServerMutation) SetOcspComponent(b bool) {
	m.ocsp_component = &b
}

// OcspComponent returns the value of the "ocsp_component" field in the mutation.
func (m *ServerMutation) OcspComponent() (r bool, exists bool) {
	v := m.ocsp_component
	if v == nil {
		return
	}
	return *v, true
}

// OldOcspComponent returns the old "ocsp_component" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldOcspComponent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOcspComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOcspComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOcspComponent: %w", err)
	}
	return oldValue.OcspComponent, nil
}

// ClearOcspComponent clears the value of the "ocsp_component" field.
func (m *ServerMutation) ClearOcspComponent() {
	m.ocsp_component = nil
	m.clearedFields[server.FieldOcspComponent] = struct{}{}
}

// OcspComponentCleared returns if the "ocsp_component" field was cleared in this mutation.
func (m *ServerMutation) OcspComponentCleared() bool {
	_, ok := m.clearedFields[server.FieldOcspComponent]
	return ok
}

// ResetOcspComponent resets all changes to the "ocsp_component" field.
func (m *ServerMutation) ResetOcspComponent() {
	m.ocsp_component = nil
	delete(m.clearedFields, server.FieldOcspComponent)
}

// SetConsoleComponent sets the "console_component" field.
func (m *ServerMutation) SetConsoleComponent(b bool) {
	m.console_component = &b
}

// ConsoleComponent returns the value of the "console_component" field in the mutation.
func (m *ServerMutation) ConsoleComponent() (r bool, exists bool) {
	v := m.console_component
	if v == nil {
		return
	}
	return *v, true
}

// OldConsoleComponent returns the old "console_component" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldConsoleComponent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsoleComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsoleComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsoleComponent: %w", err)
	}
	return oldValue.ConsoleComponent, nil
}

// ClearConsoleComponent clears the value of the "console_component" field.
func (m *ServerMutation) ClearConsoleComponent() {
	m.console_component = nil
	m.clearedFields[server.FieldConsoleComponent] = struct{}{}
}

// ConsoleComponentCleared returns if the "console_component" field was cleared in this mutation.
func (m *ServerMutation) ConsoleComponentCleared() bool {
	_, ok := m.clearedFields[server.FieldConsoleComponent]
	return ok
}

// ResetConsoleComponent resets all changes to the "console_component" field.
func (m *ServerMutation) ResetConsoleComponent() {
	m.console_component = nil
	delete(m.clearedFields, server.FieldConsoleComponent)
}

// SetAgentWorkerComponent sets the "agent_worker_component" field.
func (m *ServerMutation) SetAgentWorkerComponent(b bool) {
	m.agent_worker_component = &b
}

// AgentWorkerComponent returns the value of the "agent_worker_component" field in the mutation.
func (m *ServerMutation) AgentWorkerComponent() (r bool, exists bool) {
	v := m.agent_worker_component
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentWorkerComponent returns the old "agent_worker_component" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldAgentWorkerComponent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentWorkerComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentWorkerComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentWorkerComponent: %w", err)
	}
	return oldValue.AgentWorkerComponent, nil
}

// ClearAgentWorkerComponent clears the value of the "agent_worker_component" field.
func (m *ServerMutation) ClearAgentWorkerComponent() {
	m.agent_worker_component = nil
	m.clearedFields[server.FieldAgentWorkerComponent] = struct{}{}
}

// AgentWorkerComponentCleared returns if the "agent_worker_component" field was cleared in this mutation.
func (m *ServerMutation) AgentWorkerComponentCleared() bool {
	_, ok := m.clearedFields[server.FieldAgentWorkerComponent]
	return ok
}

// ResetAgentWorkerComponent resets all changes to the "agent_worker_component" field.
func (m *ServerMutation) ResetAgentWorkerComponent() {
	m.agent_worker_component = nil
	delete(m.clearedFields, server.FieldAgentWorkerComponent)
}

// SetNotificationWorkerComponent sets the "notification_worker_component" field.
func (m *ServerMutation) SetNotificationWorkerComponent(b bool) {
	m.notification_worker_component = &b
}

// NotificationWorkerComponent returns the value of the "notification_worker_component" field in the mutation.
func (m *ServerMutation) NotificationWorkerComponent() (r bool, exists bool) {
	v := m.notification_worker_component
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationWorkerComponent returns the old "notification_worker_component" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldNotificationWorkerComponent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationWorkerComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationWorkerComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationWorkerComponent: %w", err)
	}
	return oldValue.NotificationWorkerComponent, nil
}

// ClearNotificationWorkerComponent clears the value of the "notification_worker_component" field.
func (m *ServerMutation) ClearNotificationWorkerComponent() {
	m.notification_worker_component = nil
	m.clearedFields[server.FieldNotificationWorkerComponent] = struct{}{}
}

// NotificationWorkerComponentCleared returns if the "notification_worker_component" field was cleared in this mutation.
func (m *ServerMutation) NotificationWorkerComponentCleared() bool {
	_, ok := m.clearedFields[server.FieldNotificationWorkerComponent]
	return ok
}

// ResetNotificationWorkerComponent resets all changes to the "notification_worker_component" field.
func (m *ServerMutation) ResetNotificationWorkerComponent() {
	m.notification_worker_component = nil
	delete(m.clearedFields, server.FieldNotificationWorkerComponent)
}

// SetCertManagerWorkerComponent sets the "cert_manager_worker_component" field.
func (m *ServerMutation) SetCertManagerWorkerComponent(b bool) {
	m.cert_manager_worker_component = &b
}

// CertManagerWorkerComponent returns the value of the "cert_manager_worker_component" field in the mutation.
func (m *ServerMutation) CertManagerWorkerComponent() (r bool, exists bool) {
	v := m.cert_manager_worker_component
	if v == nil {
		return
	}
	return *v, true
}

// OldCertManagerWorkerComponent returns the old "cert_manager_worker_component" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldCertManagerWorkerComponent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertManagerWorkerComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertManagerWorkerComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertManagerWorkerComponent: %w", err)
	}
	return oldValue.CertManagerWorkerComponent, nil
}

// ClearCertManagerWorkerComponent clears the value of the "cert_manager_worker_component" field.
func (m *ServerMutation) ClearCertManagerWorkerComponent() {
	m.cert_manager_worker_component = nil
	m.clearedFields[server.FieldCertManagerWorkerComponent] = struct{}{}
}

// CertManagerWorkerComponentCleared returns if the "cert_manager_worker_component" field was cleared in this mutation.
func (m *ServerMutation) CertManagerWorkerComponentCleared() bool {
	_, ok := m.clearedFields[server.FieldCertManagerWorkerComponent]
	return ok
}

// ResetCertManagerWorkerComponent resets all changes to the "cert_manager_worker_component" field.
func (m *ServerMutation) ResetCertManagerWorkerComponent() {
	m.cert_manager_worker_component = nil
	delete(m.clearedFields, server.FieldCertManagerWorkerComponent)
}

// Where appends a list predicates to the ServerMutation builder.
func (m *ServerMutation) Where(ps ...predicate.Server) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Server, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Server).
func (m *ServerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.hostname != nil {
		fields = append(fields, server.FieldHostname)
	}
	if m.arch != nil {
		fields = append(fields, server.FieldArch)
	}
	if m.os != nil {
		fields = append(fields, server.FieldOs)
	}
	if m.version != nil {
		fields = append(fields, server.FieldVersion)
	}
	if m.channel != nil {
		fields = append(fields, server.FieldChannel)
	}
	if m.update_status != nil {
		fields = append(fields, server.FieldUpdateStatus)
	}
	if m.update_message != nil {
		fields = append(fields, server.FieldUpdateMessage)
	}
	if m.update_when != nil {
		fields = append(fields, server.FieldUpdateWhen)
	}
	if m.nats_component != nil {
		fields = append(fields, server.FieldNatsComponent)
	}
	if m.ocsp_component != nil {
		fields = append(fields, server.FieldOcspComponent)
	}
	if m.console_component != nil {
		fields = append(fields, server.FieldConsoleComponent)
	}
	if m.agent_worker_component != nil {
		fields = append(fields, server.FieldAgentWorkerComponent)
	}
	if m.notification_worker_component != nil {
		fields = append(fields, server.FieldNotificationWorkerComponent)
	}
	if m.cert_manager_worker_component != nil {
		fields = append(fields, server.FieldCertManagerWorkerComponent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case server.FieldHostname:
		return m.Hostname()
	case server.FieldArch:
		return m.Arch()
	case server.FieldOs:
		return m.Os()
	case server.FieldVersion:
		return m.Version()
	case server.FieldChannel:
		return m.Channel()
	case server.FieldUpdateStatus:
		return m.UpdateStatus()
	case server.FieldUpdateMessage:
		return m.UpdateMessage()
	case server.FieldUpdateWhen:
		return m.UpdateWhen()
	case server.FieldNatsComponent:
		return m.NatsComponent()
	case server.FieldOcspComponent:
		return m.OcspComponent()
	case server.FieldConsoleComponent:
		return m.ConsoleComponent()
	case server.FieldAgentWorkerComponent:
		return m.AgentWorkerComponent()
	case server.FieldNotificationWorkerComponent:
		return m.NotificationWorkerComponent()
	case server.FieldCertManagerWorkerComponent:
		return m.CertManagerWorkerComponent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case server.FieldHostname:
		return m.OldHostname(ctx)
	case server.FieldArch:
		return m.OldArch(ctx)
	case server.FieldOs:
		return m.OldOs(ctx)
	case server.FieldVersion:
		return m.OldVersion(ctx)
	case server.FieldChannel:
		return m.OldChannel(ctx)
	case server.FieldUpdateStatus:
		return m.OldUpdateStatus(ctx)
	case server.FieldUpdateMessage:
		return m.OldUpdateMessage(ctx)
	case server.FieldUpdateWhen:
		return m.OldUpdateWhen(ctx)
	case server.FieldNatsComponent:
		return m.OldNatsComponent(ctx)
	case server.FieldOcspComponent:
		return m.OldOcspComponent(ctx)
	case server.FieldConsoleComponent:
		return m.OldConsoleComponent(ctx)
	case server.FieldAgentWorkerComponent:
		return m.OldAgentWorkerComponent(ctx)
	case server.FieldNotificationWorkerComponent:
		return m.OldNotificationWorkerComponent(ctx)
	case server.FieldCertManagerWorkerComponent:
		return m.OldCertManagerWorkerComponent(ctx)
	}
	return nil, fmt.Errorf("unknown Server field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case server.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case server.FieldArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	case server.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case server.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case server.FieldChannel:
		v, ok := value.(server.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case server.FieldUpdateStatus:
		v, ok := value.(server.UpdateStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateStatus(v)
		return nil
	case server.FieldUpdateMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateMessage(v)
		return nil
	case server.FieldUpdateWhen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateWhen(v)
		return nil
	case server.FieldNatsComponent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNatsComponent(v)
		return nil
	case server.FieldOcspComponent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOcspComponent(v)
		return nil
	case server.FieldConsoleComponent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsoleComponent(v)
		return nil
	case server.FieldAgentWorkerComponent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentWorkerComponent(v)
		return nil
	case server.FieldNotificationWorkerComponent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationWorkerComponent(v)
		return nil
	case server.FieldCertManagerWorkerComponent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertManagerWorkerComponent(v)
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Server numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(server.FieldUpdateStatus) {
		fields = append(fields, server.FieldUpdateStatus)
	}
	if m.FieldCleared(server.FieldUpdateMessage) {
		fields = append(fields, server.FieldUpdateMessage)
	}
	if m.FieldCleared(server.FieldUpdateWhen) {
		fields = append(fields, server.FieldUpdateWhen)
	}
	if m.FieldCleared(server.FieldNatsComponent) {
		fields = append(fields, server.FieldNatsComponent)
	}
	if m.FieldCleared(server.FieldOcspComponent) {
		fields = append(fields, server.FieldOcspComponent)
	}
	if m.FieldCleared(server.FieldConsoleComponent) {
		fields = append(fields, server.FieldConsoleComponent)
	}
	if m.FieldCleared(server.FieldAgentWorkerComponent) {
		fields = append(fields, server.FieldAgentWorkerComponent)
	}
	if m.FieldCleared(server.FieldNotificationWorkerComponent) {
		fields = append(fields, server.FieldNotificationWorkerComponent)
	}
	if m.FieldCleared(server.FieldCertManagerWorkerComponent) {
		fields = append(fields, server.FieldCertManagerWorkerComponent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMutation) ClearField(name string) error {
	switch name {
	case server.FieldUpdateStatus:
		m.ClearUpdateStatus()
		return nil
	case server.FieldUpdateMessage:
		m.ClearUpdateMessage()
		return nil
	case server.FieldUpdateWhen:
		m.ClearUpdateWhen()
		return nil
	case server.FieldNatsComponent:
		m.ClearNatsComponent()
		return nil
	case server.FieldOcspComponent:
		m.ClearOcspComponent()
		return nil
	case server.FieldConsoleComponent:
		m.ClearConsoleComponent()
		return nil
	case server.FieldAgentWorkerComponent:
		m.ClearAgentWorkerComponent()
		return nil
	case server.FieldNotificationWorkerComponent:
		m.ClearNotificationWorkerComponent()
		return nil
	case server.FieldCertManagerWorkerComponent:
		m.ClearCertManagerWorkerComponent()
		return nil
	}
	return fmt.Errorf("unknown Server nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerMutation) ResetField(name string) error {
	switch name {
	case server.FieldHostname:
		m.ResetHostname()
		return nil
	case server.FieldArch:
		m.ResetArch()
		return nil
	case server.FieldOs:
		m.ResetOs()
		return nil
	case server.FieldVersion:
		m.ResetVersion()
		return nil
	case server.FieldChannel:
		m.ResetChannel()
		return nil
	case server.FieldUpdateStatus:
		m.ResetUpdateStatus()
		return nil
	case server.FieldUpdateMessage:
		m.ResetUpdateMessage()
		return nil
	case server.FieldUpdateWhen:
		m.ResetUpdateWhen()
		return nil
	case server.FieldNatsComponent:
		m.ResetNatsComponent()
		return nil
	case server.FieldOcspComponent:
		m.ResetOcspComponent()
		return nil
	case server.FieldConsoleComponent:
		m.ResetConsoleComponent()
		return nil
	case server.FieldAgentWorkerComponent:
		m.ResetAgentWorkerComponent()
		return nil
	case server.FieldNotificationWorkerComponent:
		m.ResetNotificationWorkerComponent()
		return nil
	case server.FieldCertManagerWorkerComponent:
		m.ResetCertManagerWorkerComponent()
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Server unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Server edge %s", name)
}

// SessionsMutation represents an operation that mutates the Sessions nodes in the graph.
type SessionsMutation struct {
	config
	op            Op
	typ           string
	id            *string
	data          *[]byte
	expiry        *time.Time
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Sessions, error)
	predicates    []predicate.Sessions
}

var _ ent.Mutation = (*SessionsMutation)(nil)

// sessionsOption allows management of the mutation configuration using functional options.
type sessionsOption func(*SessionsMutation)

// newSessionsMutation creates new mutation for the Sessions entity.
func newSessionsMutation(c config, op Op, opts ...sessionsOption) *SessionsMutation {
	m := &SessionsMutation{
		config:        c,
		op:            op,
		typ:           TypeSessions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionsID sets the ID field of the mutation.
func withSessionsID(id string) sessionsOption {
	return func(m *SessionsMutation) {
		var (
			err   error
			once  sync.Once
			value *Sessions
		)
		m.oldValue = func(ctx context.Context) (*Sessions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sessions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSessions sets the old Sessions of the mutation.
func withSessions(node *Sessions) sessionsOption {
	return func(m *SessionsMutation) {
		m.oldValue = func(context.Context) (*Sessions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Sessions entities.
func (m *SessionsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Sessions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetData sets the "data" field.
func (m *SessionsMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *SessionsMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Sessions entity.
// If the Sessions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionsMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *SessionsMutation) ResetData() {
	m.data = nil
}

// SetExpiry sets the "expiry" field.
func (m *SessionsMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *SessionsMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Sessions entity.
// If the Sessions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionsMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *SessionsMutation) ResetExpiry() {
	m.expiry = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *SessionsMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *SessionsMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *SessionsMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *SessionsMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SessionsMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *SessionsMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the SessionsMutation builder.
func (m *SessionsMutation) Where(ps ...predicate.Sessions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Sessions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Sessions).
func (m *SessionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.data != nil {
		fields = append(fields, sessions.FieldData)
	}
	if m.expiry != nil {
		fields = append(fields, sessions.FieldExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sessions.FieldData:
		return m.Data()
	case sessions.FieldExpiry:
		return m.Expiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sessions.FieldData:
		return m.OldData(ctx)
	case sessions.FieldExpiry:
		return m.OldExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown Sessions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sessions.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case sessions.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown Sessions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Sessions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Sessions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionsMutation) ResetField(name string) error {
	switch name {
	case sessions.FieldData:
		m.ResetData()
		return nil
	case sessions.FieldExpiry:
		m.ResetExpiry()
		return nil
	}
	return fmt.Errorf("unknown Sessions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, sessions.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sessions.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, sessions.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionsMutation) EdgeCleared(name string) bool {
	switch name {
	case sessions.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionsMutation) ClearEdge(name string) error {
	switch name {
	case sessions.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Sessions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionsMutation) ResetEdge(name string) error {
	switch name {
	case sessions.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Sessions edge %s", name)
}

// SettingsMutation represents an operation that mutates the Settings nodes in the graph.
type SettingsMutation struct {
	config
	op                                           Op
	typ                                          string
	id                                           *int
	language                                     *string
	organization                                 *string
	postal_address                               *string
	postal_code                                  *string
	locality                                     *string
	province                                     *string
	state                                        *string
	country                                      *string
	smtp_server                                  *string
	smtp_port                                    *int
	addsmtp_port                                 *int
	smtp_user                                    *string
	smtp_password                                *string
	smtp_auth                                    *string
	smtp_tls                                     *bool
	smtp_starttls                                *bool
	nats_server                                  *string
	nats_port                                    *string
	message_from                                 *string
	max_upload_size                              *string
	user_cert_years_valid                        *int
	adduser_cert_years_valid                     *int
	nats_request_timeout_seconds                 *int
	addnats_request_timeout_seconds              *int
	refresh_time_in_minutes                      *int
	addrefresh_time_in_minutes                   *int
	session_lifetime_in_minutes                  *int
	addsession_lifetime_in_minutes               *int
	update_channel                               *string
	created                                      *time.Time
	modified                                     *time.Time
	agent_report_frequence_in_minutes            *int
	addagent_report_frequence_in_minutes         *int
	request_vnc_pin                              *bool
	profiles_application_frequence_in_minutes    *int
	addprofiles_application_frequence_in_minutes *int
	use_winget                                   *bool
	use_flatpak                                  *bool
	use_brew                                     *bool
	disable_sftp                                 *bool
	disable_remote_assistance                    *bool
	detect_remote_agents                         *bool
	auto_admit_agents                            *bool
	default_items_per_page                       *int
	adddefault_items_per_page                    *int
	clearedFields                                map[string]struct{}
	tag                                          *int
	clearedtag                                   bool
	tenant                                       *int
	clearedtenant                                bool
	done                                         bool
	oldValue                                     func(context.Context) (*Settings, error)
	predicates                                   []predicate.Settings
}

var _ ent.Mutation = (*SettingsMutation)(nil)

// settingsOption allows management of the mutation configuration using functional options.
type settingsOption func(*SettingsMutation)

// newSettingsMutation creates new mutation for the Settings entity.
func newSettingsMutation(c config, op Op, opts ...settingsOption) *SettingsMutation {
	m := &SettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingsID sets the ID field of the mutation.
func withSettingsID(id int) settingsOption {
	return func(m *SettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Settings
		)
		m.oldValue = func(ctx context.Context) (*Settings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettings sets the old Settings of the mutation.
func withSettings(node *Settings) settingsOption {
	return func(m *SettingsMutation) {
		m.oldValue = func(context.Context) (*Settings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Settings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLanguage sets the "language" field.
func (m *SettingsMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *SettingsMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *SettingsMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[settings.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *SettingsMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[settings.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *SettingsMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, settings.FieldLanguage)
}

// SetOrganization sets the "organization" field.
func (m *SettingsMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *SettingsMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ClearOrganization clears the value of the "organization" field.
func (m *SettingsMutation) ClearOrganization() {
	m.organization = nil
	m.clearedFields[settings.FieldOrganization] = struct{}{}
}

// OrganizationCleared returns if the "organization" field was cleared in this mutation.
func (m *SettingsMutation) OrganizationCleared() bool {
	_, ok := m.clearedFields[settings.FieldOrganization]
	return ok
}

// ResetOrganization resets all changes to the "organization" field.
func (m *SettingsMutation) ResetOrganization() {
	m.organization = nil
	delete(m.clearedFields, settings.FieldOrganization)
}

// SetPostalAddress sets the "postal_address" field.
func (m *SettingsMutation) SetPostalAddress(s string) {
	m.postal_address = &s
}

// PostalAddress returns the value of the "postal_address" field in the mutation.
func (m *SettingsMutation) PostalAddress() (r string, exists bool) {
	v := m.postal_address
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalAddress returns the old "postal_address" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldPostalAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalAddress: %w", err)
	}
	return oldValue.PostalAddress, nil
}

// ClearPostalAddress clears the value of the "postal_address" field.
func (m *SettingsMutation) ClearPostalAddress() {
	m.postal_address = nil
	m.clearedFields[settings.FieldPostalAddress] = struct{}{}
}

// PostalAddressCleared returns if the "postal_address" field was cleared in this mutation.
func (m *SettingsMutation) PostalAddressCleared() bool {
	_, ok := m.clearedFields[settings.FieldPostalAddress]
	return ok
}

// ResetPostalAddress resets all changes to the "postal_address" field.
func (m *SettingsMutation) ResetPostalAddress() {
	m.postal_address = nil
	delete(m.clearedFields, settings.FieldPostalAddress)
}

// SetPostalCode sets the "postal_code" field.
func (m *SettingsMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *SettingsMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *SettingsMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[settings.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *SettingsMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[settings.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *SettingsMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, settings.FieldPostalCode)
}

// SetLocality sets the "locality" field.
func (m *SettingsMutation) SetLocality(s string) {
	m.locality = &s
}

// Locality returns the value of the "locality" field in the mutation.
func (m *SettingsMutation) Locality() (r string, exists bool) {
	v := m.locality
	if v == nil {
		return
	}
	return *v, true
}

// OldLocality returns the old "locality" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldLocality(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocality: %w", err)
	}
	return oldValue.Locality, nil
}

// ClearLocality clears the value of the "locality" field.
func (m *SettingsMutation) ClearLocality() {
	m.locality = nil
	m.clearedFields[settings.FieldLocality] = struct{}{}
}

// LocalityCleared returns if the "locality" field was cleared in this mutation.
func (m *SettingsMutation) LocalityCleared() bool {
	_, ok := m.clearedFields[settings.FieldLocality]
	return ok
}

// ResetLocality resets all changes to the "locality" field.
func (m *SettingsMutation) ResetLocality() {
	m.locality = nil
	delete(m.clearedFields, settings.FieldLocality)
}

// SetProvince sets the "province" field.
func (m *SettingsMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *SettingsMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *SettingsMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[settings.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *SettingsMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[settings.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *SettingsMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, settings.FieldProvince)
}

// SetState sets the "state" field.
func (m *SettingsMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *SettingsMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *SettingsMutation) ClearState() {
	m.state = nil
	m.clearedFields[settings.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *SettingsMutation) StateCleared() bool {
	_, ok := m.clearedFields[settings.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *SettingsMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, settings.FieldState)
}

// SetCountry sets the "country" field.
func (m *SettingsMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *SettingsMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *SettingsMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[settings.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *SettingsMutation) CountryCleared() bool {
	_, ok := m.clearedFields[settings.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *SettingsMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, settings.FieldCountry)
}

// SetSMTPServer sets the "smtp_server" field.
func (m *SettingsMutation) SetSMTPServer(s string) {
	m.smtp_server = &s
}

// SMTPServer returns the value of the "smtp_server" field in the mutation.
func (m *SettingsMutation) SMTPServer() (r string, exists bool) {
	v := m.smtp_server
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPServer returns the old "smtp_server" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPServer: %w", err)
	}
	return oldValue.SMTPServer, nil
}

// ClearSMTPServer clears the value of the "smtp_server" field.
func (m *SettingsMutation) ClearSMTPServer() {
	m.smtp_server = nil
	m.clearedFields[settings.FieldSMTPServer] = struct{}{}
}

// SMTPServerCleared returns if the "smtp_server" field was cleared in this mutation.
func (m *SettingsMutation) SMTPServerCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPServer]
	return ok
}

// ResetSMTPServer resets all changes to the "smtp_server" field.
func (m *SettingsMutation) ResetSMTPServer() {
	m.smtp_server = nil
	delete(m.clearedFields, settings.FieldSMTPServer)
}

// SetSMTPPort sets the "smtp_port" field.
func (m *SettingsMutation) SetSMTPPort(i int) {
	m.smtp_port = &i
	m.addsmtp_port = nil
}

// SMTPPort returns the value of the "smtp_port" field in the mutation.
func (m *SettingsMutation) SMTPPort() (r int, exists bool) {
	v := m.smtp_port
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPPort returns the old "smtp_port" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPPort: %w", err)
	}
	return oldValue.SMTPPort, nil
}

// AddSMTPPort adds i to the "smtp_port" field.
func (m *SettingsMutation) AddSMTPPort(i int) {
	if m.addsmtp_port != nil {
		*m.addsmtp_port += i
	} else {
		m.addsmtp_port = &i
	}
}

// AddedSMTPPort returns the value that was added to the "smtp_port" field in this mutation.
func (m *SettingsMutation) AddedSMTPPort() (r int, exists bool) {
	v := m.addsmtp_port
	if v == nil {
		return
	}
	return *v, true
}

// ClearSMTPPort clears the value of the "smtp_port" field.
func (m *SettingsMutation) ClearSMTPPort() {
	m.smtp_port = nil
	m.addsmtp_port = nil
	m.clearedFields[settings.FieldSMTPPort] = struct{}{}
}

// SMTPPortCleared returns if the "smtp_port" field was cleared in this mutation.
func (m *SettingsMutation) SMTPPortCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPPort]
	return ok
}

// ResetSMTPPort resets all changes to the "smtp_port" field.
func (m *SettingsMutation) ResetSMTPPort() {
	m.smtp_port = nil
	m.addsmtp_port = nil
	delete(m.clearedFields, settings.FieldSMTPPort)
}

// SetSMTPUser sets the "smtp_user" field.
func (m *SettingsMutation) SetSMTPUser(s string) {
	m.smtp_user = &s
}

// SMTPUser returns the value of the "smtp_user" field in the mutation.
func (m *SettingsMutation) SMTPUser() (r string, exists bool) {
	v := m.smtp_user
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPUser returns the old "smtp_user" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPUser: %w", err)
	}
	return oldValue.SMTPUser, nil
}

// ClearSMTPUser clears the value of the "smtp_user" field.
func (m *SettingsMutation) ClearSMTPUser() {
	m.smtp_user = nil
	m.clearedFields[settings.FieldSMTPUser] = struct{}{}
}

// SMTPUserCleared returns if the "smtp_user" field was cleared in this mutation.
func (m *SettingsMutation) SMTPUserCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPUser]
	return ok
}

// ResetSMTPUser resets all changes to the "smtp_user" field.
func (m *SettingsMutation) ResetSMTPUser() {
	m.smtp_user = nil
	delete(m.clearedFields, settings.FieldSMTPUser)
}

// SetSMTPPassword sets the "smtp_password" field.
func (m *SettingsMutation) SetSMTPPassword(s string) {
	m.smtp_password = &s
}

// SMTPPassword returns the value of the "smtp_password" field in the mutation.
func (m *SettingsMutation) SMTPPassword() (r string, exists bool) {
	v := m.smtp_password
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPPassword returns the old "smtp_password" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPPassword: %w", err)
	}
	return oldValue.SMTPPassword, nil
}

// ClearSMTPPassword clears the value of the "smtp_password" field.
func (m *SettingsMutation) ClearSMTPPassword() {
	m.smtp_password = nil
	m.clearedFields[settings.FieldSMTPPassword] = struct{}{}
}

// SMTPPasswordCleared returns if the "smtp_password" field was cleared in this mutation.
func (m *SettingsMutation) SMTPPasswordCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPPassword]
	return ok
}

// ResetSMTPPassword resets all changes to the "smtp_password" field.
func (m *SettingsMutation) ResetSMTPPassword() {
	m.smtp_password = nil
	delete(m.clearedFields, settings.FieldSMTPPassword)
}

// SetSMTPAuth sets the "smtp_auth" field.
func (m *SettingsMutation) SetSMTPAuth(s string) {
	m.smtp_auth = &s
}

// SMTPAuth returns the value of the "smtp_auth" field in the mutation.
func (m *SettingsMutation) SMTPAuth() (r string, exists bool) {
	v := m.smtp_auth
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPAuth returns the old "smtp_auth" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPAuth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPAuth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPAuth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPAuth: %w", err)
	}
	return oldValue.SMTPAuth, nil
}

// ClearSMTPAuth clears the value of the "smtp_auth" field.
func (m *SettingsMutation) ClearSMTPAuth() {
	m.smtp_auth = nil
	m.clearedFields[settings.FieldSMTPAuth] = struct{}{}
}

// SMTPAuthCleared returns if the "smtp_auth" field was cleared in this mutation.
func (m *SettingsMutation) SMTPAuthCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPAuth]
	return ok
}

// ResetSMTPAuth resets all changes to the "smtp_auth" field.
func (m *SettingsMutation) ResetSMTPAuth() {
	m.smtp_auth = nil
	delete(m.clearedFields, settings.FieldSMTPAuth)
}

// SetSMTPTLS sets the "smtp_tls" field.
func (m *SettingsMutation) SetSMTPTLS(b bool) {
	m.smtp_tls = &b
}

// SMTPTLS returns the value of the "smtp_tls" field in the mutation.
func (m *SettingsMutation) SMTPTLS() (r bool, exists bool) {
	v := m.smtp_tls
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPTLS returns the old "smtp_tls" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPTLS(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPTLS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPTLS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPTLS: %w", err)
	}
	return oldValue.SMTPTLS, nil
}

// ClearSMTPTLS clears the value of the "smtp_tls" field.
func (m *SettingsMutation) ClearSMTPTLS() {
	m.smtp_tls = nil
	m.clearedFields[settings.FieldSMTPTLS] = struct{}{}
}

// SMTPTLSCleared returns if the "smtp_tls" field was cleared in this mutation.
func (m *SettingsMutation) SMTPTLSCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPTLS]
	return ok
}

// ResetSMTPTLS resets all changes to the "smtp_tls" field.
func (m *SettingsMutation) ResetSMTPTLS() {
	m.smtp_tls = nil
	delete(m.clearedFields, settings.FieldSMTPTLS)
}

// SetSMTPStarttls sets the "smtp_starttls" field.
func (m *SettingsMutation) SetSMTPStarttls(b bool) {
	m.smtp_starttls = &b
}

// SMTPStarttls returns the value of the "smtp_starttls" field in the mutation.
func (m *SettingsMutation) SMTPStarttls() (r bool, exists bool) {
	v := m.smtp_starttls
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPStarttls returns the old "smtp_starttls" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPStarttls(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPStarttls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPStarttls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPStarttls: %w", err)
	}
	return oldValue.SMTPStarttls, nil
}

// ClearSMTPStarttls clears the value of the "smtp_starttls" field.
func (m *SettingsMutation) ClearSMTPStarttls() {
	m.smtp_starttls = nil
	m.clearedFields[settings.FieldSMTPStarttls] = struct{}{}
}

// SMTPStarttlsCleared returns if the "smtp_starttls" field was cleared in this mutation.
func (m *SettingsMutation) SMTPStarttlsCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPStarttls]
	return ok
}

// ResetSMTPStarttls resets all changes to the "smtp_starttls" field.
func (m *SettingsMutation) ResetSMTPStarttls() {
	m.smtp_starttls = nil
	delete(m.clearedFields, settings.FieldSMTPStarttls)
}

// SetNatsServer sets the "nats_server" field.
func (m *SettingsMutation) SetNatsServer(s string) {
	m.nats_server = &s
}

// NatsServer returns the value of the "nats_server" field in the mutation.
func (m *SettingsMutation) NatsServer() (r string, exists bool) {
	v := m.nats_server
	if v == nil {
		return
	}
	return *v, true
}

// OldNatsServer returns the old "nats_server" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldNatsServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNatsServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNatsServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNatsServer: %w", err)
	}
	return oldValue.NatsServer, nil
}

// ClearNatsServer clears the value of the "nats_server" field.
func (m *SettingsMutation) ClearNatsServer() {
	m.nats_server = nil
	m.clearedFields[settings.FieldNatsServer] = struct{}{}
}

// NatsServerCleared returns if the "nats_server" field was cleared in this mutation.
func (m *SettingsMutation) NatsServerCleared() bool {
	_, ok := m.clearedFields[settings.FieldNatsServer]
	return ok
}

// ResetNatsServer resets all changes to the "nats_server" field.
func (m *SettingsMutation) ResetNatsServer() {
	m.nats_server = nil
	delete(m.clearedFields, settings.FieldNatsServer)
}

// SetNatsPort sets the "nats_port" field.
func (m *SettingsMutation) SetNatsPort(s string) {
	m.nats_port = &s
}

// NatsPort returns the value of the "nats_port" field in the mutation.
func (m *SettingsMutation) NatsPort() (r string, exists bool) {
	v := m.nats_port
	if v == nil {
		return
	}
	return *v, true
}

// OldNatsPort returns the old "nats_port" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldNatsPort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNatsPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNatsPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNatsPort: %w", err)
	}
	return oldValue.NatsPort, nil
}

// ClearNatsPort clears the value of the "nats_port" field.
func (m *SettingsMutation) ClearNatsPort() {
	m.nats_port = nil
	m.clearedFields[settings.FieldNatsPort] = struct{}{}
}

// NatsPortCleared returns if the "nats_port" field was cleared in this mutation.
func (m *SettingsMutation) NatsPortCleared() bool {
	_, ok := m.clearedFields[settings.FieldNatsPort]
	return ok
}

// ResetNatsPort resets all changes to the "nats_port" field.
func (m *SettingsMutation) ResetNatsPort() {
	m.nats_port = nil
	delete(m.clearedFields, settings.FieldNatsPort)
}

// SetMessageFrom sets the "message_from" field.
func (m *SettingsMutation) SetMessageFrom(s string) {
	m.message_from = &s
}

// MessageFrom returns the value of the "message_from" field in the mutation.
func (m *SettingsMutation) MessageFrom() (r string, exists bool) {
	v := m.message_from
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageFrom returns the old "message_from" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldMessageFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageFrom: %w", err)
	}
	return oldValue.MessageFrom, nil
}

// ClearMessageFrom clears the value of the "message_from" field.
func (m *SettingsMutation) ClearMessageFrom() {
	m.message_from = nil
	m.clearedFields[settings.FieldMessageFrom] = struct{}{}
}

// MessageFromCleared returns if the "message_from" field was cleared in this mutation.
func (m *SettingsMutation) MessageFromCleared() bool {
	_, ok := m.clearedFields[settings.FieldMessageFrom]
	return ok
}

// ResetMessageFrom resets all changes to the "message_from" field.
func (m *SettingsMutation) ResetMessageFrom() {
	m.message_from = nil
	delete(m.clearedFields, settings.FieldMessageFrom)
}

// SetMaxUploadSize sets the "max_upload_size" field.
func (m *SettingsMutation) SetMaxUploadSize(s string) {
	m.max_upload_size = &s
}

// MaxUploadSize returns the value of the "max_upload_size" field in the mutation.
func (m *SettingsMutation) MaxUploadSize() (r string, exists bool) {
	v := m.max_upload_size
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxUploadSize returns the old "max_upload_size" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldMaxUploadSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxUploadSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxUploadSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxUploadSize: %w", err)
	}
	return oldValue.MaxUploadSize, nil
}

// ClearMaxUploadSize clears the value of the "max_upload_size" field.
func (m *SettingsMutation) ClearMaxUploadSize() {
	m.max_upload_size = nil
	m.clearedFields[settings.FieldMaxUploadSize] = struct{}{}
}

// MaxUploadSizeCleared returns if the "max_upload_size" field was cleared in this mutation.
func (m *SettingsMutation) MaxUploadSizeCleared() bool {
	_, ok := m.clearedFields[settings.FieldMaxUploadSize]
	return ok
}

// ResetMaxUploadSize resets all changes to the "max_upload_size" field.
func (m *SettingsMutation) ResetMaxUploadSize() {
	m.max_upload_size = nil
	delete(m.clearedFields, settings.FieldMaxUploadSize)
}

// SetUserCertYearsValid sets the "user_cert_years_valid" field.
func (m *SettingsMutation) SetUserCertYearsValid(i int) {
	m.user_cert_years_valid = &i
	m.adduser_cert_years_valid = nil
}

// UserCertYearsValid returns the value of the "user_cert_years_valid" field in the mutation.
func (m *SettingsMutation) UserCertYearsValid() (r int, exists bool) {
	v := m.user_cert_years_valid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCertYearsValid returns the old "user_cert_years_valid" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUserCertYearsValid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCertYearsValid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCertYearsValid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCertYearsValid: %w", err)
	}
	return oldValue.UserCertYearsValid, nil
}

// AddUserCertYearsValid adds i to the "user_cert_years_valid" field.
func (m *SettingsMutation) AddUserCertYearsValid(i int) {
	if m.adduser_cert_years_valid != nil {
		*m.adduser_cert_years_valid += i
	} else {
		m.adduser_cert_years_valid = &i
	}
}

// AddedUserCertYearsValid returns the value that was added to the "user_cert_years_valid" field in this mutation.
func (m *SettingsMutation) AddedUserCertYearsValid() (r int, exists bool) {
	v := m.adduser_cert_years_valid
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserCertYearsValid clears the value of the "user_cert_years_valid" field.
func (m *SettingsMutation) ClearUserCertYearsValid() {
	m.user_cert_years_valid = nil
	m.adduser_cert_years_valid = nil
	m.clearedFields[settings.FieldUserCertYearsValid] = struct{}{}
}

// UserCertYearsValidCleared returns if the "user_cert_years_valid" field was cleared in this mutation.
func (m *SettingsMutation) UserCertYearsValidCleared() bool {
	_, ok := m.clearedFields[settings.FieldUserCertYearsValid]
	return ok
}

// ResetUserCertYearsValid resets all changes to the "user_cert_years_valid" field.
func (m *SettingsMutation) ResetUserCertYearsValid() {
	m.user_cert_years_valid = nil
	m.adduser_cert_years_valid = nil
	delete(m.clearedFields, settings.FieldUserCertYearsValid)
}

// SetNatsRequestTimeoutSeconds sets the "nats_request_timeout_seconds" field.
func (m *SettingsMutation) SetNatsRequestTimeoutSeconds(i int) {
	m.nats_request_timeout_seconds = &i
	m.addnats_request_timeout_seconds = nil
}

// NatsRequestTimeoutSeconds returns the value of the "nats_request_timeout_seconds" field in the mutation.
func (m *SettingsMutation) NatsRequestTimeoutSeconds() (r int, exists bool) {
	v := m.nats_request_timeout_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldNatsRequestTimeoutSeconds returns the old "nats_request_timeout_seconds" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldNatsRequestTimeoutSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNatsRequestTimeoutSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNatsRequestTimeoutSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNatsRequestTimeoutSeconds: %w", err)
	}
	return oldValue.NatsRequestTimeoutSeconds, nil
}

// AddNatsRequestTimeoutSeconds adds i to the "nats_request_timeout_seconds" field.
func (m *SettingsMutation) AddNatsRequestTimeoutSeconds(i int) {
	if m.addnats_request_timeout_seconds != nil {
		*m.addnats_request_timeout_seconds += i
	} else {
		m.addnats_request_timeout_seconds = &i
	}
}

// AddedNatsRequestTimeoutSeconds returns the value that was added to the "nats_request_timeout_seconds" field in this mutation.
func (m *SettingsMutation) AddedNatsRequestTimeoutSeconds() (r int, exists bool) {
	v := m.addnats_request_timeout_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearNatsRequestTimeoutSeconds clears the value of the "nats_request_timeout_seconds" field.
func (m *SettingsMutation) ClearNatsRequestTimeoutSeconds() {
	m.nats_request_timeout_seconds = nil
	m.addnats_request_timeout_seconds = nil
	m.clearedFields[settings.FieldNatsRequestTimeoutSeconds] = struct{}{}
}

// NatsRequestTimeoutSecondsCleared returns if the "nats_request_timeout_seconds" field was cleared in this mutation.
func (m *SettingsMutation) NatsRequestTimeoutSecondsCleared() bool {
	_, ok := m.clearedFields[settings.FieldNatsRequestTimeoutSeconds]
	return ok
}

// ResetNatsRequestTimeoutSeconds resets all changes to the "nats_request_timeout_seconds" field.
func (m *SettingsMutation) ResetNatsRequestTimeoutSeconds() {
	m.nats_request_timeout_seconds = nil
	m.addnats_request_timeout_seconds = nil
	delete(m.clearedFields, settings.FieldNatsRequestTimeoutSeconds)
}

// SetRefreshTimeInMinutes sets the "refresh_time_in_minutes" field.
func (m *SettingsMutation) SetRefreshTimeInMinutes(i int) {
	m.refresh_time_in_minutes = &i
	m.addrefresh_time_in_minutes = nil
}

// RefreshTimeInMinutes returns the value of the "refresh_time_in_minutes" field in the mutation.
func (m *SettingsMutation) RefreshTimeInMinutes() (r int, exists bool) {
	v := m.refresh_time_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTimeInMinutes returns the old "refresh_time_in_minutes" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldRefreshTimeInMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTimeInMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTimeInMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTimeInMinutes: %w", err)
	}
	return oldValue.RefreshTimeInMinutes, nil
}

// AddRefreshTimeInMinutes adds i to the "refresh_time_in_minutes" field.
func (m *SettingsMutation) AddRefreshTimeInMinutes(i int) {
	if m.addrefresh_time_in_minutes != nil {
		*m.addrefresh_time_in_minutes += i
	} else {
		m.addrefresh_time_in_minutes = &i
	}
}

// AddedRefreshTimeInMinutes returns the value that was added to the "refresh_time_in_minutes" field in this mutation.
func (m *SettingsMutation) AddedRefreshTimeInMinutes() (r int, exists bool) {
	v := m.addrefresh_time_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ClearRefreshTimeInMinutes clears the value of the "refresh_time_in_minutes" field.
func (m *SettingsMutation) ClearRefreshTimeInMinutes() {
	m.refresh_time_in_minutes = nil
	m.addrefresh_time_in_minutes = nil
	m.clearedFields[settings.FieldRefreshTimeInMinutes] = struct{}{}
}

// RefreshTimeInMinutesCleared returns if the "refresh_time_in_minutes" field was cleared in this mutation.
func (m *SettingsMutation) RefreshTimeInMinutesCleared() bool {
	_, ok := m.clearedFields[settings.FieldRefreshTimeInMinutes]
	return ok
}

// ResetRefreshTimeInMinutes resets all changes to the "refresh_time_in_minutes" field.
func (m *SettingsMutation) ResetRefreshTimeInMinutes() {
	m.refresh_time_in_minutes = nil
	m.addrefresh_time_in_minutes = nil
	delete(m.clearedFields, settings.FieldRefreshTimeInMinutes)
}

// SetSessionLifetimeInMinutes sets the "session_lifetime_in_minutes" field.
func (m *SettingsMutation) SetSessionLifetimeInMinutes(i int) {
	m.session_lifetime_in_minutes = &i
	m.addsession_lifetime_in_minutes = nil
}

// SessionLifetimeInMinutes returns the value of the "session_lifetime_in_minutes" field in the mutation.
func (m *SettingsMutation) SessionLifetimeInMinutes() (r int, exists bool) {
	v := m.session_lifetime_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionLifetimeInMinutes returns the old "session_lifetime_in_minutes" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSessionLifetimeInMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionLifetimeInMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionLifetimeInMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionLifetimeInMinutes: %w", err)
	}
	return oldValue.SessionLifetimeInMinutes, nil
}

// AddSessionLifetimeInMinutes adds i to the "session_lifetime_in_minutes" field.
func (m *SettingsMutation) AddSessionLifetimeInMinutes(i int) {
	if m.addsession_lifetime_in_minutes != nil {
		*m.addsession_lifetime_in_minutes += i
	} else {
		m.addsession_lifetime_in_minutes = &i
	}
}

// AddedSessionLifetimeInMinutes returns the value that was added to the "session_lifetime_in_minutes" field in this mutation.
func (m *SettingsMutation) AddedSessionLifetimeInMinutes() (r int, exists bool) {
	v := m.addsession_lifetime_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSessionLifetimeInMinutes clears the value of the "session_lifetime_in_minutes" field.
func (m *SettingsMutation) ClearSessionLifetimeInMinutes() {
	m.session_lifetime_in_minutes = nil
	m.addsession_lifetime_in_minutes = nil
	m.clearedFields[settings.FieldSessionLifetimeInMinutes] = struct{}{}
}

// SessionLifetimeInMinutesCleared returns if the "session_lifetime_in_minutes" field was cleared in this mutation.
func (m *SettingsMutation) SessionLifetimeInMinutesCleared() bool {
	_, ok := m.clearedFields[settings.FieldSessionLifetimeInMinutes]
	return ok
}

// ResetSessionLifetimeInMinutes resets all changes to the "session_lifetime_in_minutes" field.
func (m *SettingsMutation) ResetSessionLifetimeInMinutes() {
	m.session_lifetime_in_minutes = nil
	m.addsession_lifetime_in_minutes = nil
	delete(m.clearedFields, settings.FieldSessionLifetimeInMinutes)
}

// SetUpdateChannel sets the "update_channel" field.
func (m *SettingsMutation) SetUpdateChannel(s string) {
	m.update_channel = &s
}

// UpdateChannel returns the value of the "update_channel" field in the mutation.
func (m *SettingsMutation) UpdateChannel() (r string, exists bool) {
	v := m.update_channel
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateChannel returns the old "update_channel" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUpdateChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateChannel: %w", err)
	}
	return oldValue.UpdateChannel, nil
}

// ClearUpdateChannel clears the value of the "update_channel" field.
func (m *SettingsMutation) ClearUpdateChannel() {
	m.update_channel = nil
	m.clearedFields[settings.FieldUpdateChannel] = struct{}{}
}

// UpdateChannelCleared returns if the "update_channel" field was cleared in this mutation.
func (m *SettingsMutation) UpdateChannelCleared() bool {
	_, ok := m.clearedFields[settings.FieldUpdateChannel]
	return ok
}

// ResetUpdateChannel resets all changes to the "update_channel" field.
func (m *SettingsMutation) ResetUpdateChannel() {
	m.update_channel = nil
	delete(m.clearedFields, settings.FieldUpdateChannel)
}

// SetCreated sets the "created" field.
func (m *SettingsMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *SettingsMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ClearCreated clears the value of the "created" field.
func (m *SettingsMutation) ClearCreated() {
	m.created = nil
	m.clearedFields[settings.FieldCreated] = struct{}{}
}

// CreatedCleared returns if the "created" field was cleared in this mutation.
func (m *SettingsMutation) CreatedCleared() bool {
	_, ok := m.clearedFields[settings.FieldCreated]
	return ok
}

// ResetCreated resets all changes to the "created" field.
func (m *SettingsMutation) ResetCreated() {
	m.created = nil
	delete(m.clearedFields, settings.FieldCreated)
}

// SetModified sets the "modified" field.
func (m *SettingsMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *SettingsMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ClearModified clears the value of the "modified" field.
func (m *SettingsMutation) ClearModified() {
	m.modified = nil
	m.clearedFields[settings.FieldModified] = struct{}{}
}

// ModifiedCleared returns if the "modified" field was cleared in this mutation.
func (m *SettingsMutation) ModifiedCleared() bool {
	_, ok := m.clearedFields[settings.FieldModified]
	return ok
}

// ResetModified resets all changes to the "modified" field.
func (m *SettingsMutation) ResetModified() {
	m.modified = nil
	delete(m.clearedFields, settings.FieldModified)
}

// SetAgentReportFrequenceInMinutes sets the "agent_report_frequence_in_minutes" field.
func (m *SettingsMutation) SetAgentReportFrequenceInMinutes(i int) {
	m.agent_report_frequence_in_minutes = &i
	m.addagent_report_frequence_in_minutes = nil
}

// AgentReportFrequenceInMinutes returns the value of the "agent_report_frequence_in_minutes" field in the mutation.
func (m *SettingsMutation) AgentReportFrequenceInMinutes() (r int, exists bool) {
	v := m.agent_report_frequence_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentReportFrequenceInMinutes returns the old "agent_report_frequence_in_minutes" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldAgentReportFrequenceInMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentReportFrequenceInMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentReportFrequenceInMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentReportFrequenceInMinutes: %w", err)
	}
	return oldValue.AgentReportFrequenceInMinutes, nil
}

// AddAgentReportFrequenceInMinutes adds i to the "agent_report_frequence_in_minutes" field.
func (m *SettingsMutation) AddAgentReportFrequenceInMinutes(i int) {
	if m.addagent_report_frequence_in_minutes != nil {
		*m.addagent_report_frequence_in_minutes += i
	} else {
		m.addagent_report_frequence_in_minutes = &i
	}
}

// AddedAgentReportFrequenceInMinutes returns the value that was added to the "agent_report_frequence_in_minutes" field in this mutation.
func (m *SettingsMutation) AddedAgentReportFrequenceInMinutes() (r int, exists bool) {
	v := m.addagent_report_frequence_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ClearAgentReportFrequenceInMinutes clears the value of the "agent_report_frequence_in_minutes" field.
func (m *SettingsMutation) ClearAgentReportFrequenceInMinutes() {
	m.agent_report_frequence_in_minutes = nil
	m.addagent_report_frequence_in_minutes = nil
	m.clearedFields[settings.FieldAgentReportFrequenceInMinutes] = struct{}{}
}

// AgentReportFrequenceInMinutesCleared returns if the "agent_report_frequence_in_minutes" field was cleared in this mutation.
func (m *SettingsMutation) AgentReportFrequenceInMinutesCleared() bool {
	_, ok := m.clearedFields[settings.FieldAgentReportFrequenceInMinutes]
	return ok
}

// ResetAgentReportFrequenceInMinutes resets all changes to the "agent_report_frequence_in_minutes" field.
func (m *SettingsMutation) ResetAgentReportFrequenceInMinutes() {
	m.agent_report_frequence_in_minutes = nil
	m.addagent_report_frequence_in_minutes = nil
	delete(m.clearedFields, settings.FieldAgentReportFrequenceInMinutes)
}

// SetRequestVncPin sets the "request_vnc_pin" field.
func (m *SettingsMutation) SetRequestVncPin(b bool) {
	m.request_vnc_pin = &b
}

// RequestVncPin returns the value of the "request_vnc_pin" field in the mutation.
func (m *SettingsMutation) RequestVncPin() (r bool, exists bool) {
	v := m.request_vnc_pin
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestVncPin returns the old "request_vnc_pin" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldRequestVncPin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestVncPin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestVncPin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestVncPin: %w", err)
	}
	return oldValue.RequestVncPin, nil
}

// ClearRequestVncPin clears the value of the "request_vnc_pin" field.
func (m *SettingsMutation) ClearRequestVncPin() {
	m.request_vnc_pin = nil
	m.clearedFields[settings.FieldRequestVncPin] = struct{}{}
}

// RequestVncPinCleared returns if the "request_vnc_pin" field was cleared in this mutation.
func (m *SettingsMutation) RequestVncPinCleared() bool {
	_, ok := m.clearedFields[settings.FieldRequestVncPin]
	return ok
}

// ResetRequestVncPin resets all changes to the "request_vnc_pin" field.
func (m *SettingsMutation) ResetRequestVncPin() {
	m.request_vnc_pin = nil
	delete(m.clearedFields, settings.FieldRequestVncPin)
}

// SetProfilesApplicationFrequenceInMinutes sets the "profiles_application_frequence_in_minutes" field.
func (m *SettingsMutation) SetProfilesApplicationFrequenceInMinutes(i int) {
	m.profiles_application_frequence_in_minutes = &i
	m.addprofiles_application_frequence_in_minutes = nil
}

// ProfilesApplicationFrequenceInMinutes returns the value of the "profiles_application_frequence_in_minutes" field in the mutation.
func (m *SettingsMutation) ProfilesApplicationFrequenceInMinutes() (r int, exists bool) {
	v := m.profiles_application_frequence_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilesApplicationFrequenceInMinutes returns the old "profiles_application_frequence_in_minutes" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldProfilesApplicationFrequenceInMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilesApplicationFrequenceInMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilesApplicationFrequenceInMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilesApplicationFrequenceInMinutes: %w", err)
	}
	return oldValue.ProfilesApplicationFrequenceInMinutes, nil
}

// AddProfilesApplicationFrequenceInMinutes adds i to the "profiles_application_frequence_in_minutes" field.
func (m *SettingsMutation) AddProfilesApplicationFrequenceInMinutes(i int) {
	if m.addprofiles_application_frequence_in_minutes != nil {
		*m.addprofiles_application_frequence_in_minutes += i
	} else {
		m.addprofiles_application_frequence_in_minutes = &i
	}
}

// AddedProfilesApplicationFrequenceInMinutes returns the value that was added to the "profiles_application_frequence_in_minutes" field in this mutation.
func (m *SettingsMutation) AddedProfilesApplicationFrequenceInMinutes() (r int, exists bool) {
	v := m.addprofiles_application_frequence_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ClearProfilesApplicationFrequenceInMinutes clears the value of the "profiles_application_frequence_in_minutes" field.
func (m *SettingsMutation) ClearProfilesApplicationFrequenceInMinutes() {
	m.profiles_application_frequence_in_minutes = nil
	m.addprofiles_application_frequence_in_minutes = nil
	m.clearedFields[settings.FieldProfilesApplicationFrequenceInMinutes] = struct{}{}
}

// ProfilesApplicationFrequenceInMinutesCleared returns if the "profiles_application_frequence_in_minutes" field was cleared in this mutation.
func (m *SettingsMutation) ProfilesApplicationFrequenceInMinutesCleared() bool {
	_, ok := m.clearedFields[settings.FieldProfilesApplicationFrequenceInMinutes]
	return ok
}

// ResetProfilesApplicationFrequenceInMinutes resets all changes to the "profiles_application_frequence_in_minutes" field.
func (m *SettingsMutation) ResetProfilesApplicationFrequenceInMinutes() {
	m.profiles_application_frequence_in_minutes = nil
	m.addprofiles_application_frequence_in_minutes = nil
	delete(m.clearedFields, settings.FieldProfilesApplicationFrequenceInMinutes)
}

// SetUseWinget sets the "use_winget" field.
func (m *SettingsMutation) SetUseWinget(b bool) {
	m.use_winget = &b
}

// UseWinget returns the value of the "use_winget" field in the mutation.
func (m *SettingsMutation) UseWinget() (r bool, exists bool) {
	v := m.use_winget
	if v == nil {
		return
	}
	return *v, true
}

// OldUseWinget returns the old "use_winget" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUseWinget(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseWinget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseWinget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseWinget: %w", err)
	}
	return oldValue.UseWinget, nil
}

// ClearUseWinget clears the value of the "use_winget" field.
func (m *SettingsMutation) ClearUseWinget() {
	m.use_winget = nil
	m.clearedFields[settings.FieldUseWinget] = struct{}{}
}

// UseWingetCleared returns if the "use_winget" field was cleared in this mutation.
func (m *SettingsMutation) UseWingetCleared() bool {
	_, ok := m.clearedFields[settings.FieldUseWinget]
	return ok
}

// ResetUseWinget resets all changes to the "use_winget" field.
func (m *SettingsMutation) ResetUseWinget() {
	m.use_winget = nil
	delete(m.clearedFields, settings.FieldUseWinget)
}

// SetUseFlatpak sets the "use_flatpak" field.
func (m *SettingsMutation) SetUseFlatpak(b bool) {
	m.use_flatpak = &b
}

// UseFlatpak returns the value of the "use_flatpak" field in the mutation.
func (m *SettingsMutation) UseFlatpak() (r bool, exists bool) {
	v := m.use_flatpak
	if v == nil {
		return
	}
	return *v, true
}

// OldUseFlatpak returns the old "use_flatpak" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUseFlatpak(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseFlatpak is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseFlatpak requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseFlatpak: %w", err)
	}
	return oldValue.UseFlatpak, nil
}

// ClearUseFlatpak clears the value of the "use_flatpak" field.
func (m *SettingsMutation) ClearUseFlatpak() {
	m.use_flatpak = nil
	m.clearedFields[settings.FieldUseFlatpak] = struct{}{}
}

// UseFlatpakCleared returns if the "use_flatpak" field was cleared in this mutation.
func (m *SettingsMutation) UseFlatpakCleared() bool {
	_, ok := m.clearedFields[settings.FieldUseFlatpak]
	return ok
}

// ResetUseFlatpak resets all changes to the "use_flatpak" field.
func (m *SettingsMutation) ResetUseFlatpak() {
	m.use_flatpak = nil
	delete(m.clearedFields, settings.FieldUseFlatpak)
}

// SetUseBrew sets the "use_brew" field.
func (m *SettingsMutation) SetUseBrew(b bool) {
	m.use_brew = &b
}

// UseBrew returns the value of the "use_brew" field in the mutation.
func (m *SettingsMutation) UseBrew() (r bool, exists bool) {
	v := m.use_brew
	if v == nil {
		return
	}
	return *v, true
}

// OldUseBrew returns the old "use_brew" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUseBrew(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseBrew is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseBrew requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseBrew: %w", err)
	}
	return oldValue.UseBrew, nil
}

// ClearUseBrew clears the value of the "use_brew" field.
func (m *SettingsMutation) ClearUseBrew() {
	m.use_brew = nil
	m.clearedFields[settings.FieldUseBrew] = struct{}{}
}

// UseBrewCleared returns if the "use_brew" field was cleared in this mutation.
func (m *SettingsMutation) UseBrewCleared() bool {
	_, ok := m.clearedFields[settings.FieldUseBrew]
	return ok
}

// ResetUseBrew resets all changes to the "use_brew" field.
func (m *SettingsMutation) ResetUseBrew() {
	m.use_brew = nil
	delete(m.clearedFields, settings.FieldUseBrew)
}

// SetDisableSftp sets the "disable_sftp" field.
func (m *SettingsMutation) SetDisableSftp(b bool) {
	m.disable_sftp = &b
}

// DisableSftp returns the value of the "disable_sftp" field in the mutation.
func (m *SettingsMutation) DisableSftp() (r bool, exists bool) {
	v := m.disable_sftp
	if v == nil {
		return
	}
	return *v, true
}

// OldDisableSftp returns the old "disable_sftp" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldDisableSftp(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisableSftp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisableSftp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisableSftp: %w", err)
	}
	return oldValue.DisableSftp, nil
}

// ClearDisableSftp clears the value of the "disable_sftp" field.
func (m *SettingsMutation) ClearDisableSftp() {
	m.disable_sftp = nil
	m.clearedFields[settings.FieldDisableSftp] = struct{}{}
}

// DisableSftpCleared returns if the "disable_sftp" field was cleared in this mutation.
func (m *SettingsMutation) DisableSftpCleared() bool {
	_, ok := m.clearedFields[settings.FieldDisableSftp]
	return ok
}

// ResetDisableSftp resets all changes to the "disable_sftp" field.
func (m *SettingsMutation) ResetDisableSftp() {
	m.disable_sftp = nil
	delete(m.clearedFields, settings.FieldDisableSftp)
}

// SetDisableRemoteAssistance sets the "disable_remote_assistance" field.
func (m *SettingsMutation) SetDisableRemoteAssistance(b bool) {
	m.disable_remote_assistance = &b
}

// DisableRemoteAssistance returns the value of the "disable_remote_assistance" field in the mutation.
func (m *SettingsMutation) DisableRemoteAssistance() (r bool, exists bool) {
	v := m.disable_remote_assistance
	if v == nil {
		return
	}
	return *v, true
}

// OldDisableRemoteAssistance returns the old "disable_remote_assistance" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldDisableRemoteAssistance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisableRemoteAssistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisableRemoteAssistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisableRemoteAssistance: %w", err)
	}
	return oldValue.DisableRemoteAssistance, nil
}

// ClearDisableRemoteAssistance clears the value of the "disable_remote_assistance" field.
func (m *SettingsMutation) ClearDisableRemoteAssistance() {
	m.disable_remote_assistance = nil
	m.clearedFields[settings.FieldDisableRemoteAssistance] = struct{}{}
}

// DisableRemoteAssistanceCleared returns if the "disable_remote_assistance" field was cleared in this mutation.
func (m *SettingsMutation) DisableRemoteAssistanceCleared() bool {
	_, ok := m.clearedFields[settings.FieldDisableRemoteAssistance]
	return ok
}

// ResetDisableRemoteAssistance resets all changes to the "disable_remote_assistance" field.
func (m *SettingsMutation) ResetDisableRemoteAssistance() {
	m.disable_remote_assistance = nil
	delete(m.clearedFields, settings.FieldDisableRemoteAssistance)
}

// SetDetectRemoteAgents sets the "detect_remote_agents" field.
func (m *SettingsMutation) SetDetectRemoteAgents(b bool) {
	m.detect_remote_agents = &b
}

// DetectRemoteAgents returns the value of the "detect_remote_agents" field in the mutation.
func (m *SettingsMutation) DetectRemoteAgents() (r bool, exists bool) {
	v := m.detect_remote_agents
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectRemoteAgents returns the old "detect_remote_agents" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldDetectRemoteAgents(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectRemoteAgents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectRemoteAgents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectRemoteAgents: %w", err)
	}
	return oldValue.DetectRemoteAgents, nil
}

// ClearDetectRemoteAgents clears the value of the "detect_remote_agents" field.
func (m *SettingsMutation) ClearDetectRemoteAgents() {
	m.detect_remote_agents = nil
	m.clearedFields[settings.FieldDetectRemoteAgents] = struct{}{}
}

// DetectRemoteAgentsCleared returns if the "detect_remote_agents" field was cleared in this mutation.
func (m *SettingsMutation) DetectRemoteAgentsCleared() bool {
	_, ok := m.clearedFields[settings.FieldDetectRemoteAgents]
	return ok
}

// ResetDetectRemoteAgents resets all changes to the "detect_remote_agents" field.
func (m *SettingsMutation) ResetDetectRemoteAgents() {
	m.detect_remote_agents = nil
	delete(m.clearedFields, settings.FieldDetectRemoteAgents)
}

// SetAutoAdmitAgents sets the "auto_admit_agents" field.
func (m *SettingsMutation) SetAutoAdmitAgents(b bool) {
	m.auto_admit_agents = &b
}

// AutoAdmitAgents returns the value of the "auto_admit_agents" field in the mutation.
func (m *SettingsMutation) AutoAdmitAgents() (r bool, exists bool) {
	v := m.auto_admit_agents
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoAdmitAgents returns the old "auto_admit_agents" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldAutoAdmitAgents(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoAdmitAgents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoAdmitAgents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoAdmitAgents: %w", err)
	}
	return oldValue.AutoAdmitAgents, nil
}

// ClearAutoAdmitAgents clears the value of the "auto_admit_agents" field.
func (m *SettingsMutation) ClearAutoAdmitAgents() {
	m.auto_admit_agents = nil
	m.clearedFields[settings.FieldAutoAdmitAgents] = struct{}{}
}

// AutoAdmitAgentsCleared returns if the "auto_admit_agents" field was cleared in this mutation.
func (m *SettingsMutation) AutoAdmitAgentsCleared() bool {
	_, ok := m.clearedFields[settings.FieldAutoAdmitAgents]
	return ok
}

// ResetAutoAdmitAgents resets all changes to the "auto_admit_agents" field.
func (m *SettingsMutation) ResetAutoAdmitAgents() {
	m.auto_admit_agents = nil
	delete(m.clearedFields, settings.FieldAutoAdmitAgents)
}

// SetDefaultItemsPerPage sets the "default_items_per_page" field.
func (m *SettingsMutation) SetDefaultItemsPerPage(i int) {
	m.default_items_per_page = &i
	m.adddefault_items_per_page = nil
}

// DefaultItemsPerPage returns the value of the "default_items_per_page" field in the mutation.
func (m *SettingsMutation) DefaultItemsPerPage() (r int, exists bool) {
	v := m.default_items_per_page
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultItemsPerPage returns the old "default_items_per_page" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldDefaultItemsPerPage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultItemsPerPage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultItemsPerPage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultItemsPerPage: %w", err)
	}
	return oldValue.DefaultItemsPerPage, nil
}

// AddDefaultItemsPerPage adds i to the "default_items_per_page" field.
func (m *SettingsMutation) AddDefaultItemsPerPage(i int) {
	if m.adddefault_items_per_page != nil {
		*m.adddefault_items_per_page += i
	} else {
		m.adddefault_items_per_page = &i
	}
}

// AddedDefaultItemsPerPage returns the value that was added to the "default_items_per_page" field in this mutation.
func (m *SettingsMutation) AddedDefaultItemsPerPage() (r int, exists bool) {
	v := m.adddefault_items_per_page
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultItemsPerPage clears the value of the "default_items_per_page" field.
func (m *SettingsMutation) ClearDefaultItemsPerPage() {
	m.default_items_per_page = nil
	m.adddefault_items_per_page = nil
	m.clearedFields[settings.FieldDefaultItemsPerPage] = struct{}{}
}

// DefaultItemsPerPageCleared returns if the "default_items_per_page" field was cleared in this mutation.
func (m *SettingsMutation) DefaultItemsPerPageCleared() bool {
	_, ok := m.clearedFields[settings.FieldDefaultItemsPerPage]
	return ok
}

// ResetDefaultItemsPerPage resets all changes to the "default_items_per_page" field.
func (m *SettingsMutation) ResetDefaultItemsPerPage() {
	m.default_items_per_page = nil
	m.adddefault_items_per_page = nil
	delete(m.clearedFields, settings.FieldDefaultItemsPerPage)
}

// SetTagID sets the "tag" edge to the Tag entity by id.
func (m *SettingsMutation) SetTagID(id int) {
	m.tag = &id
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *SettingsMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *SettingsMutation) TagCleared() bool {
	return m.clearedtag
}

// TagID returns the "tag" edge ID in the mutation.
func (m *SettingsMutation) TagID() (id int, exists bool) {
	if m.tag != nil {
		return *m.tag, true
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *SettingsMutation) TagIDs() (ids []int) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *SettingsMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SettingsMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SettingsMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SettingsMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SettingsMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SettingsMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SettingsMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the SettingsMutation builder.
func (m *SettingsMutation) Where(ps ...predicate.Settings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Settings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Settings).
func (m *SettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingsMutation) Fields() []string {
	fields := make([]string, 0, 37)
	if m.language != nil {
		fields = append(fields, settings.FieldLanguage)
	}
	if m.organization != nil {
		fields = append(fields, settings.FieldOrganization)
	}
	if m.postal_address != nil {
		fields = append(fields, settings.FieldPostalAddress)
	}
	if m.postal_code != nil {
		fields = append(fields, settings.FieldPostalCode)
	}
	if m.locality != nil {
		fields = append(fields, settings.FieldLocality)
	}
	if m.province != nil {
		fields = append(fields, settings.FieldProvince)
	}
	if m.state != nil {
		fields = append(fields, settings.FieldState)
	}
	if m.country != nil {
		fields = append(fields, settings.FieldCountry)
	}
	if m.smtp_server != nil {
		fields = append(fields, settings.FieldSMTPServer)
	}
	if m.smtp_port != nil {
		fields = append(fields, settings.FieldSMTPPort)
	}
	if m.smtp_user != nil {
		fields = append(fields, settings.FieldSMTPUser)
	}
	if m.smtp_password != nil {
		fields = append(fields, settings.FieldSMTPPassword)
	}
	if m.smtp_auth != nil {
		fields = append(fields, settings.FieldSMTPAuth)
	}
	if m.smtp_tls != nil {
		fields = append(fields, settings.FieldSMTPTLS)
	}
	if m.smtp_starttls != nil {
		fields = append(fields, settings.FieldSMTPStarttls)
	}
	if m.nats_server != nil {
		fields = append(fields, settings.FieldNatsServer)
	}
	if m.nats_port != nil {
		fields = append(fields, settings.FieldNatsPort)
	}
	if m.message_from != nil {
		fields = append(fields, settings.FieldMessageFrom)
	}
	if m.max_upload_size != nil {
		fields = append(fields, settings.FieldMaxUploadSize)
	}
	if m.user_cert_years_valid != nil {
		fields = append(fields, settings.FieldUserCertYearsValid)
	}
	if m.nats_request_timeout_seconds != nil {
		fields = append(fields, settings.FieldNatsRequestTimeoutSeconds)
	}
	if m.refresh_time_in_minutes != nil {
		fields = append(fields, settings.FieldRefreshTimeInMinutes)
	}
	if m.session_lifetime_in_minutes != nil {
		fields = append(fields, settings.FieldSessionLifetimeInMinutes)
	}
	if m.update_channel != nil {
		fields = append(fields, settings.FieldUpdateChannel)
	}
	if m.created != nil {
		fields = append(fields, settings.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, settings.FieldModified)
	}
	if m.agent_report_frequence_in_minutes != nil {
		fields = append(fields, settings.FieldAgentReportFrequenceInMinutes)
	}
	if m.request_vnc_pin != nil {
		fields = append(fields, settings.FieldRequestVncPin)
	}
	if m.profiles_application_frequence_in_minutes != nil {
		fields = append(fields, settings.FieldProfilesApplicationFrequenceInMinutes)
	}
	if m.use_winget != nil {
		fields = append(fields, settings.FieldUseWinget)
	}
	if m.use_flatpak != nil {
		fields = append(fields, settings.FieldUseFlatpak)
	}
	if m.use_brew != nil {
		fields = append(fields, settings.FieldUseBrew)
	}
	if m.disable_sftp != nil {
		fields = append(fields, settings.FieldDisableSftp)
	}
	if m.disable_remote_assistance != nil {
		fields = append(fields, settings.FieldDisableRemoteAssistance)
	}
	if m.detect_remote_agents != nil {
		fields = append(fields, settings.FieldDetectRemoteAgents)
	}
	if m.auto_admit_agents != nil {
		fields = append(fields, settings.FieldAutoAdmitAgents)
	}
	if m.default_items_per_page != nil {
		fields = append(fields, settings.FieldDefaultItemsPerPage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldLanguage:
		return m.Language()
	case settings.FieldOrganization:
		return m.Organization()
	case settings.FieldPostalAddress:
		return m.PostalAddress()
	case settings.FieldPostalCode:
		return m.PostalCode()
	case settings.FieldLocality:
		return m.Locality()
	case settings.FieldProvince:
		return m.Province()
	case settings.FieldState:
		return m.State()
	case settings.FieldCountry:
		return m.Country()
	case settings.FieldSMTPServer:
		return m.SMTPServer()
	case settings.FieldSMTPPort:
		return m.SMTPPort()
	case settings.FieldSMTPUser:
		return m.SMTPUser()
	case settings.FieldSMTPPassword:
		return m.SMTPPassword()
	case settings.FieldSMTPAuth:
		return m.SMTPAuth()
	case settings.FieldSMTPTLS:
		return m.SMTPTLS()
	case settings.FieldSMTPStarttls:
		return m.SMTPStarttls()
	case settings.FieldNatsServer:
		return m.NatsServer()
	case settings.FieldNatsPort:
		return m.NatsPort()
	case settings.FieldMessageFrom:
		return m.MessageFrom()
	case settings.FieldMaxUploadSize:
		return m.MaxUploadSize()
	case settings.FieldUserCertYearsValid:
		return m.UserCertYearsValid()
	case settings.FieldNatsRequestTimeoutSeconds:
		return m.NatsRequestTimeoutSeconds()
	case settings.FieldRefreshTimeInMinutes:
		return m.RefreshTimeInMinutes()
	case settings.FieldSessionLifetimeInMinutes:
		return m.SessionLifetimeInMinutes()
	case settings.FieldUpdateChannel:
		return m.UpdateChannel()
	case settings.FieldCreated:
		return m.Created()
	case settings.FieldModified:
		return m.Modified()
	case settings.FieldAgentReportFrequenceInMinutes:
		return m.AgentReportFrequenceInMinutes()
	case settings.FieldRequestVncPin:
		return m.RequestVncPin()
	case settings.FieldProfilesApplicationFrequenceInMinutes:
		return m.ProfilesApplicationFrequenceInMinutes()
	case settings.FieldUseWinget:
		return m.UseWinget()
	case settings.FieldUseFlatpak:
		return m.UseFlatpak()
	case settings.FieldUseBrew:
		return m.UseBrew()
	case settings.FieldDisableSftp:
		return m.DisableSftp()
	case settings.FieldDisableRemoteAssistance:
		return m.DisableRemoteAssistance()
	case settings.FieldDetectRemoteAgents:
		return m.DetectRemoteAgents()
	case settings.FieldAutoAdmitAgents:
		return m.AutoAdmitAgents()
	case settings.FieldDefaultItemsPerPage:
		return m.DefaultItemsPerPage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settings.FieldLanguage:
		return m.OldLanguage(ctx)
	case settings.FieldOrganization:
		return m.OldOrganization(ctx)
	case settings.FieldPostalAddress:
		return m.OldPostalAddress(ctx)
	case settings.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case settings.FieldLocality:
		return m.OldLocality(ctx)
	case settings.FieldProvince:
		return m.OldProvince(ctx)
	case settings.FieldState:
		return m.OldState(ctx)
	case settings.FieldCountry:
		return m.OldCountry(ctx)
	case settings.FieldSMTPServer:
		return m.OldSMTPServer(ctx)
	case settings.FieldSMTPPort:
		return m.OldSMTPPort(ctx)
	case settings.FieldSMTPUser:
		return m.OldSMTPUser(ctx)
	case settings.FieldSMTPPassword:
		return m.OldSMTPPassword(ctx)
	case settings.FieldSMTPAuth:
		return m.OldSMTPAuth(ctx)
	case settings.FieldSMTPTLS:
		return m.OldSMTPTLS(ctx)
	case settings.FieldSMTPStarttls:
		return m.OldSMTPStarttls(ctx)
	case settings.FieldNatsServer:
		return m.OldNatsServer(ctx)
	case settings.FieldNatsPort:
		return m.OldNatsPort(ctx)
	case settings.FieldMessageFrom:
		return m.OldMessageFrom(ctx)
	case settings.FieldMaxUploadSize:
		return m.OldMaxUploadSize(ctx)
	case settings.FieldUserCertYearsValid:
		return m.OldUserCertYearsValid(ctx)
	case settings.FieldNatsRequestTimeoutSeconds:
		return m.OldNatsRequestTimeoutSeconds(ctx)
	case settings.FieldRefreshTimeInMinutes:
		return m.OldRefreshTimeInMinutes(ctx)
	case settings.FieldSessionLifetimeInMinutes:
		return m.OldSessionLifetimeInMinutes(ctx)
	case settings.FieldUpdateChannel:
		return m.OldUpdateChannel(ctx)
	case settings.FieldCreated:
		return m.OldCreated(ctx)
	case settings.FieldModified:
		return m.OldModified(ctx)
	case settings.FieldAgentReportFrequenceInMinutes:
		return m.OldAgentReportFrequenceInMinutes(ctx)
	case settings.FieldRequestVncPin:
		return m.OldRequestVncPin(ctx)
	case settings.FieldProfilesApplicationFrequenceInMinutes:
		return m.OldProfilesApplicationFrequenceInMinutes(ctx)
	case settings.FieldUseWinget:
		return m.OldUseWinget(ctx)
	case settings.FieldUseFlatpak:
		return m.OldUseFlatpak(ctx)
	case settings.FieldUseBrew:
		return m.OldUseBrew(ctx)
	case settings.FieldDisableSftp:
		return m.OldDisableSftp(ctx)
	case settings.FieldDisableRemoteAssistance:
		return m.OldDisableRemoteAssistance(ctx)
	case settings.FieldDetectRemoteAgents:
		return m.OldDetectRemoteAgents(ctx)
	case settings.FieldAutoAdmitAgents:
		return m.OldAutoAdmitAgents(ctx)
	case settings.FieldDefaultItemsPerPage:
		return m.OldDefaultItemsPerPage(ctx)
	}
	return nil, fmt.Errorf("unknown Settings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settings.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case settings.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case settings.FieldPostalAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalAddress(v)
		return nil
	case settings.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case settings.FieldLocality:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocality(v)
		return nil
	case settings.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case settings.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case settings.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case settings.FieldSMTPServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPServer(v)
		return nil
	case settings.FieldSMTPPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPPort(v)
		return nil
	case settings.FieldSMTPUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPUser(v)
		return nil
	case settings.FieldSMTPPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPPassword(v)
		return nil
	case settings.FieldSMTPAuth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPAuth(v)
		return nil
	case settings.FieldSMTPTLS:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPTLS(v)
		return nil
	case settings.FieldSMTPStarttls:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPStarttls(v)
		return nil
	case settings.FieldNatsServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNatsServer(v)
		return nil
	case settings.FieldNatsPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNatsPort(v)
		return nil
	case settings.FieldMessageFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageFrom(v)
		return nil
	case settings.FieldMaxUploadSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxUploadSize(v)
		return nil
	case settings.FieldUserCertYearsValid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCertYearsValid(v)
		return nil
	case settings.FieldNatsRequestTimeoutSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNatsRequestTimeoutSeconds(v)
		return nil
	case settings.FieldRefreshTimeInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTimeInMinutes(v)
		return nil
	case settings.FieldSessionLifetimeInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionLifetimeInMinutes(v)
		return nil
	case settings.FieldUpdateChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateChannel(v)
		return nil
	case settings.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case settings.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	case settings.FieldAgentReportFrequenceInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentReportFrequenceInMinutes(v)
		return nil
	case settings.FieldRequestVncPin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestVncPin(v)
		return nil
	case settings.FieldProfilesApplicationFrequenceInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilesApplicationFrequenceInMinutes(v)
		return nil
	case settings.FieldUseWinget:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseWinget(v)
		return nil
	case settings.FieldUseFlatpak:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseFlatpak(v)
		return nil
	case settings.FieldUseBrew:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseBrew(v)
		return nil
	case settings.FieldDisableSftp:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisableSftp(v)
		return nil
	case settings.FieldDisableRemoteAssistance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisableRemoteAssistance(v)
		return nil
	case settings.FieldDetectRemoteAgents:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectRemoteAgents(v)
		return nil
	case settings.FieldAutoAdmitAgents:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoAdmitAgents(v)
		return nil
	case settings.FieldDefaultItemsPerPage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultItemsPerPage(v)
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingsMutation) AddedFields() []string {
	var fields []string
	if m.addsmtp_port != nil {
		fields = append(fields, settings.FieldSMTPPort)
	}
	if m.adduser_cert_years_valid != nil {
		fields = append(fields, settings.FieldUserCertYearsValid)
	}
	if m.addnats_request_timeout_seconds != nil {
		fields = append(fields, settings.FieldNatsRequestTimeoutSeconds)
	}
	if m.addrefresh_time_in_minutes != nil {
		fields = append(fields, settings.FieldRefreshTimeInMinutes)
	}
	if m.addsession_lifetime_in_minutes != nil {
		fields = append(fields, settings.FieldSessionLifetimeInMinutes)
	}
	if m.addagent_report_frequence_in_minutes != nil {
		fields = append(fields, settings.FieldAgentReportFrequenceInMinutes)
	}
	if m.addprofiles_application_frequence_in_minutes != nil {
		fields = append(fields, settings.FieldProfilesApplicationFrequenceInMinutes)
	}
	if m.adddefault_items_per_page != nil {
		fields = append(fields, settings.FieldDefaultItemsPerPage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldSMTPPort:
		return m.AddedSMTPPort()
	case settings.FieldUserCertYearsValid:
		return m.AddedUserCertYearsValid()
	case settings.FieldNatsRequestTimeoutSeconds:
		return m.AddedNatsRequestTimeoutSeconds()
	case settings.FieldRefreshTimeInMinutes:
		return m.AddedRefreshTimeInMinutes()
	case settings.FieldSessionLifetimeInMinutes:
		return m.AddedSessionLifetimeInMinutes()
	case settings.FieldAgentReportFrequenceInMinutes:
		return m.AddedAgentReportFrequenceInMinutes()
	case settings.FieldProfilesApplicationFrequenceInMinutes:
		return m.AddedProfilesApplicationFrequenceInMinutes()
	case settings.FieldDefaultItemsPerPage:
		return m.AddedDefaultItemsPerPage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case settings.FieldSMTPPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSMTPPort(v)
		return nil
	case settings.FieldUserCertYearsValid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserCertYearsValid(v)
		return nil
	case settings.FieldNatsRequestTimeoutSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNatsRequestTimeoutSeconds(v)
		return nil
	case settings.FieldRefreshTimeInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefreshTimeInMinutes(v)
		return nil
	case settings.FieldSessionLifetimeInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessionLifetimeInMinutes(v)
		return nil
	case settings.FieldAgentReportFrequenceInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgentReportFrequenceInMinutes(v)
		return nil
	case settings.FieldProfilesApplicationFrequenceInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfilesApplicationFrequenceInMinutes(v)
		return nil
	case settings.FieldDefaultItemsPerPage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultItemsPerPage(v)
		return nil
	}
	return fmt.Errorf("unknown Settings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(settings.FieldLanguage) {
		fields = append(fields, settings.FieldLanguage)
	}
	if m.FieldCleared(settings.FieldOrganization) {
		fields = append(fields, settings.FieldOrganization)
	}
	if m.FieldCleared(settings.FieldPostalAddress) {
		fields = append(fields, settings.FieldPostalAddress)
	}
	if m.FieldCleared(settings.FieldPostalCode) {
		fields = append(fields, settings.FieldPostalCode)
	}
	if m.FieldCleared(settings.FieldLocality) {
		fields = append(fields, settings.FieldLocality)
	}
	if m.FieldCleared(settings.FieldProvince) {
		fields = append(fields, settings.FieldProvince)
	}
	if m.FieldCleared(settings.FieldState) {
		fields = append(fields, settings.FieldState)
	}
	if m.FieldCleared(settings.FieldCountry) {
		fields = append(fields, settings.FieldCountry)
	}
	if m.FieldCleared(settings.FieldSMTPServer) {
		fields = append(fields, settings.FieldSMTPServer)
	}
	if m.FieldCleared(settings.FieldSMTPPort) {
		fields = append(fields, settings.FieldSMTPPort)
	}
	if m.FieldCleared(settings.FieldSMTPUser) {
		fields = append(fields, settings.FieldSMTPUser)
	}
	if m.FieldCleared(settings.FieldSMTPPassword) {
		fields = append(fields, settings.FieldSMTPPassword)
	}
	if m.FieldCleared(settings.FieldSMTPAuth) {
		fields = append(fields, settings.FieldSMTPAuth)
	}
	if m.FieldCleared(settings.FieldSMTPTLS) {
		fields = append(fields, settings.FieldSMTPTLS)
	}
	if m.FieldCleared(settings.FieldSMTPStarttls) {
		fields = append(fields, settings.FieldSMTPStarttls)
	}
	if m.FieldCleared(settings.FieldNatsServer) {
		fields = append(fields, settings.FieldNatsServer)
	}
	if m.FieldCleared(settings.FieldNatsPort) {
		fields = append(fields, settings.FieldNatsPort)
	}
	if m.FieldCleared(settings.FieldMessageFrom) {
		fields = append(fields, settings.FieldMessageFrom)
	}
	if m.FieldCleared(settings.FieldMaxUploadSize) {
		fields = append(fields, settings.FieldMaxUploadSize)
	}
	if m.FieldCleared(settings.FieldUserCertYearsValid) {
		fields = append(fields, settings.FieldUserCertYearsValid)
	}
	if m.FieldCleared(settings.FieldNatsRequestTimeoutSeconds) {
		fields = append(fields, settings.FieldNatsRequestTimeoutSeconds)
	}
	if m.FieldCleared(settings.FieldRefreshTimeInMinutes) {
		fields = append(fields, settings.FieldRefreshTimeInMinutes)
	}
	if m.FieldCleared(settings.FieldSessionLifetimeInMinutes) {
		fields = append(fields, settings.FieldSessionLifetimeInMinutes)
	}
	if m.FieldCleared(settings.FieldUpdateChannel) {
		fields = append(fields, settings.FieldUpdateChannel)
	}
	if m.FieldCleared(settings.FieldCreated) {
		fields = append(fields, settings.FieldCreated)
	}
	if m.FieldCleared(settings.FieldModified) {
		fields = append(fields, settings.FieldModified)
	}
	if m.FieldCleared(settings.FieldAgentReportFrequenceInMinutes) {
		fields = append(fields, settings.FieldAgentReportFrequenceInMinutes)
	}
	if m.FieldCleared(settings.FieldRequestVncPin) {
		fields = append(fields, settings.FieldRequestVncPin)
	}
	if m.FieldCleared(settings.FieldProfilesApplicationFrequenceInMinutes) {
		fields = append(fields, settings.FieldProfilesApplicationFrequenceInMinutes)
	}
	if m.FieldCleared(settings.FieldUseWinget) {
		fields = append(fields, settings.FieldUseWinget)
	}
	if m.FieldCleared(settings.FieldUseFlatpak) {
		fields = append(fields, settings.FieldUseFlatpak)
	}
	if m.FieldCleared(settings.FieldUseBrew) {
		fields = append(fields, settings.FieldUseBrew)
	}
	if m.FieldCleared(settings.FieldDisableSftp) {
		fields = append(fields, settings.FieldDisableSftp)
	}
	if m.FieldCleared(settings.FieldDisableRemoteAssistance) {
		fields = append(fields, settings.FieldDisableRemoteAssistance)
	}
	if m.FieldCleared(settings.FieldDetectRemoteAgents) {
		fields = append(fields, settings.FieldDetectRemoteAgents)
	}
	if m.FieldCleared(settings.FieldAutoAdmitAgents) {
		fields = append(fields, settings.FieldAutoAdmitAgents)
	}
	if m.FieldCleared(settings.FieldDefaultItemsPerPage) {
		fields = append(fields, settings.FieldDefaultItemsPerPage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingsMutation) ClearField(name string) error {
	switch name {
	case settings.FieldLanguage:
		m.ClearLanguage()
		return nil
	case settings.FieldOrganization:
		m.ClearOrganization()
		return nil
	case settings.FieldPostalAddress:
		m.ClearPostalAddress()
		return nil
	case settings.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case settings.FieldLocality:
		m.ClearLocality()
		return nil
	case settings.FieldProvince:
		m.ClearProvince()
		return nil
	case settings.FieldState:
		m.ClearState()
		return nil
	case settings.FieldCountry:
		m.ClearCountry()
		return nil
	case settings.FieldSMTPServer:
		m.ClearSMTPServer()
		return nil
	case settings.FieldSMTPPort:
		m.ClearSMTPPort()
		return nil
	case settings.FieldSMTPUser:
		m.ClearSMTPUser()
		return nil
	case settings.FieldSMTPPassword:
		m.ClearSMTPPassword()
		return nil
	case settings.FieldSMTPAuth:
		m.ClearSMTPAuth()
		return nil
	case settings.FieldSMTPTLS:
		m.ClearSMTPTLS()
		return nil
	case settings.FieldSMTPStarttls:
		m.ClearSMTPStarttls()
		return nil
	case settings.FieldNatsServer:
		m.ClearNatsServer()
		return nil
	case settings.FieldNatsPort:
		m.ClearNatsPort()
		return nil
	case settings.FieldMessageFrom:
		m.ClearMessageFrom()
		return nil
	case settings.FieldMaxUploadSize:
		m.ClearMaxUploadSize()
		return nil
	case settings.FieldUserCertYearsValid:
		m.ClearUserCertYearsValid()
		return nil
	case settings.FieldNatsRequestTimeoutSeconds:
		m.ClearNatsRequestTimeoutSeconds()
		return nil
	case settings.FieldRefreshTimeInMinutes:
		m.ClearRefreshTimeInMinutes()
		return nil
	case settings.FieldSessionLifetimeInMinutes:
		m.ClearSessionLifetimeInMinutes()
		return nil
	case settings.FieldUpdateChannel:
		m.ClearUpdateChannel()
		return nil
	case settings.FieldCreated:
		m.ClearCreated()
		return nil
	case settings.FieldModified:
		m.ClearModified()
		return nil
	case settings.FieldAgentReportFrequenceInMinutes:
		m.ClearAgentReportFrequenceInMinutes()
		return nil
	case settings.FieldRequestVncPin:
		m.ClearRequestVncPin()
		return nil
	case settings.FieldProfilesApplicationFrequenceInMinutes:
		m.ClearProfilesApplicationFrequenceInMinutes()
		return nil
	case settings.FieldUseWinget:
		m.ClearUseWinget()
		return nil
	case settings.FieldUseFlatpak:
		m.ClearUseFlatpak()
		return nil
	case settings.FieldUseBrew:
		m.ClearUseBrew()
		return nil
	case settings.FieldDisableSftp:
		m.ClearDisableSftp()
		return nil
	case settings.FieldDisableRemoteAssistance:
		m.ClearDisableRemoteAssistance()
		return nil
	case settings.FieldDetectRemoteAgents:
		m.ClearDetectRemoteAgents()
		return nil
	case settings.FieldAutoAdmitAgents:
		m.ClearAutoAdmitAgents()
		return nil
	case settings.FieldDefaultItemsPerPage:
		m.ClearDefaultItemsPerPage()
		return nil
	}
	return fmt.Errorf("unknown Settings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingsMutation) ResetField(name string) error {
	switch name {
	case settings.FieldLanguage:
		m.ResetLanguage()
		return nil
	case settings.FieldOrganization:
		m.ResetOrganization()
		return nil
	case settings.FieldPostalAddress:
		m.ResetPostalAddress()
		return nil
	case settings.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case settings.FieldLocality:
		m.ResetLocality()
		return nil
	case settings.FieldProvince:
		m.ResetProvince()
		return nil
	case settings.FieldState:
		m.ResetState()
		return nil
	case settings.FieldCountry:
		m.ResetCountry()
		return nil
	case settings.FieldSMTPServer:
		m.ResetSMTPServer()
		return nil
	case settings.FieldSMTPPort:
		m.ResetSMTPPort()
		return nil
	case settings.FieldSMTPUser:
		m.ResetSMTPUser()
		return nil
	case settings.FieldSMTPPassword:
		m.ResetSMTPPassword()
		return nil
	case settings.FieldSMTPAuth:
		m.ResetSMTPAuth()
		return nil
	case settings.FieldSMTPTLS:
		m.ResetSMTPTLS()
		return nil
	case settings.FieldSMTPStarttls:
		m.ResetSMTPStarttls()
		return nil
	case settings.FieldNatsServer:
		m.ResetNatsServer()
		return nil
	case settings.FieldNatsPort:
		m.ResetNatsPort()
		return nil
	case settings.FieldMessageFrom:
		m.ResetMessageFrom()
		return nil
	case settings.FieldMaxUploadSize:
		m.ResetMaxUploadSize()
		return nil
	case settings.FieldUserCertYearsValid:
		m.ResetUserCertYearsValid()
		return nil
	case settings.FieldNatsRequestTimeoutSeconds:
		m.ResetNatsRequestTimeoutSeconds()
		return nil
	case settings.FieldRefreshTimeInMinutes:
		m.ResetRefreshTimeInMinutes()
		return nil
	case settings.FieldSessionLifetimeInMinutes:
		m.ResetSessionLifetimeInMinutes()
		return nil
	case settings.FieldUpdateChannel:
		m.ResetUpdateChannel()
		return nil
	case settings.FieldCreated:
		m.ResetCreated()
		return nil
	case settings.FieldModified:
		m.ResetModified()
		return nil
	case settings.FieldAgentReportFrequenceInMinutes:
		m.ResetAgentReportFrequenceInMinutes()
		return nil
	case settings.FieldRequestVncPin:
		m.ResetRequestVncPin()
		return nil
	case settings.FieldProfilesApplicationFrequenceInMinutes:
		m.ResetProfilesApplicationFrequenceInMinutes()
		return nil
	case settings.FieldUseWinget:
		m.ResetUseWinget()
		return nil
	case settings.FieldUseFlatpak:
		m.ResetUseFlatpak()
		return nil
	case settings.FieldUseBrew:
		m.ResetUseBrew()
		return nil
	case settings.FieldDisableSftp:
		m.ResetDisableSftp()
		return nil
	case settings.FieldDisableRemoteAssistance:
		m.ResetDisableRemoteAssistance()
		return nil
	case settings.FieldDetectRemoteAgents:
		m.ResetDetectRemoteAgents()
		return nil
	case settings.FieldAutoAdmitAgents:
		m.ResetAutoAdmitAgents()
		return nil
	case settings.FieldDefaultItemsPerPage:
		m.ResetDefaultItemsPerPage()
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tag != nil {
		edges = append(edges, settings.EdgeTag)
	}
	if m.tenant != nil {
		edges = append(edges, settings.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case settings.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	case settings.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtag {
		edges = append(edges, settings.EdgeTag)
	}
	if m.clearedtenant {
		edges = append(edges, settings.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case settings.EdgeTag:
		return m.clearedtag
	case settings.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingsMutation) ClearEdge(name string) error {
	switch name {
	case settings.EdgeTag:
		m.ClearTag()
		return nil
	case settings.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Settings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingsMutation) ResetEdge(name string) error {
	switch name {
	case settings.EdgeTag:
		m.ResetTag()
		return nil
	case settings.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Settings edge %s", name)
}

// ShareMutation represents an operation that mutates the Share nodes in the graph.
type ShareMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	_path         *string
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Share, error)
	predicates    []predicate.Share
}

var _ ent.Mutation = (*ShareMutation)(nil)

// shareOption allows management of the mutation configuration using functional options.
type shareOption func(*ShareMutation)

// newShareMutation creates new mutation for the Share entity.
func newShareMutation(c config, op Op, opts ...shareOption) *ShareMutation {
	m := &ShareMutation{
		config:        c,
		op:            op,
		typ:           TypeShare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShareID sets the ID field of the mutation.
func withShareID(id int) shareOption {
	return func(m *ShareMutation) {
		var (
			err   error
			once  sync.Once
			value *Share
		)
		m.oldValue = func(ctx context.Context) (*Share, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Share.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShare sets the old Share of the mutation.
func withShare(node *Share) shareOption {
	return func(m *ShareMutation) {
		m.oldValue = func(context.Context) (*Share, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShareMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShareMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Share.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ShareMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ShareMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ShareMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ShareMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ShareMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ShareMutation) ResetDescription() {
	m.description = nil
}

// SetPath sets the "path" field.
func (m *ShareMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ShareMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *ShareMutation) ClearPath() {
	m._path = nil
	m.clearedFields[share.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *ShareMutation) PathCleared() bool {
	_, ok := m.clearedFields[share.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *ShareMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, share.FieldPath)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *ShareMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *ShareMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *ShareMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ShareMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ShareMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ShareMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the ShareMutation builder.
func (m *ShareMutation) Where(ps ...predicate.Share) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Share, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Share).
func (m *ShareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShareMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, share.FieldName)
	}
	if m.description != nil {
		fields = append(fields, share.FieldDescription)
	}
	if m._path != nil {
		fields = append(fields, share.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case share.FieldName:
		return m.Name()
	case share.FieldDescription:
		return m.Description()
	case share.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case share.FieldName:
		return m.OldName(ctx)
	case share.FieldDescription:
		return m.OldDescription(ctx)
	case share.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown Share field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case share.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case share.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case share.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown Share field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShareMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShareMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShareMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Share numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShareMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(share.FieldPath) {
		fields = append(fields, share.FieldPath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShareMutation) ClearField(name string) error {
	switch name {
	case share.FieldPath:
		m.ClearPath()
		return nil
	}
	return fmt.Errorf("unknown Share nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShareMutation) ResetField(name string) error {
	switch name {
	case share.FieldName:
		m.ResetName()
		return nil
	case share.FieldDescription:
		m.ResetDescription()
		return nil
	case share.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown Share field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShareMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, share.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case share.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, share.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShareMutation) EdgeCleared(name string) bool {
	switch name {
	case share.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShareMutation) ClearEdge(name string) error {
	switch name {
	case share.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Share unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShareMutation) ResetEdge(name string) error {
	switch name {
	case share.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Share edge %s", name)
}

// SiteMutation represents an operation that mutates the Site nodes in the graph.
type SiteMutation struct {
	config
	op              Op
	typ             string
	id              *int
	description     *string
	is_default      *bool
	domain          *string
	created         *time.Time
	modified        *time.Time
	clearedFields   map[string]struct{}
	tenant          *int
	clearedtenant   bool
	agents          map[string]struct{}
	removedagents   map[string]struct{}
	clearedagents   bool
	profiles        map[int]struct{}
	removedprofiles map[int]struct{}
	clearedprofiles bool
	done            bool
	oldValue        func(context.Context) (*Site, error)
	predicates      []predicate.Site
}

var _ ent.Mutation = (*SiteMutation)(nil)

// siteOption allows management of the mutation configuration using functional options.
type siteOption func(*SiteMutation)

// newSiteMutation creates new mutation for the Site entity.
func newSiteMutation(c config, op Op, opts ...siteOption) *SiteMutation {
	m := &SiteMutation{
		config:        c,
		op:            op,
		typ:           TypeSite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSiteID sets the ID field of the mutation.
func withSiteID(id int) siteOption {
	return func(m *SiteMutation) {
		var (
			err   error
			once  sync.Once
			value *Site
		)
		m.oldValue = func(ctx context.Context) (*Site, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Site.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSite sets the old Site of the mutation.
func withSite(node *Site) siteOption {
	return func(m *SiteMutation) {
		m.oldValue = func(context.Context) (*Site, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SiteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SiteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SiteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SiteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Site.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *SiteMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SiteMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SiteMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[site.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SiteMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[site.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SiteMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, site.FieldDescription)
}

// SetIsDefault sets the "is_default" field.
func (m *SiteMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *SiteMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "is_default" field.
func (m *SiteMutation) ClearIsDefault() {
	m.is_default = nil
	m.clearedFields[site.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "is_default" field was cleared in this mutation.
func (m *SiteMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[site.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *SiteMutation) ResetIsDefault() {
	m.is_default = nil
	delete(m.clearedFields, site.FieldIsDefault)
}

// SetDomain sets the "domain" field.
func (m *SiteMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *SiteMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *SiteMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[site.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *SiteMutation) DomainCleared() bool {
	_, ok := m.clearedFields[site.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *SiteMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, site.FieldDomain)
}

// SetCreated sets the "created" field.
func (m *SiteMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *SiteMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ClearCreated clears the value of the "created" field.
func (m *SiteMutation) ClearCreated() {
	m.created = nil
	m.clearedFields[site.FieldCreated] = struct{}{}
}

// CreatedCleared returns if the "created" field was cleared in this mutation.
func (m *SiteMutation) CreatedCleared() bool {
	_, ok := m.clearedFields[site.FieldCreated]
	return ok
}

// ResetCreated resets all changes to the "created" field.
func (m *SiteMutation) ResetCreated() {
	m.created = nil
	delete(m.clearedFields, site.FieldCreated)
}

// SetModified sets the "modified" field.
func (m *SiteMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *SiteMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Site entity.
// If the Site object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ClearModified clears the value of the "modified" field.
func (m *SiteMutation) ClearModified() {
	m.modified = nil
	m.clearedFields[site.FieldModified] = struct{}{}
}

// ModifiedCleared returns if the "modified" field was cleared in this mutation.
func (m *SiteMutation) ModifiedCleared() bool {
	_, ok := m.clearedFields[site.FieldModified]
	return ok
}

// ResetModified resets all changes to the "modified" field.
func (m *SiteMutation) ResetModified() {
	m.modified = nil
	delete(m.clearedFields, site.FieldModified)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SiteMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SiteMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SiteMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SiteMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SiteMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SiteMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddAgentIDs adds the "agents" edge to the Agent entity by ids.
func (m *SiteMutation) AddAgentIDs(ids ...string) {
	if m.agents == nil {
		m.agents = make(map[string]struct{})
	}
	for i := range ids {
		m.agents[ids[i]] = struct{}{}
	}
}

// ClearAgents clears the "agents" edge to the Agent entity.
func (m *SiteMutation) ClearAgents() {
	m.clearedagents = true
}

// AgentsCleared reports if the "agents" edge to the Agent entity was cleared.
func (m *SiteMutation) AgentsCleared() bool {
	return m.clearedagents
}

// RemoveAgentIDs removes the "agents" edge to the Agent entity by IDs.
func (m *SiteMutation) RemoveAgentIDs(ids ...string) {
	if m.removedagents == nil {
		m.removedagents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.agents, ids[i])
		m.removedagents[ids[i]] = struct{}{}
	}
}

// RemovedAgents returns the removed IDs of the "agents" edge to the Agent entity.
func (m *SiteMutation) RemovedAgentsIDs() (ids []string) {
	for id := range m.removedagents {
		ids = append(ids, id)
	}
	return
}

// AgentsIDs returns the "agents" edge IDs in the mutation.
func (m *SiteMutation) AgentsIDs() (ids []string) {
	for id := range m.agents {
		ids = append(ids, id)
	}
	return
}

// ResetAgents resets all changes to the "agents" edge.
func (m *SiteMutation) ResetAgents() {
	m.agents = nil
	m.clearedagents = false
	m.removedagents = nil
}

// AddProfileIDs adds the "profiles" edge to the Profile entity by ids.
func (m *SiteMutation) AddProfileIDs(ids ...int) {
	if m.profiles == nil {
		m.profiles = make(map[int]struct{})
	}
	for i := range ids {
		m.profiles[ids[i]] = struct{}{}
	}
}

// ClearProfiles clears the "profiles" edge to the Profile entity.
func (m *SiteMutation) ClearProfiles() {
	m.clearedprofiles = true
}

// ProfilesCleared reports if the "profiles" edge to the Profile entity was cleared.
func (m *SiteMutation) ProfilesCleared() bool {
	return m.clearedprofiles
}

// RemoveProfileIDs removes the "profiles" edge to the Profile entity by IDs.
func (m *SiteMutation) RemoveProfileIDs(ids ...int) {
	if m.removedprofiles == nil {
		m.removedprofiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.profiles, ids[i])
		m.removedprofiles[ids[i]] = struct{}{}
	}
}

// RemovedProfiles returns the removed IDs of the "profiles" edge to the Profile entity.
func (m *SiteMutation) RemovedProfilesIDs() (ids []int) {
	for id := range m.removedprofiles {
		ids = append(ids, id)
	}
	return
}

// ProfilesIDs returns the "profiles" edge IDs in the mutation.
func (m *SiteMutation) ProfilesIDs() (ids []int) {
	for id := range m.profiles {
		ids = append(ids, id)
	}
	return
}

// ResetProfiles resets all changes to the "profiles" edge.
func (m *SiteMutation) ResetProfiles() {
	m.profiles = nil
	m.clearedprofiles = false
	m.removedprofiles = nil
}

// Where appends a list predicates to the SiteMutation builder.
func (m *SiteMutation) Where(ps ...predicate.Site) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SiteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SiteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Site, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SiteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SiteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Site).
func (m *SiteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SiteMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.description != nil {
		fields = append(fields, site.FieldDescription)
	}
	if m.is_default != nil {
		fields = append(fields, site.FieldIsDefault)
	}
	if m.domain != nil {
		fields = append(fields, site.FieldDomain)
	}
	if m.created != nil {
		fields = append(fields, site.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, site.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SiteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case site.FieldDescription:
		return m.Description()
	case site.FieldIsDefault:
		return m.IsDefault()
	case site.FieldDomain:
		return m.Domain()
	case site.FieldCreated:
		return m.Created()
	case site.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SiteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case site.FieldDescription:
		return m.OldDescription(ctx)
	case site.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case site.FieldDomain:
		return m.OldDomain(ctx)
	case site.FieldCreated:
		return m.OldCreated(ctx)
	case site.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown Site field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SiteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case site.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case site.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case site.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case site.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case site.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown Site field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SiteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SiteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SiteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Site numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SiteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(site.FieldDescription) {
		fields = append(fields, site.FieldDescription)
	}
	if m.FieldCleared(site.FieldIsDefault) {
		fields = append(fields, site.FieldIsDefault)
	}
	if m.FieldCleared(site.FieldDomain) {
		fields = append(fields, site.FieldDomain)
	}
	if m.FieldCleared(site.FieldCreated) {
		fields = append(fields, site.FieldCreated)
	}
	if m.FieldCleared(site.FieldModified) {
		fields = append(fields, site.FieldModified)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SiteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SiteMutation) ClearField(name string) error {
	switch name {
	case site.FieldDescription:
		m.ClearDescription()
		return nil
	case site.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	case site.FieldDomain:
		m.ClearDomain()
		return nil
	case site.FieldCreated:
		m.ClearCreated()
		return nil
	case site.FieldModified:
		m.ClearModified()
		return nil
	}
	return fmt.Errorf("unknown Site nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SiteMutation) ResetField(name string) error {
	switch name {
	case site.FieldDescription:
		m.ResetDescription()
		return nil
	case site.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case site.FieldDomain:
		m.ResetDomain()
		return nil
	case site.FieldCreated:
		m.ResetCreated()
		return nil
	case site.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown Site field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SiteMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, site.EdgeTenant)
	}
	if m.agents != nil {
		edges = append(edges, site.EdgeAgents)
	}
	if m.profiles != nil {
		edges = append(edges, site.EdgeProfiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SiteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case site.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case site.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.agents))
		for id := range m.agents {
			ids = append(ids, id)
		}
		return ids
	case site.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.profiles))
		for id := range m.profiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SiteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedagents != nil {
		edges = append(edges, site.EdgeAgents)
	}
	if m.removedprofiles != nil {
		edges = append(edges, site.EdgeProfiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SiteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case site.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.removedagents))
		for id := range m.removedagents {
			ids = append(ids, id)
		}
		return ids
	case site.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.removedprofiles))
		for id := range m.removedprofiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SiteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, site.EdgeTenant)
	}
	if m.clearedagents {
		edges = append(edges, site.EdgeAgents)
	}
	if m.clearedprofiles {
		edges = append(edges, site.EdgeProfiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SiteMutation) EdgeCleared(name string) bool {
	switch name {
	case site.EdgeTenant:
		return m.clearedtenant
	case site.EdgeAgents:
		return m.clearedagents
	case site.EdgeProfiles:
		return m.clearedprofiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SiteMutation) ClearEdge(name string) error {
	switch name {
	case site.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Site unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SiteMutation) ResetEdge(name string) error {
	switch name {
	case site.EdgeTenant:
		m.ResetTenant()
		return nil
	case site.EdgeAgents:
		m.ResetAgents()
		return nil
	case site.EdgeProfiles:
		m.ResetProfiles()
		return nil
	}
	return fmt.Errorf("unknown Site edge %s", name)
}

// SystemUpdateMutation represents an operation that mutates the SystemUpdate nodes in the graph.
type SystemUpdateMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	system_update_status *string
	last_install         *time.Time
	last_search          *time.Time
	pending_updates      *bool
	clearedFields        map[string]struct{}
	owner                *string
	clearedowner         bool
	done                 bool
	oldValue             func(context.Context) (*SystemUpdate, error)
	predicates           []predicate.SystemUpdate
}

var _ ent.Mutation = (*SystemUpdateMutation)(nil)

// systemupdateOption allows management of the mutation configuration using functional options.
type systemupdateOption func(*SystemUpdateMutation)

// newSystemUpdateMutation creates new mutation for the SystemUpdate entity.
func newSystemUpdateMutation(c config, op Op, opts ...systemupdateOption) *SystemUpdateMutation {
	m := &SystemUpdateMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemUpdate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemUpdateID sets the ID field of the mutation.
func withSystemUpdateID(id int) systemupdateOption {
	return func(m *SystemUpdateMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemUpdate
		)
		m.oldValue = func(ctx context.Context) (*SystemUpdate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemUpdate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemUpdate sets the old SystemUpdate of the mutation.
func withSystemUpdate(node *SystemUpdate) systemupdateOption {
	return func(m *SystemUpdateMutation) {
		m.oldValue = func(context.Context) (*SystemUpdate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemUpdateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemUpdateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemUpdateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemUpdateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemUpdate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSystemUpdateStatus sets the "system_update_status" field.
func (m *SystemUpdateMutation) SetSystemUpdateStatus(s string) {
	m.system_update_status = &s
}

// SystemUpdateStatus returns the value of the "system_update_status" field in the mutation.
func (m *SystemUpdateMutation) SystemUpdateStatus() (r string, exists bool) {
	v := m.system_update_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemUpdateStatus returns the old "system_update_status" field's value of the SystemUpdate entity.
// If the SystemUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemUpdateMutation) OldSystemUpdateStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemUpdateStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemUpdateStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemUpdateStatus: %w", err)
	}
	return oldValue.SystemUpdateStatus, nil
}

// ResetSystemUpdateStatus resets all changes to the "system_update_status" field.
func (m *SystemUpdateMutation) ResetSystemUpdateStatus() {
	m.system_update_status = nil
}

// SetLastInstall sets the "last_install" field.
func (m *SystemUpdateMutation) SetLastInstall(t time.Time) {
	m.last_install = &t
}

// LastInstall returns the value of the "last_install" field in the mutation.
func (m *SystemUpdateMutation) LastInstall() (r time.Time, exists bool) {
	v := m.last_install
	if v == nil {
		return
	}
	return *v, true
}

// OldLastInstall returns the old "last_install" field's value of the SystemUpdate entity.
// If the SystemUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemUpdateMutation) OldLastInstall(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastInstall is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastInstall requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastInstall: %w", err)
	}
	return oldValue.LastInstall, nil
}

// ResetLastInstall resets all changes to the "last_install" field.
func (m *SystemUpdateMutation) ResetLastInstall() {
	m.last_install = nil
}

// SetLastSearch sets the "last_search" field.
func (m *SystemUpdateMutation) SetLastSearch(t time.Time) {
	m.last_search = &t
}

// LastSearch returns the value of the "last_search" field in the mutation.
func (m *SystemUpdateMutation) LastSearch() (r time.Time, exists bool) {
	v := m.last_search
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSearch returns the old "last_search" field's value of the SystemUpdate entity.
// If the SystemUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemUpdateMutation) OldLastSearch(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSearch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSearch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSearch: %w", err)
	}
	return oldValue.LastSearch, nil
}

// ResetLastSearch resets all changes to the "last_search" field.
func (m *SystemUpdateMutation) ResetLastSearch() {
	m.last_search = nil
}

// SetPendingUpdates sets the "pending_updates" field.
func (m *SystemUpdateMutation) SetPendingUpdates(b bool) {
	m.pending_updates = &b
}

// PendingUpdates returns the value of the "pending_updates" field in the mutation.
func (m *SystemUpdateMutation) PendingUpdates() (r bool, exists bool) {
	v := m.pending_updates
	if v == nil {
		return
	}
	return *v, true
}

// OldPendingUpdates returns the old "pending_updates" field's value of the SystemUpdate entity.
// If the SystemUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemUpdateMutation) OldPendingUpdates(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPendingUpdates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPendingUpdates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPendingUpdates: %w", err)
	}
	return oldValue.PendingUpdates, nil
}

// ResetPendingUpdates resets all changes to the "pending_updates" field.
func (m *SystemUpdateMutation) ResetPendingUpdates() {
	m.pending_updates = nil
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *SystemUpdateMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *SystemUpdateMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *SystemUpdateMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *SystemUpdateMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SystemUpdateMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *SystemUpdateMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the SystemUpdateMutation builder.
func (m *SystemUpdateMutation) Where(ps ...predicate.SystemUpdate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemUpdateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemUpdateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemUpdate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemUpdateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemUpdateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemUpdate).
func (m *SystemUpdateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemUpdateMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.system_update_status != nil {
		fields = append(fields, systemupdate.FieldSystemUpdateStatus)
	}
	if m.last_install != nil {
		fields = append(fields, systemupdate.FieldLastInstall)
	}
	if m.last_search != nil {
		fields = append(fields, systemupdate.FieldLastSearch)
	}
	if m.pending_updates != nil {
		fields = append(fields, systemupdate.FieldPendingUpdates)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemUpdateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemupdate.FieldSystemUpdateStatus:
		return m.SystemUpdateStatus()
	case systemupdate.FieldLastInstall:
		return m.LastInstall()
	case systemupdate.FieldLastSearch:
		return m.LastSearch()
	case systemupdate.FieldPendingUpdates:
		return m.PendingUpdates()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemUpdateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemupdate.FieldSystemUpdateStatus:
		return m.OldSystemUpdateStatus(ctx)
	case systemupdate.FieldLastInstall:
		return m.OldLastInstall(ctx)
	case systemupdate.FieldLastSearch:
		return m.OldLastSearch(ctx)
	case systemupdate.FieldPendingUpdates:
		return m.OldPendingUpdates(ctx)
	}
	return nil, fmt.Errorf("unknown SystemUpdate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemUpdateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemupdate.FieldSystemUpdateStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemUpdateStatus(v)
		return nil
	case systemupdate.FieldLastInstall:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastInstall(v)
		return nil
	case systemupdate.FieldLastSearch:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSearch(v)
		return nil
	case systemupdate.FieldPendingUpdates:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPendingUpdates(v)
		return nil
	}
	return fmt.Errorf("unknown SystemUpdate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemUpdateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemUpdateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemUpdateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemUpdate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemUpdateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemUpdateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemUpdateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SystemUpdate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemUpdateMutation) ResetField(name string) error {
	switch name {
	case systemupdate.FieldSystemUpdateStatus:
		m.ResetSystemUpdateStatus()
		return nil
	case systemupdate.FieldLastInstall:
		m.ResetLastInstall()
		return nil
	case systemupdate.FieldLastSearch:
		m.ResetLastSearch()
		return nil
	case systemupdate.FieldPendingUpdates:
		m.ResetPendingUpdates()
		return nil
	}
	return fmt.Errorf("unknown SystemUpdate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemUpdateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, systemupdate.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemUpdateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemupdate.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemUpdateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemUpdateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemUpdateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, systemupdate.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemUpdateMutation) EdgeCleared(name string) bool {
	switch name {
	case systemupdate.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemUpdateMutation) ClearEdge(name string) error {
	switch name {
	case systemupdate.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown SystemUpdate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemUpdateMutation) ResetEdge(name string) error {
	switch name {
	case systemupdate.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown SystemUpdate edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op              Op
	typ             string
	id              *int
	tag             *string
	description     *string
	color           *string
	clearedFields   map[string]struct{}
	owner           map[string]struct{}
	removedowner    map[string]struct{}
	clearedowner    bool
	parent          *int
	clearedparent   bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	clearedchildren bool
	profile         map[int]struct{}
	removedprofile  map[int]struct{}
	clearedprofile  bool
	tenant          *int
	clearedtenant   bool
	done            bool
	oldValue        func(context.Context) (*Tag, error)
	predicates      []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTag sets the "tag" field.
func (m *TagMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *TagMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag resets all changes to the "tag" field.
func (m *TagMutation) ResetTag() {
	m.tag = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tag.FieldDescription)
}

// SetColor sets the "color" field.
func (m *TagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *TagMutation) ResetColor() {
	m.color = nil
}

// AddOwnerIDs adds the "owner" edge to the Agent entity by ids.
func (m *TagMutation) AddOwnerIDs(ids ...string) {
	if m.owner == nil {
		m.owner = make(map[string]struct{})
	}
	for i := range ids {
		m.owner[ids[i]] = struct{}{}
	}
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *TagMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *TagMutation) OwnerCleared() bool {
	return m.clearedowner
}

// RemoveOwnerIDs removes the "owner" edge to the Agent entity by IDs.
func (m *TagMutation) RemoveOwnerIDs(ids ...string) {
	if m.removedowner == nil {
		m.removedowner = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.owner, ids[i])
		m.removedowner[ids[i]] = struct{}{}
	}
}

// RemovedOwner returns the removed IDs of the "owner" edge to the Agent entity.
func (m *TagMutation) RemovedOwnerIDs() (ids []string) {
	for id := range m.removedowner {
		ids = append(ids, id)
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
func (m *TagMutation) OwnerIDs() (ids []string) {
	for id := range m.owner {
		ids = append(ids, id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TagMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
	m.removedowner = nil
}

// SetParentID sets the "parent" edge to the Tag entity by id.
func (m *TagMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Tag entity.
func (m *TagMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Tag entity was cleared.
func (m *TagMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *TagMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TagMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TagMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Tag entity by ids.
func (m *TagMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Tag entity.
func (m *TagMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Tag entity was cleared.
func (m *TagMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Tag entity by IDs.
func (m *TagMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Tag entity.
func (m *TagMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TagMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TagMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddProfileIDs adds the "profile" edge to the Profile entity by ids.
func (m *TagMutation) AddProfileIDs(ids ...int) {
	if m.profile == nil {
		m.profile = make(map[int]struct{})
	}
	for i := range ids {
		m.profile[ids[i]] = struct{}{}
	}
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *TagMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *TagMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// RemoveProfileIDs removes the "profile" edge to the Profile entity by IDs.
func (m *TagMutation) RemoveProfileIDs(ids ...int) {
	if m.removedprofile == nil {
		m.removedprofile = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.profile, ids[i])
		m.removedprofile[ids[i]] = struct{}{}
	}
}

// RemovedProfile returns the removed IDs of the "profile" edge to the Profile entity.
func (m *TagMutation) RemovedProfileIDs() (ids []int) {
	for id := range m.removedprofile {
		ids = append(ids, id)
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
func (m *TagMutation) ProfileIDs() (ids []int) {
	for id := range m.profile {
		ids = append(ids, id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *TagMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
	m.removedprofile = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *TagMutation) SetTenantID(id int) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TagMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TagMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *TagMutation) TenantID() (id int, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TagMutation) TenantIDs() (ids []int) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TagMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tag != nil {
		fields = append(fields, tag.FieldTag)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldTag:
		return m.Tag()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldTag:
		return m.OldTag(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDescription) {
		fields = append(fields, tag.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldTag:
		m.ResetTag()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, tag.EdgeOwner)
	}
	if m.parent != nil {
		edges = append(edges, tag.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, tag.EdgeChildren)
	}
	if m.profile != nil {
		edges = append(edges, tag.EdgeProfile)
	}
	if m.tenant != nil {
		edges = append(edges, tag.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeOwner:
		ids := make([]ent.Value, 0, len(m.owner))
		for id := range m.owner {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeProfile:
		ids := make([]ent.Value, 0, len(m.profile))
		for id := range m.profile {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedowner != nil {
		edges = append(edges, tag.EdgeOwner)
	}
	if m.removedchildren != nil {
		edges = append(edges, tag.EdgeChildren)
	}
	if m.removedprofile != nil {
		edges = append(edges, tag.EdgeProfile)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeOwner:
		ids := make([]ent.Value, 0, len(m.removedowner))
		for id := range m.removedowner {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeProfile:
		ids := make([]ent.Value, 0, len(m.removedprofile))
		for id := range m.removedprofile {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, tag.EdgeOwner)
	}
	if m.clearedparent {
		edges = append(edges, tag.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, tag.EdgeChildren)
	}
	if m.clearedprofile {
		edges = append(edges, tag.EdgeProfile)
	}
	if m.clearedtenant {
		edges = append(edges, tag.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeOwner:
		return m.clearedowner
	case tag.EdgeParent:
		return m.clearedparent
	case tag.EdgeChildren:
		return m.clearedchildren
	case tag.EdgeProfile:
		return m.clearedprofile
	case tag.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeParent:
		m.ClearParent()
		return nil
	case tag.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeOwner:
		m.ResetOwner()
		return nil
	case tag.EdgeParent:
		m.ResetParent()
		return nil
	case tag.EdgeChildren:
		m.ResetChildren()
		return nil
	case tag.EdgeProfile:
		m.ResetProfile()
		return nil
	case tag.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                                         Op
	typ                                        string
	id                                         *int
	name                                       *string
	_type                                      *task.Type
	package_id                                 *string
	package_name                               *string
	package_latest                             *bool
	registry_key                               *string
	registry_key_value_name                    *string
	registry_key_value_type                    *task.RegistryKeyValueType
	registry_key_value_data                    *string
	registry_hex                               *bool
	registry_force                             *bool
	local_user_username                        *string
	local_user_description                     *string
	local_user_disable                         *bool
	local_user_fullname                        *string
	local_user_password                        *string
	local_user_password_change_not_allowed     *bool
	local_user_password_change_required        *bool
	local_user_password_never_expires          *bool
	local_user_append                          *bool
	local_user_create_home                     *bool
	local_user_expires                         *string
	local_user_force                           *bool
	local_user_generate_ssh_key                *bool
	local_user_group                           *string
	local_user_groups                          *string
	local_user_home                            *string
	local_user_move_home                       *bool
	local_user_nonunique                       *bool
	local_user_password_expire_account_disable *string
	local_user_password_expire_max             *string
	local_user_password_expire_min             *string
	local_user_password_expire_warn            *string
	local_user_password_lock                   *bool
	local_user_seuser                          *string
	local_user_shell                           *string
	local_user_skeleton                        *string
	local_user_system                          *bool
	local_user_id                              *string
	local_user_id_max                          *string
	local_user_id_min                          *string
	local_user_ssh_key_bits                    *string
	local_user_ssh_key_comment                 *string
	local_user_ssh_key_file                    *string
	local_user_ssh_key_passphrase              *string
	local_user_ssh_key_type                    *string
	local_user_umask                           *string
	local_group_id                             *string
	local_group_name                           *string
	local_group_description                    *string
	local_group_system                         *bool
	local_group_force                          *bool
	local_group_members                        *string
	local_group_members_to_include             *string
	local_group_members_to_exclude             *string
	msi_productid                              *string
	msi_path                                   *string
	msi_arguments                              *string
	msi_file_hash                              *string
	msi_file_hash_alg                          *task.MsiFileHashAlg
	msi_log_path                               *string
	script                                     *string
	script_executable                          *string
	script_creates                             *string
	script_run                                 *task.ScriptRun
	agent_type                                 *task.AgentType
	when                                       *time.Time
	brew_update                                *bool
	brew_upgrade_all                           *bool
	brew_upgrade_options                       *string
	brew_install_options                       *string
	brew_greedy                                *bool
	package_version                            *string
	apt_allow_downgrade                        *bool
	apt_deb                                    *string
	apt_dpkg_options                           *string
	apt_fail_on_autoremove                     *bool
	apt_force                                  *bool
	apt_install_recommends                     *bool
	apt_name                                   *string
	apt_only_upgrade                           *bool
	apt_purge                                  *bool
	apt_update_cache                           *bool
	apt_upgrade_type                           *task.AptUpgradeType
	version                                    *int
	addversion                                 *int
	tenant                                     *int
	addtenant                                  *int
	netbird_groups                             *string
	netbird_allow_extra_dns_labels             *bool
	clearedFields                              map[string]struct{}
	tags                                       map[int]struct{}
	removedtags                                map[int]struct{}
	clearedtags                                bool
	profile                                    *int
	clearedprofile                             bool
	done                                       bool
	oldValue                                   func(context.Context) (*Task, error)
	predicates                                 []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *TaskMutation) SetType(t task.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskMutation) GetType() (r task.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldType(ctx context.Context) (v task.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TaskMutation) ResetType() {
	m._type = nil
}

// SetPackageID sets the "package_id" field.
func (m *TaskMutation) SetPackageID(s string) {
	m.package_id = &s
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *TaskMutation) PackageID() (r string, exists bool) {
	v := m.package_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPackageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *TaskMutation) ClearPackageID() {
	m.package_id = nil
	m.clearedFields[task.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *TaskMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[task.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *TaskMutation) ResetPackageID() {
	m.package_id = nil
	delete(m.clearedFields, task.FieldPackageID)
}

// SetPackageName sets the "package_name" field.
func (m *TaskMutation) SetPackageName(s string) {
	m.package_name = &s
}

// PackageName returns the value of the "package_name" field in the mutation.
func (m *TaskMutation) PackageName() (r string, exists bool) {
	v := m.package_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageName returns the old "package_name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPackageName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageName: %w", err)
	}
	return oldValue.PackageName, nil
}

// ClearPackageName clears the value of the "package_name" field.
func (m *TaskMutation) ClearPackageName() {
	m.package_name = nil
	m.clearedFields[task.FieldPackageName] = struct{}{}
}

// PackageNameCleared returns if the "package_name" field was cleared in this mutation.
func (m *TaskMutation) PackageNameCleared() bool {
	_, ok := m.clearedFields[task.FieldPackageName]
	return ok
}

// ResetPackageName resets all changes to the "package_name" field.
func (m *TaskMutation) ResetPackageName() {
	m.package_name = nil
	delete(m.clearedFields, task.FieldPackageName)
}

// SetPackageLatest sets the "package_latest" field.
func (m *TaskMutation) SetPackageLatest(b bool) {
	m.package_latest = &b
}

// PackageLatest returns the value of the "package_latest" field in the mutation.
func (m *TaskMutation) PackageLatest() (r bool, exists bool) {
	v := m.package_latest
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageLatest returns the old "package_latest" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPackageLatest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageLatest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageLatest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageLatest: %w", err)
	}
	return oldValue.PackageLatest, nil
}

// ClearPackageLatest clears the value of the "package_latest" field.
func (m *TaskMutation) ClearPackageLatest() {
	m.package_latest = nil
	m.clearedFields[task.FieldPackageLatest] = struct{}{}
}

// PackageLatestCleared returns if the "package_latest" field was cleared in this mutation.
func (m *TaskMutation) PackageLatestCleared() bool {
	_, ok := m.clearedFields[task.FieldPackageLatest]
	return ok
}

// ResetPackageLatest resets all changes to the "package_latest" field.
func (m *TaskMutation) ResetPackageLatest() {
	m.package_latest = nil
	delete(m.clearedFields, task.FieldPackageLatest)
}

// SetRegistryKey sets the "registry_key" field.
func (m *TaskMutation) SetRegistryKey(s string) {
	m.registry_key = &s
}

// RegistryKey returns the value of the "registry_key" field in the mutation.
func (m *TaskMutation) RegistryKey() (r string, exists bool) {
	v := m.registry_key
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistryKey returns the old "registry_key" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRegistryKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistryKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistryKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistryKey: %w", err)
	}
	return oldValue.RegistryKey, nil
}

// ClearRegistryKey clears the value of the "registry_key" field.
func (m *TaskMutation) ClearRegistryKey() {
	m.registry_key = nil
	m.clearedFields[task.FieldRegistryKey] = struct{}{}
}

// RegistryKeyCleared returns if the "registry_key" field was cleared in this mutation.
func (m *TaskMutation) RegistryKeyCleared() bool {
	_, ok := m.clearedFields[task.FieldRegistryKey]
	return ok
}

// ResetRegistryKey resets all changes to the "registry_key" field.
func (m *TaskMutation) ResetRegistryKey() {
	m.registry_key = nil
	delete(m.clearedFields, task.FieldRegistryKey)
}

// SetRegistryKeyValueName sets the "registry_key_value_name" field.
func (m *TaskMutation) SetRegistryKeyValueName(s string) {
	m.registry_key_value_name = &s
}

// RegistryKeyValueName returns the value of the "registry_key_value_name" field in the mutation.
func (m *TaskMutation) RegistryKeyValueName() (r string, exists bool) {
	v := m.registry_key_value_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistryKeyValueName returns the old "registry_key_value_name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRegistryKeyValueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistryKeyValueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistryKeyValueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistryKeyValueName: %w", err)
	}
	return oldValue.RegistryKeyValueName, nil
}

// ClearRegistryKeyValueName clears the value of the "registry_key_value_name" field.
func (m *TaskMutation) ClearRegistryKeyValueName() {
	m.registry_key_value_name = nil
	m.clearedFields[task.FieldRegistryKeyValueName] = struct{}{}
}

// RegistryKeyValueNameCleared returns if the "registry_key_value_name" field was cleared in this mutation.
func (m *TaskMutation) RegistryKeyValueNameCleared() bool {
	_, ok := m.clearedFields[task.FieldRegistryKeyValueName]
	return ok
}

// ResetRegistryKeyValueName resets all changes to the "registry_key_value_name" field.
func (m *TaskMutation) ResetRegistryKeyValueName() {
	m.registry_key_value_name = nil
	delete(m.clearedFields, task.FieldRegistryKeyValueName)
}

// SetRegistryKeyValueType sets the "registry_key_value_type" field.
func (m *TaskMutation) SetRegistryKeyValueType(tkvt task.RegistryKeyValueType) {
	m.registry_key_value_type = &tkvt
}

// RegistryKeyValueType returns the value of the "registry_key_value_type" field in the mutation.
func (m *TaskMutation) RegistryKeyValueType() (r task.RegistryKeyValueType, exists bool) {
	v := m.registry_key_value_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistryKeyValueType returns the old "registry_key_value_type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRegistryKeyValueType(ctx context.Context) (v task.RegistryKeyValueType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistryKeyValueType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistryKeyValueType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistryKeyValueType: %w", err)
	}
	return oldValue.RegistryKeyValueType, nil
}

// ClearRegistryKeyValueType clears the value of the "registry_key_value_type" field.
func (m *TaskMutation) ClearRegistryKeyValueType() {
	m.registry_key_value_type = nil
	m.clearedFields[task.FieldRegistryKeyValueType] = struct{}{}
}

// RegistryKeyValueTypeCleared returns if the "registry_key_value_type" field was cleared in this mutation.
func (m *TaskMutation) RegistryKeyValueTypeCleared() bool {
	_, ok := m.clearedFields[task.FieldRegistryKeyValueType]
	return ok
}

// ResetRegistryKeyValueType resets all changes to the "registry_key_value_type" field.
func (m *TaskMutation) ResetRegistryKeyValueType() {
	m.registry_key_value_type = nil
	delete(m.clearedFields, task.FieldRegistryKeyValueType)
}

// SetRegistryKeyValueData sets the "registry_key_value_data" field.
func (m *TaskMutation) SetRegistryKeyValueData(s string) {
	m.registry_key_value_data = &s
}

// RegistryKeyValueData returns the value of the "registry_key_value_data" field in the mutation.
func (m *TaskMutation) RegistryKeyValueData() (r string, exists bool) {
	v := m.registry_key_value_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistryKeyValueData returns the old "registry_key_value_data" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRegistryKeyValueData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistryKeyValueData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistryKeyValueData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistryKeyValueData: %w", err)
	}
	return oldValue.RegistryKeyValueData, nil
}

// ClearRegistryKeyValueData clears the value of the "registry_key_value_data" field.
func (m *TaskMutation) ClearRegistryKeyValueData() {
	m.registry_key_value_data = nil
	m.clearedFields[task.FieldRegistryKeyValueData] = struct{}{}
}

// RegistryKeyValueDataCleared returns if the "registry_key_value_data" field was cleared in this mutation.
func (m *TaskMutation) RegistryKeyValueDataCleared() bool {
	_, ok := m.clearedFields[task.FieldRegistryKeyValueData]
	return ok
}

// ResetRegistryKeyValueData resets all changes to the "registry_key_value_data" field.
func (m *TaskMutation) ResetRegistryKeyValueData() {
	m.registry_key_value_data = nil
	delete(m.clearedFields, task.FieldRegistryKeyValueData)
}

// SetRegistryHex sets the "registry_hex" field.
func (m *TaskMutation) SetRegistryHex(b bool) {
	m.registry_hex = &b
}

// RegistryHex returns the value of the "registry_hex" field in the mutation.
func (m *TaskMutation) RegistryHex() (r bool, exists bool) {
	v := m.registry_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistryHex returns the old "registry_hex" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRegistryHex(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistryHex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistryHex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistryHex: %w", err)
	}
	return oldValue.RegistryHex, nil
}

// ClearRegistryHex clears the value of the "registry_hex" field.
func (m *TaskMutation) ClearRegistryHex() {
	m.registry_hex = nil
	m.clearedFields[task.FieldRegistryHex] = struct{}{}
}

// RegistryHexCleared returns if the "registry_hex" field was cleared in this mutation.
func (m *TaskMutation) RegistryHexCleared() bool {
	_, ok := m.clearedFields[task.FieldRegistryHex]
	return ok
}

// ResetRegistryHex resets all changes to the "registry_hex" field.
func (m *TaskMutation) ResetRegistryHex() {
	m.registry_hex = nil
	delete(m.clearedFields, task.FieldRegistryHex)
}

// SetRegistryForce sets the "registry_force" field.
func (m *TaskMutation) SetRegistryForce(b bool) {
	m.registry_force = &b
}

// RegistryForce returns the value of the "registry_force" field in the mutation.
func (m *TaskMutation) RegistryForce() (r bool, exists bool) {
	v := m.registry_force
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistryForce returns the old "registry_force" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRegistryForce(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistryForce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistryForce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistryForce: %w", err)
	}
	return oldValue.RegistryForce, nil
}

// ClearRegistryForce clears the value of the "registry_force" field.
func (m *TaskMutation) ClearRegistryForce() {
	m.registry_force = nil
	m.clearedFields[task.FieldRegistryForce] = struct{}{}
}

// RegistryForceCleared returns if the "registry_force" field was cleared in this mutation.
func (m *TaskMutation) RegistryForceCleared() bool {
	_, ok := m.clearedFields[task.FieldRegistryForce]
	return ok
}

// ResetRegistryForce resets all changes to the "registry_force" field.
func (m *TaskMutation) ResetRegistryForce() {
	m.registry_force = nil
	delete(m.clearedFields, task.FieldRegistryForce)
}

// SetLocalUserUsername sets the "local_user_username" field.
func (m *TaskMutation) SetLocalUserUsername(s string) {
	m.local_user_username = &s
}

// LocalUserUsername returns the value of the "local_user_username" field in the mutation.
func (m *TaskMutation) LocalUserUsername() (r string, exists bool) {
	v := m.local_user_username
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserUsername returns the old "local_user_username" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserUsername: %w", err)
	}
	return oldValue.LocalUserUsername, nil
}

// ClearLocalUserUsername clears the value of the "local_user_username" field.
func (m *TaskMutation) ClearLocalUserUsername() {
	m.local_user_username = nil
	m.clearedFields[task.FieldLocalUserUsername] = struct{}{}
}

// LocalUserUsernameCleared returns if the "local_user_username" field was cleared in this mutation.
func (m *TaskMutation) LocalUserUsernameCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserUsername]
	return ok
}

// ResetLocalUserUsername resets all changes to the "local_user_username" field.
func (m *TaskMutation) ResetLocalUserUsername() {
	m.local_user_username = nil
	delete(m.clearedFields, task.FieldLocalUserUsername)
}

// SetLocalUserDescription sets the "local_user_description" field.
func (m *TaskMutation) SetLocalUserDescription(s string) {
	m.local_user_description = &s
}

// LocalUserDescription returns the value of the "local_user_description" field in the mutation.
func (m *TaskMutation) LocalUserDescription() (r string, exists bool) {
	v := m.local_user_description
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserDescription returns the old "local_user_description" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserDescription: %w", err)
	}
	return oldValue.LocalUserDescription, nil
}

// ClearLocalUserDescription clears the value of the "local_user_description" field.
func (m *TaskMutation) ClearLocalUserDescription() {
	m.local_user_description = nil
	m.clearedFields[task.FieldLocalUserDescription] = struct{}{}
}

// LocalUserDescriptionCleared returns if the "local_user_description" field was cleared in this mutation.
func (m *TaskMutation) LocalUserDescriptionCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserDescription]
	return ok
}

// ResetLocalUserDescription resets all changes to the "local_user_description" field.
func (m *TaskMutation) ResetLocalUserDescription() {
	m.local_user_description = nil
	delete(m.clearedFields, task.FieldLocalUserDescription)
}

// SetLocalUserDisable sets the "local_user_disable" field.
func (m *TaskMutation) SetLocalUserDisable(b bool) {
	m.local_user_disable = &b
}

// LocalUserDisable returns the value of the "local_user_disable" field in the mutation.
func (m *TaskMutation) LocalUserDisable() (r bool, exists bool) {
	v := m.local_user_disable
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserDisable returns the old "local_user_disable" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserDisable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserDisable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserDisable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserDisable: %w", err)
	}
	return oldValue.LocalUserDisable, nil
}

// ClearLocalUserDisable clears the value of the "local_user_disable" field.
func (m *TaskMutation) ClearLocalUserDisable() {
	m.local_user_disable = nil
	m.clearedFields[task.FieldLocalUserDisable] = struct{}{}
}

// LocalUserDisableCleared returns if the "local_user_disable" field was cleared in this mutation.
func (m *TaskMutation) LocalUserDisableCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserDisable]
	return ok
}

// ResetLocalUserDisable resets all changes to the "local_user_disable" field.
func (m *TaskMutation) ResetLocalUserDisable() {
	m.local_user_disable = nil
	delete(m.clearedFields, task.FieldLocalUserDisable)
}

// SetLocalUserFullname sets the "local_user_fullname" field.
func (m *TaskMutation) SetLocalUserFullname(s string) {
	m.local_user_fullname = &s
}

// LocalUserFullname returns the value of the "local_user_fullname" field in the mutation.
func (m *TaskMutation) LocalUserFullname() (r string, exists bool) {
	v := m.local_user_fullname
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserFullname returns the old "local_user_fullname" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserFullname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserFullname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserFullname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserFullname: %w", err)
	}
	return oldValue.LocalUserFullname, nil
}

// ClearLocalUserFullname clears the value of the "local_user_fullname" field.
func (m *TaskMutation) ClearLocalUserFullname() {
	m.local_user_fullname = nil
	m.clearedFields[task.FieldLocalUserFullname] = struct{}{}
}

// LocalUserFullnameCleared returns if the "local_user_fullname" field was cleared in this mutation.
func (m *TaskMutation) LocalUserFullnameCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserFullname]
	return ok
}

// ResetLocalUserFullname resets all changes to the "local_user_fullname" field.
func (m *TaskMutation) ResetLocalUserFullname() {
	m.local_user_fullname = nil
	delete(m.clearedFields, task.FieldLocalUserFullname)
}

// SetLocalUserPassword sets the "local_user_password" field.
func (m *TaskMutation) SetLocalUserPassword(s string) {
	m.local_user_password = &s
}

// LocalUserPassword returns the value of the "local_user_password" field in the mutation.
func (m *TaskMutation) LocalUserPassword() (r string, exists bool) {
	v := m.local_user_password
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserPassword returns the old "local_user_password" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserPassword: %w", err)
	}
	return oldValue.LocalUserPassword, nil
}

// ClearLocalUserPassword clears the value of the "local_user_password" field.
func (m *TaskMutation) ClearLocalUserPassword() {
	m.local_user_password = nil
	m.clearedFields[task.FieldLocalUserPassword] = struct{}{}
}

// LocalUserPasswordCleared returns if the "local_user_password" field was cleared in this mutation.
func (m *TaskMutation) LocalUserPasswordCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserPassword]
	return ok
}

// ResetLocalUserPassword resets all changes to the "local_user_password" field.
func (m *TaskMutation) ResetLocalUserPassword() {
	m.local_user_password = nil
	delete(m.clearedFields, task.FieldLocalUserPassword)
}

// SetLocalUserPasswordChangeNotAllowed sets the "local_user_password_change_not_allowed" field.
func (m *TaskMutation) SetLocalUserPasswordChangeNotAllowed(b bool) {
	m.local_user_password_change_not_allowed = &b
}

// LocalUserPasswordChangeNotAllowed returns the value of the "local_user_password_change_not_allowed" field in the mutation.
func (m *TaskMutation) LocalUserPasswordChangeNotAllowed() (r bool, exists bool) {
	v := m.local_user_password_change_not_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserPasswordChangeNotAllowed returns the old "local_user_password_change_not_allowed" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserPasswordChangeNotAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserPasswordChangeNotAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserPasswordChangeNotAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserPasswordChangeNotAllowed: %w", err)
	}
	return oldValue.LocalUserPasswordChangeNotAllowed, nil
}

// ClearLocalUserPasswordChangeNotAllowed clears the value of the "local_user_password_change_not_allowed" field.
func (m *TaskMutation) ClearLocalUserPasswordChangeNotAllowed() {
	m.local_user_password_change_not_allowed = nil
	m.clearedFields[task.FieldLocalUserPasswordChangeNotAllowed] = struct{}{}
}

// LocalUserPasswordChangeNotAllowedCleared returns if the "local_user_password_change_not_allowed" field was cleared in this mutation.
func (m *TaskMutation) LocalUserPasswordChangeNotAllowedCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserPasswordChangeNotAllowed]
	return ok
}

// ResetLocalUserPasswordChangeNotAllowed resets all changes to the "local_user_password_change_not_allowed" field.
func (m *TaskMutation) ResetLocalUserPasswordChangeNotAllowed() {
	m.local_user_password_change_not_allowed = nil
	delete(m.clearedFields, task.FieldLocalUserPasswordChangeNotAllowed)
}

// SetLocalUserPasswordChangeRequired sets the "local_user_password_change_required" field.
func (m *TaskMutation) SetLocalUserPasswordChangeRequired(b bool) {
	m.local_user_password_change_required = &b
}

// LocalUserPasswordChangeRequired returns the value of the "local_user_password_change_required" field in the mutation.
func (m *TaskMutation) LocalUserPasswordChangeRequired() (r bool, exists bool) {
	v := m.local_user_password_change_required
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserPasswordChangeRequired returns the old "local_user_password_change_required" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserPasswordChangeRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserPasswordChangeRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserPasswordChangeRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserPasswordChangeRequired: %w", err)
	}
	return oldValue.LocalUserPasswordChangeRequired, nil
}

// ClearLocalUserPasswordChangeRequired clears the value of the "local_user_password_change_required" field.
func (m *TaskMutation) ClearLocalUserPasswordChangeRequired() {
	m.local_user_password_change_required = nil
	m.clearedFields[task.FieldLocalUserPasswordChangeRequired] = struct{}{}
}

// LocalUserPasswordChangeRequiredCleared returns if the "local_user_password_change_required" field was cleared in this mutation.
func (m *TaskMutation) LocalUserPasswordChangeRequiredCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserPasswordChangeRequired]
	return ok
}

// ResetLocalUserPasswordChangeRequired resets all changes to the "local_user_password_change_required" field.
func (m *TaskMutation) ResetLocalUserPasswordChangeRequired() {
	m.local_user_password_change_required = nil
	delete(m.clearedFields, task.FieldLocalUserPasswordChangeRequired)
}

// SetLocalUserPasswordNeverExpires sets the "local_user_password_never_expires" field.
func (m *TaskMutation) SetLocalUserPasswordNeverExpires(b bool) {
	m.local_user_password_never_expires = &b
}

// LocalUserPasswordNeverExpires returns the value of the "local_user_password_never_expires" field in the mutation.
func (m *TaskMutation) LocalUserPasswordNeverExpires() (r bool, exists bool) {
	v := m.local_user_password_never_expires
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserPasswordNeverExpires returns the old "local_user_password_never_expires" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserPasswordNeverExpires(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserPasswordNeverExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserPasswordNeverExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserPasswordNeverExpires: %w", err)
	}
	return oldValue.LocalUserPasswordNeverExpires, nil
}

// ClearLocalUserPasswordNeverExpires clears the value of the "local_user_password_never_expires" field.
func (m *TaskMutation) ClearLocalUserPasswordNeverExpires() {
	m.local_user_password_never_expires = nil
	m.clearedFields[task.FieldLocalUserPasswordNeverExpires] = struct{}{}
}

// LocalUserPasswordNeverExpiresCleared returns if the "local_user_password_never_expires" field was cleared in this mutation.
func (m *TaskMutation) LocalUserPasswordNeverExpiresCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserPasswordNeverExpires]
	return ok
}

// ResetLocalUserPasswordNeverExpires resets all changes to the "local_user_password_never_expires" field.
func (m *TaskMutation) ResetLocalUserPasswordNeverExpires() {
	m.local_user_password_never_expires = nil
	delete(m.clearedFields, task.FieldLocalUserPasswordNeverExpires)
}

// SetLocalUserAppend sets the "local_user_append" field.
func (m *TaskMutation) SetLocalUserAppend(b bool) {
	m.local_user_append = &b
}

// LocalUserAppend returns the value of the "local_user_append" field in the mutation.
func (m *TaskMutation) LocalUserAppend() (r bool, exists bool) {
	v := m.local_user_append
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserAppend returns the old "local_user_append" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserAppend(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserAppend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserAppend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserAppend: %w", err)
	}
	return oldValue.LocalUserAppend, nil
}

// ClearLocalUserAppend clears the value of the "local_user_append" field.
func (m *TaskMutation) ClearLocalUserAppend() {
	m.local_user_append = nil
	m.clearedFields[task.FieldLocalUserAppend] = struct{}{}
}

// LocalUserAppendCleared returns if the "local_user_append" field was cleared in this mutation.
func (m *TaskMutation) LocalUserAppendCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserAppend]
	return ok
}

// ResetLocalUserAppend resets all changes to the "local_user_append" field.
func (m *TaskMutation) ResetLocalUserAppend() {
	m.local_user_append = nil
	delete(m.clearedFields, task.FieldLocalUserAppend)
}

// SetLocalUserCreateHome sets the "local_user_create_home" field.
func (m *TaskMutation) SetLocalUserCreateHome(b bool) {
	m.local_user_create_home = &b
}

// LocalUserCreateHome returns the value of the "local_user_create_home" field in the mutation.
func (m *TaskMutation) LocalUserCreateHome() (r bool, exists bool) {
	v := m.local_user_create_home
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserCreateHome returns the old "local_user_create_home" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserCreateHome(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserCreateHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserCreateHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserCreateHome: %w", err)
	}
	return oldValue.LocalUserCreateHome, nil
}

// ClearLocalUserCreateHome clears the value of the "local_user_create_home" field.
func (m *TaskMutation) ClearLocalUserCreateHome() {
	m.local_user_create_home = nil
	m.clearedFields[task.FieldLocalUserCreateHome] = struct{}{}
}

// LocalUserCreateHomeCleared returns if the "local_user_create_home" field was cleared in this mutation.
func (m *TaskMutation) LocalUserCreateHomeCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserCreateHome]
	return ok
}

// ResetLocalUserCreateHome resets all changes to the "local_user_create_home" field.
func (m *TaskMutation) ResetLocalUserCreateHome() {
	m.local_user_create_home = nil
	delete(m.clearedFields, task.FieldLocalUserCreateHome)
}

// SetLocalUserExpires sets the "local_user_expires" field.
func (m *TaskMutation) SetLocalUserExpires(s string) {
	m.local_user_expires = &s
}

// LocalUserExpires returns the value of the "local_user_expires" field in the mutation.
func (m *TaskMutation) LocalUserExpires() (r string, exists bool) {
	v := m.local_user_expires
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserExpires returns the old "local_user_expires" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserExpires(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserExpires: %w", err)
	}
	return oldValue.LocalUserExpires, nil
}

// ClearLocalUserExpires clears the value of the "local_user_expires" field.
func (m *TaskMutation) ClearLocalUserExpires() {
	m.local_user_expires = nil
	m.clearedFields[task.FieldLocalUserExpires] = struct{}{}
}

// LocalUserExpiresCleared returns if the "local_user_expires" field was cleared in this mutation.
func (m *TaskMutation) LocalUserExpiresCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserExpires]
	return ok
}

// ResetLocalUserExpires resets all changes to the "local_user_expires" field.
func (m *TaskMutation) ResetLocalUserExpires() {
	m.local_user_expires = nil
	delete(m.clearedFields, task.FieldLocalUserExpires)
}

// SetLocalUserForce sets the "local_user_force" field.
func (m *TaskMutation) SetLocalUserForce(b bool) {
	m.local_user_force = &b
}

// LocalUserForce returns the value of the "local_user_force" field in the mutation.
func (m *TaskMutation) LocalUserForce() (r bool, exists bool) {
	v := m.local_user_force
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserForce returns the old "local_user_force" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserForce(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserForce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserForce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserForce: %w", err)
	}
	return oldValue.LocalUserForce, nil
}

// ClearLocalUserForce clears the value of the "local_user_force" field.
func (m *TaskMutation) ClearLocalUserForce() {
	m.local_user_force = nil
	m.clearedFields[task.FieldLocalUserForce] = struct{}{}
}

// LocalUserForceCleared returns if the "local_user_force" field was cleared in this mutation.
func (m *TaskMutation) LocalUserForceCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserForce]
	return ok
}

// ResetLocalUserForce resets all changes to the "local_user_force" field.
func (m *TaskMutation) ResetLocalUserForce() {
	m.local_user_force = nil
	delete(m.clearedFields, task.FieldLocalUserForce)
}

// SetLocalUserGenerateSSHKey sets the "local_user_generate_ssh_key" field.
func (m *TaskMutation) SetLocalUserGenerateSSHKey(b bool) {
	m.local_user_generate_ssh_key = &b
}

// LocalUserGenerateSSHKey returns the value of the "local_user_generate_ssh_key" field in the mutation.
func (m *TaskMutation) LocalUserGenerateSSHKey() (r bool, exists bool) {
	v := m.local_user_generate_ssh_key
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserGenerateSSHKey returns the old "local_user_generate_ssh_key" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserGenerateSSHKey(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserGenerateSSHKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserGenerateSSHKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserGenerateSSHKey: %w", err)
	}
	return oldValue.LocalUserGenerateSSHKey, nil
}

// ClearLocalUserGenerateSSHKey clears the value of the "local_user_generate_ssh_key" field.
func (m *TaskMutation) ClearLocalUserGenerateSSHKey() {
	m.local_user_generate_ssh_key = nil
	m.clearedFields[task.FieldLocalUserGenerateSSHKey] = struct{}{}
}

// LocalUserGenerateSSHKeyCleared returns if the "local_user_generate_ssh_key" field was cleared in this mutation.
func (m *TaskMutation) LocalUserGenerateSSHKeyCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserGenerateSSHKey]
	return ok
}

// ResetLocalUserGenerateSSHKey resets all changes to the "local_user_generate_ssh_key" field.
func (m *TaskMutation) ResetLocalUserGenerateSSHKey() {
	m.local_user_generate_ssh_key = nil
	delete(m.clearedFields, task.FieldLocalUserGenerateSSHKey)
}

// SetLocalUserGroup sets the "local_user_group" field.
func (m *TaskMutation) SetLocalUserGroup(s string) {
	m.local_user_group = &s
}

// LocalUserGroup returns the value of the "local_user_group" field in the mutation.
func (m *TaskMutation) LocalUserGroup() (r string, exists bool) {
	v := m.local_user_group
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserGroup returns the old "local_user_group" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserGroup: %w", err)
	}
	return oldValue.LocalUserGroup, nil
}

// ClearLocalUserGroup clears the value of the "local_user_group" field.
func (m *TaskMutation) ClearLocalUserGroup() {
	m.local_user_group = nil
	m.clearedFields[task.FieldLocalUserGroup] = struct{}{}
}

// LocalUserGroupCleared returns if the "local_user_group" field was cleared in this mutation.
func (m *TaskMutation) LocalUserGroupCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserGroup]
	return ok
}

// ResetLocalUserGroup resets all changes to the "local_user_group" field.
func (m *TaskMutation) ResetLocalUserGroup() {
	m.local_user_group = nil
	delete(m.clearedFields, task.FieldLocalUserGroup)
}

// SetLocalUserGroups sets the "local_user_groups" field.
func (m *TaskMutation) SetLocalUserGroups(s string) {
	m.local_user_groups = &s
}

// LocalUserGroups returns the value of the "local_user_groups" field in the mutation.
func (m *TaskMutation) LocalUserGroups() (r string, exists bool) {
	v := m.local_user_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserGroups returns the old "local_user_groups" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserGroups(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserGroups: %w", err)
	}
	return oldValue.LocalUserGroups, nil
}

// ClearLocalUserGroups clears the value of the "local_user_groups" field.
func (m *TaskMutation) ClearLocalUserGroups() {
	m.local_user_groups = nil
	m.clearedFields[task.FieldLocalUserGroups] = struct{}{}
}

// LocalUserGroupsCleared returns if the "local_user_groups" field was cleared in this mutation.
func (m *TaskMutation) LocalUserGroupsCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserGroups]
	return ok
}

// ResetLocalUserGroups resets all changes to the "local_user_groups" field.
func (m *TaskMutation) ResetLocalUserGroups() {
	m.local_user_groups = nil
	delete(m.clearedFields, task.FieldLocalUserGroups)
}

// SetLocalUserHome sets the "local_user_home" field.
func (m *TaskMutation) SetLocalUserHome(s string) {
	m.local_user_home = &s
}

// LocalUserHome returns the value of the "local_user_home" field in the mutation.
func (m *TaskMutation) LocalUserHome() (r string, exists bool) {
	v := m.local_user_home
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserHome returns the old "local_user_home" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserHome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserHome: %w", err)
	}
	return oldValue.LocalUserHome, nil
}

// ClearLocalUserHome clears the value of the "local_user_home" field.
func (m *TaskMutation) ClearLocalUserHome() {
	m.local_user_home = nil
	m.clearedFields[task.FieldLocalUserHome] = struct{}{}
}

// LocalUserHomeCleared returns if the "local_user_home" field was cleared in this mutation.
func (m *TaskMutation) LocalUserHomeCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserHome]
	return ok
}

// ResetLocalUserHome resets all changes to the "local_user_home" field.
func (m *TaskMutation) ResetLocalUserHome() {
	m.local_user_home = nil
	delete(m.clearedFields, task.FieldLocalUserHome)
}

// SetLocalUserMoveHome sets the "local_user_move_home" field.
func (m *TaskMutation) SetLocalUserMoveHome(b bool) {
	m.local_user_move_home = &b
}

// LocalUserMoveHome returns the value of the "local_user_move_home" field in the mutation.
func (m *TaskMutation) LocalUserMoveHome() (r bool, exists bool) {
	v := m.local_user_move_home
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserMoveHome returns the old "local_user_move_home" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserMoveHome(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserMoveHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserMoveHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserMoveHome: %w", err)
	}
	return oldValue.LocalUserMoveHome, nil
}

// ClearLocalUserMoveHome clears the value of the "local_user_move_home" field.
func (m *TaskMutation) ClearLocalUserMoveHome() {
	m.local_user_move_home = nil
	m.clearedFields[task.FieldLocalUserMoveHome] = struct{}{}
}

// LocalUserMoveHomeCleared returns if the "local_user_move_home" field was cleared in this mutation.
func (m *TaskMutation) LocalUserMoveHomeCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserMoveHome]
	return ok
}

// ResetLocalUserMoveHome resets all changes to the "local_user_move_home" field.
func (m *TaskMutation) ResetLocalUserMoveHome() {
	m.local_user_move_home = nil
	delete(m.clearedFields, task.FieldLocalUserMoveHome)
}

// SetLocalUserNonunique sets the "local_user_nonunique" field.
func (m *TaskMutation) SetLocalUserNonunique(b bool) {
	m.local_user_nonunique = &b
}

// LocalUserNonunique returns the value of the "local_user_nonunique" field in the mutation.
func (m *TaskMutation) LocalUserNonunique() (r bool, exists bool) {
	v := m.local_user_nonunique
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserNonunique returns the old "local_user_nonunique" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserNonunique(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserNonunique is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserNonunique requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserNonunique: %w", err)
	}
	return oldValue.LocalUserNonunique, nil
}

// ClearLocalUserNonunique clears the value of the "local_user_nonunique" field.
func (m *TaskMutation) ClearLocalUserNonunique() {
	m.local_user_nonunique = nil
	m.clearedFields[task.FieldLocalUserNonunique] = struct{}{}
}

// LocalUserNonuniqueCleared returns if the "local_user_nonunique" field was cleared in this mutation.
func (m *TaskMutation) LocalUserNonuniqueCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserNonunique]
	return ok
}

// ResetLocalUserNonunique resets all changes to the "local_user_nonunique" field.
func (m *TaskMutation) ResetLocalUserNonunique() {
	m.local_user_nonunique = nil
	delete(m.clearedFields, task.FieldLocalUserNonunique)
}

// SetLocalUserPasswordExpireAccountDisable sets the "local_user_password_expire_account_disable" field.
func (m *TaskMutation) SetLocalUserPasswordExpireAccountDisable(s string) {
	m.local_user_password_expire_account_disable = &s
}

// LocalUserPasswordExpireAccountDisable returns the value of the "local_user_password_expire_account_disable" field in the mutation.
func (m *TaskMutation) LocalUserPasswordExpireAccountDisable() (r string, exists bool) {
	v := m.local_user_password_expire_account_disable
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserPasswordExpireAccountDisable returns the old "local_user_password_expire_account_disable" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserPasswordExpireAccountDisable(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserPasswordExpireAccountDisable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserPasswordExpireAccountDisable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserPasswordExpireAccountDisable: %w", err)
	}
	return oldValue.LocalUserPasswordExpireAccountDisable, nil
}

// ClearLocalUserPasswordExpireAccountDisable clears the value of the "local_user_password_expire_account_disable" field.
func (m *TaskMutation) ClearLocalUserPasswordExpireAccountDisable() {
	m.local_user_password_expire_account_disable = nil
	m.clearedFields[task.FieldLocalUserPasswordExpireAccountDisable] = struct{}{}
}

// LocalUserPasswordExpireAccountDisableCleared returns if the "local_user_password_expire_account_disable" field was cleared in this mutation.
func (m *TaskMutation) LocalUserPasswordExpireAccountDisableCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserPasswordExpireAccountDisable]
	return ok
}

// ResetLocalUserPasswordExpireAccountDisable resets all changes to the "local_user_password_expire_account_disable" field.
func (m *TaskMutation) ResetLocalUserPasswordExpireAccountDisable() {
	m.local_user_password_expire_account_disable = nil
	delete(m.clearedFields, task.FieldLocalUserPasswordExpireAccountDisable)
}

// SetLocalUserPasswordExpireMax sets the "local_user_password_expire_max" field.
func (m *TaskMutation) SetLocalUserPasswordExpireMax(s string) {
	m.local_user_password_expire_max = &s
}

// LocalUserPasswordExpireMax returns the value of the "local_user_password_expire_max" field in the mutation.
func (m *TaskMutation) LocalUserPasswordExpireMax() (r string, exists bool) {
	v := m.local_user_password_expire_max
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserPasswordExpireMax returns the old "local_user_password_expire_max" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserPasswordExpireMax(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserPasswordExpireMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserPasswordExpireMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserPasswordExpireMax: %w", err)
	}
	return oldValue.LocalUserPasswordExpireMax, nil
}

// ClearLocalUserPasswordExpireMax clears the value of the "local_user_password_expire_max" field.
func (m *TaskMutation) ClearLocalUserPasswordExpireMax() {
	m.local_user_password_expire_max = nil
	m.clearedFields[task.FieldLocalUserPasswordExpireMax] = struct{}{}
}

// LocalUserPasswordExpireMaxCleared returns if the "local_user_password_expire_max" field was cleared in this mutation.
func (m *TaskMutation) LocalUserPasswordExpireMaxCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserPasswordExpireMax]
	return ok
}

// ResetLocalUserPasswordExpireMax resets all changes to the "local_user_password_expire_max" field.
func (m *TaskMutation) ResetLocalUserPasswordExpireMax() {
	m.local_user_password_expire_max = nil
	delete(m.clearedFields, task.FieldLocalUserPasswordExpireMax)
}

// SetLocalUserPasswordExpireMin sets the "local_user_password_expire_min" field.
func (m *TaskMutation) SetLocalUserPasswordExpireMin(s string) {
	m.local_user_password_expire_min = &s
}

// LocalUserPasswordExpireMin returns the value of the "local_user_password_expire_min" field in the mutation.
func (m *TaskMutation) LocalUserPasswordExpireMin() (r string, exists bool) {
	v := m.local_user_password_expire_min
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserPasswordExpireMin returns the old "local_user_password_expire_min" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserPasswordExpireMin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserPasswordExpireMin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserPasswordExpireMin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserPasswordExpireMin: %w", err)
	}
	return oldValue.LocalUserPasswordExpireMin, nil
}

// ClearLocalUserPasswordExpireMin clears the value of the "local_user_password_expire_min" field.
func (m *TaskMutation) ClearLocalUserPasswordExpireMin() {
	m.local_user_password_expire_min = nil
	m.clearedFields[task.FieldLocalUserPasswordExpireMin] = struct{}{}
}

// LocalUserPasswordExpireMinCleared returns if the "local_user_password_expire_min" field was cleared in this mutation.
func (m *TaskMutation) LocalUserPasswordExpireMinCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserPasswordExpireMin]
	return ok
}

// ResetLocalUserPasswordExpireMin resets all changes to the "local_user_password_expire_min" field.
func (m *TaskMutation) ResetLocalUserPasswordExpireMin() {
	m.local_user_password_expire_min = nil
	delete(m.clearedFields, task.FieldLocalUserPasswordExpireMin)
}

// SetLocalUserPasswordExpireWarn sets the "local_user_password_expire_warn" field.
func (m *TaskMutation) SetLocalUserPasswordExpireWarn(s string) {
	m.local_user_password_expire_warn = &s
}

// LocalUserPasswordExpireWarn returns the value of the "local_user_password_expire_warn" field in the mutation.
func (m *TaskMutation) LocalUserPasswordExpireWarn() (r string, exists bool) {
	v := m.local_user_password_expire_warn
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserPasswordExpireWarn returns the old "local_user_password_expire_warn" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserPasswordExpireWarn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserPasswordExpireWarn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserPasswordExpireWarn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserPasswordExpireWarn: %w", err)
	}
	return oldValue.LocalUserPasswordExpireWarn, nil
}

// ClearLocalUserPasswordExpireWarn clears the value of the "local_user_password_expire_warn" field.
func (m *TaskMutation) ClearLocalUserPasswordExpireWarn() {
	m.local_user_password_expire_warn = nil
	m.clearedFields[task.FieldLocalUserPasswordExpireWarn] = struct{}{}
}

// LocalUserPasswordExpireWarnCleared returns if the "local_user_password_expire_warn" field was cleared in this mutation.
func (m *TaskMutation) LocalUserPasswordExpireWarnCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserPasswordExpireWarn]
	return ok
}

// ResetLocalUserPasswordExpireWarn resets all changes to the "local_user_password_expire_warn" field.
func (m *TaskMutation) ResetLocalUserPasswordExpireWarn() {
	m.local_user_password_expire_warn = nil
	delete(m.clearedFields, task.FieldLocalUserPasswordExpireWarn)
}

// SetLocalUserPasswordLock sets the "local_user_password_lock" field.
func (m *TaskMutation) SetLocalUserPasswordLock(b bool) {
	m.local_user_password_lock = &b
}

// LocalUserPasswordLock returns the value of the "local_user_password_lock" field in the mutation.
func (m *TaskMutation) LocalUserPasswordLock() (r bool, exists bool) {
	v := m.local_user_password_lock
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserPasswordLock returns the old "local_user_password_lock" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserPasswordLock(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserPasswordLock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserPasswordLock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserPasswordLock: %w", err)
	}
	return oldValue.LocalUserPasswordLock, nil
}

// ClearLocalUserPasswordLock clears the value of the "local_user_password_lock" field.
func (m *TaskMutation) ClearLocalUserPasswordLock() {
	m.local_user_password_lock = nil
	m.clearedFields[task.FieldLocalUserPasswordLock] = struct{}{}
}

// LocalUserPasswordLockCleared returns if the "local_user_password_lock" field was cleared in this mutation.
func (m *TaskMutation) LocalUserPasswordLockCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserPasswordLock]
	return ok
}

// ResetLocalUserPasswordLock resets all changes to the "local_user_password_lock" field.
func (m *TaskMutation) ResetLocalUserPasswordLock() {
	m.local_user_password_lock = nil
	delete(m.clearedFields, task.FieldLocalUserPasswordLock)
}

// SetLocalUserSeuser sets the "local_user_seuser" field.
func (m *TaskMutation) SetLocalUserSeuser(s string) {
	m.local_user_seuser = &s
}

// LocalUserSeuser returns the value of the "local_user_seuser" field in the mutation.
func (m *TaskMutation) LocalUserSeuser() (r string, exists bool) {
	v := m.local_user_seuser
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserSeuser returns the old "local_user_seuser" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserSeuser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserSeuser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserSeuser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserSeuser: %w", err)
	}
	return oldValue.LocalUserSeuser, nil
}

// ClearLocalUserSeuser clears the value of the "local_user_seuser" field.
func (m *TaskMutation) ClearLocalUserSeuser() {
	m.local_user_seuser = nil
	m.clearedFields[task.FieldLocalUserSeuser] = struct{}{}
}

// LocalUserSeuserCleared returns if the "local_user_seuser" field was cleared in this mutation.
func (m *TaskMutation) LocalUserSeuserCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserSeuser]
	return ok
}

// ResetLocalUserSeuser resets all changes to the "local_user_seuser" field.
func (m *TaskMutation) ResetLocalUserSeuser() {
	m.local_user_seuser = nil
	delete(m.clearedFields, task.FieldLocalUserSeuser)
}

// SetLocalUserShell sets the "local_user_shell" field.
func (m *TaskMutation) SetLocalUserShell(s string) {
	m.local_user_shell = &s
}

// LocalUserShell returns the value of the "local_user_shell" field in the mutation.
func (m *TaskMutation) LocalUserShell() (r string, exists bool) {
	v := m.local_user_shell
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserShell returns the old "local_user_shell" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserShell(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserShell is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserShell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserShell: %w", err)
	}
	return oldValue.LocalUserShell, nil
}

// ClearLocalUserShell clears the value of the "local_user_shell" field.
func (m *TaskMutation) ClearLocalUserShell() {
	m.local_user_shell = nil
	m.clearedFields[task.FieldLocalUserShell] = struct{}{}
}

// LocalUserShellCleared returns if the "local_user_shell" field was cleared in this mutation.
func (m *TaskMutation) LocalUserShellCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserShell]
	return ok
}

// ResetLocalUserShell resets all changes to the "local_user_shell" field.
func (m *TaskMutation) ResetLocalUserShell() {
	m.local_user_shell = nil
	delete(m.clearedFields, task.FieldLocalUserShell)
}

// SetLocalUserSkeleton sets the "local_user_skeleton" field.
func (m *TaskMutation) SetLocalUserSkeleton(s string) {
	m.local_user_skeleton = &s
}

// LocalUserSkeleton returns the value of the "local_user_skeleton" field in the mutation.
func (m *TaskMutation) LocalUserSkeleton() (r string, exists bool) {
	v := m.local_user_skeleton
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserSkeleton returns the old "local_user_skeleton" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserSkeleton(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserSkeleton is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserSkeleton requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserSkeleton: %w", err)
	}
	return oldValue.LocalUserSkeleton, nil
}

// ClearLocalUserSkeleton clears the value of the "local_user_skeleton" field.
func (m *TaskMutation) ClearLocalUserSkeleton() {
	m.local_user_skeleton = nil
	m.clearedFields[task.FieldLocalUserSkeleton] = struct{}{}
}

// LocalUserSkeletonCleared returns if the "local_user_skeleton" field was cleared in this mutation.
func (m *TaskMutation) LocalUserSkeletonCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserSkeleton]
	return ok
}

// ResetLocalUserSkeleton resets all changes to the "local_user_skeleton" field.
func (m *TaskMutation) ResetLocalUserSkeleton() {
	m.local_user_skeleton = nil
	delete(m.clearedFields, task.FieldLocalUserSkeleton)
}

// SetLocalUserSystem sets the "local_user_system" field.
func (m *TaskMutation) SetLocalUserSystem(b bool) {
	m.local_user_system = &b
}

// LocalUserSystem returns the value of the "local_user_system" field in the mutation.
func (m *TaskMutation) LocalUserSystem() (r bool, exists bool) {
	v := m.local_user_system
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserSystem returns the old "local_user_system" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserSystem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserSystem: %w", err)
	}
	return oldValue.LocalUserSystem, nil
}

// ClearLocalUserSystem clears the value of the "local_user_system" field.
func (m *TaskMutation) ClearLocalUserSystem() {
	m.local_user_system = nil
	m.clearedFields[task.FieldLocalUserSystem] = struct{}{}
}

// LocalUserSystemCleared returns if the "local_user_system" field was cleared in this mutation.
func (m *TaskMutation) LocalUserSystemCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserSystem]
	return ok
}

// ResetLocalUserSystem resets all changes to the "local_user_system" field.
func (m *TaskMutation) ResetLocalUserSystem() {
	m.local_user_system = nil
	delete(m.clearedFields, task.FieldLocalUserSystem)
}

// SetLocalUserID sets the "local_user_id" field.
func (m *TaskMutation) SetLocalUserID(s string) {
	m.local_user_id = &s
}

// LocalUserID returns the value of the "local_user_id" field in the mutation.
func (m *TaskMutation) LocalUserID() (r string, exists bool) {
	v := m.local_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserID returns the old "local_user_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserID: %w", err)
	}
	return oldValue.LocalUserID, nil
}

// ClearLocalUserID clears the value of the "local_user_id" field.
func (m *TaskMutation) ClearLocalUserID() {
	m.local_user_id = nil
	m.clearedFields[task.FieldLocalUserID] = struct{}{}
}

// LocalUserIDCleared returns if the "local_user_id" field was cleared in this mutation.
func (m *TaskMutation) LocalUserIDCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserID]
	return ok
}

// ResetLocalUserID resets all changes to the "local_user_id" field.
func (m *TaskMutation) ResetLocalUserID() {
	m.local_user_id = nil
	delete(m.clearedFields, task.FieldLocalUserID)
}

// SetLocalUserIDMax sets the "local_user_id_max" field.
func (m *TaskMutation) SetLocalUserIDMax(s string) {
	m.local_user_id_max = &s
}

// LocalUserIDMax returns the value of the "local_user_id_max" field in the mutation.
func (m *TaskMutation) LocalUserIDMax() (r string, exists bool) {
	v := m.local_user_id_max
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserIDMax returns the old "local_user_id_max" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserIDMax(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserIDMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserIDMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserIDMax: %w", err)
	}
	return oldValue.LocalUserIDMax, nil
}

// ClearLocalUserIDMax clears the value of the "local_user_id_max" field.
func (m *TaskMutation) ClearLocalUserIDMax() {
	m.local_user_id_max = nil
	m.clearedFields[task.FieldLocalUserIDMax] = struct{}{}
}

// LocalUserIDMaxCleared returns if the "local_user_id_max" field was cleared in this mutation.
func (m *TaskMutation) LocalUserIDMaxCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserIDMax]
	return ok
}

// ResetLocalUserIDMax resets all changes to the "local_user_id_max" field.
func (m *TaskMutation) ResetLocalUserIDMax() {
	m.local_user_id_max = nil
	delete(m.clearedFields, task.FieldLocalUserIDMax)
}

// SetLocalUserIDMin sets the "local_user_id_min" field.
func (m *TaskMutation) SetLocalUserIDMin(s string) {
	m.local_user_id_min = &s
}

// LocalUserIDMin returns the value of the "local_user_id_min" field in the mutation.
func (m *TaskMutation) LocalUserIDMin() (r string, exists bool) {
	v := m.local_user_id_min
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserIDMin returns the old "local_user_id_min" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserIDMin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserIDMin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserIDMin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserIDMin: %w", err)
	}
	return oldValue.LocalUserIDMin, nil
}

// ClearLocalUserIDMin clears the value of the "local_user_id_min" field.
func (m *TaskMutation) ClearLocalUserIDMin() {
	m.local_user_id_min = nil
	m.clearedFields[task.FieldLocalUserIDMin] = struct{}{}
}

// LocalUserIDMinCleared returns if the "local_user_id_min" field was cleared in this mutation.
func (m *TaskMutation) LocalUserIDMinCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserIDMin]
	return ok
}

// ResetLocalUserIDMin resets all changes to the "local_user_id_min" field.
func (m *TaskMutation) ResetLocalUserIDMin() {
	m.local_user_id_min = nil
	delete(m.clearedFields, task.FieldLocalUserIDMin)
}

// SetLocalUserSSHKeyBits sets the "local_user_ssh_key_bits" field.
func (m *TaskMutation) SetLocalUserSSHKeyBits(s string) {
	m.local_user_ssh_key_bits = &s
}

// LocalUserSSHKeyBits returns the value of the "local_user_ssh_key_bits" field in the mutation.
func (m *TaskMutation) LocalUserSSHKeyBits() (r string, exists bool) {
	v := m.local_user_ssh_key_bits
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserSSHKeyBits returns the old "local_user_ssh_key_bits" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserSSHKeyBits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserSSHKeyBits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserSSHKeyBits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserSSHKeyBits: %w", err)
	}
	return oldValue.LocalUserSSHKeyBits, nil
}

// ClearLocalUserSSHKeyBits clears the value of the "local_user_ssh_key_bits" field.
func (m *TaskMutation) ClearLocalUserSSHKeyBits() {
	m.local_user_ssh_key_bits = nil
	m.clearedFields[task.FieldLocalUserSSHKeyBits] = struct{}{}
}

// LocalUserSSHKeyBitsCleared returns if the "local_user_ssh_key_bits" field was cleared in this mutation.
func (m *TaskMutation) LocalUserSSHKeyBitsCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserSSHKeyBits]
	return ok
}

// ResetLocalUserSSHKeyBits resets all changes to the "local_user_ssh_key_bits" field.
func (m *TaskMutation) ResetLocalUserSSHKeyBits() {
	m.local_user_ssh_key_bits = nil
	delete(m.clearedFields, task.FieldLocalUserSSHKeyBits)
}

// SetLocalUserSSHKeyComment sets the "local_user_ssh_key_comment" field.
func (m *TaskMutation) SetLocalUserSSHKeyComment(s string) {
	m.local_user_ssh_key_comment = &s
}

// LocalUserSSHKeyComment returns the value of the "local_user_ssh_key_comment" field in the mutation.
func (m *TaskMutation) LocalUserSSHKeyComment() (r string, exists bool) {
	v := m.local_user_ssh_key_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserSSHKeyComment returns the old "local_user_ssh_key_comment" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserSSHKeyComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserSSHKeyComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserSSHKeyComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserSSHKeyComment: %w", err)
	}
	return oldValue.LocalUserSSHKeyComment, nil
}

// ClearLocalUserSSHKeyComment clears the value of the "local_user_ssh_key_comment" field.
func (m *TaskMutation) ClearLocalUserSSHKeyComment() {
	m.local_user_ssh_key_comment = nil
	m.clearedFields[task.FieldLocalUserSSHKeyComment] = struct{}{}
}

// LocalUserSSHKeyCommentCleared returns if the "local_user_ssh_key_comment" field was cleared in this mutation.
func (m *TaskMutation) LocalUserSSHKeyCommentCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserSSHKeyComment]
	return ok
}

// ResetLocalUserSSHKeyComment resets all changes to the "local_user_ssh_key_comment" field.
func (m *TaskMutation) ResetLocalUserSSHKeyComment() {
	m.local_user_ssh_key_comment = nil
	delete(m.clearedFields, task.FieldLocalUserSSHKeyComment)
}

// SetLocalUserSSHKeyFile sets the "local_user_ssh_key_file" field.
func (m *TaskMutation) SetLocalUserSSHKeyFile(s string) {
	m.local_user_ssh_key_file = &s
}

// LocalUserSSHKeyFile returns the value of the "local_user_ssh_key_file" field in the mutation.
func (m *TaskMutation) LocalUserSSHKeyFile() (r string, exists bool) {
	v := m.local_user_ssh_key_file
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserSSHKeyFile returns the old "local_user_ssh_key_file" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserSSHKeyFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserSSHKeyFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserSSHKeyFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserSSHKeyFile: %w", err)
	}
	return oldValue.LocalUserSSHKeyFile, nil
}

// ClearLocalUserSSHKeyFile clears the value of the "local_user_ssh_key_file" field.
func (m *TaskMutation) ClearLocalUserSSHKeyFile() {
	m.local_user_ssh_key_file = nil
	m.clearedFields[task.FieldLocalUserSSHKeyFile] = struct{}{}
}

// LocalUserSSHKeyFileCleared returns if the "local_user_ssh_key_file" field was cleared in this mutation.
func (m *TaskMutation) LocalUserSSHKeyFileCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserSSHKeyFile]
	return ok
}

// ResetLocalUserSSHKeyFile resets all changes to the "local_user_ssh_key_file" field.
func (m *TaskMutation) ResetLocalUserSSHKeyFile() {
	m.local_user_ssh_key_file = nil
	delete(m.clearedFields, task.FieldLocalUserSSHKeyFile)
}

// SetLocalUserSSHKeyPassphrase sets the "local_user_ssh_key_passphrase" field.
func (m *TaskMutation) SetLocalUserSSHKeyPassphrase(s string) {
	m.local_user_ssh_key_passphrase = &s
}

// LocalUserSSHKeyPassphrase returns the value of the "local_user_ssh_key_passphrase" field in the mutation.
func (m *TaskMutation) LocalUserSSHKeyPassphrase() (r string, exists bool) {
	v := m.local_user_ssh_key_passphrase
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserSSHKeyPassphrase returns the old "local_user_ssh_key_passphrase" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserSSHKeyPassphrase(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserSSHKeyPassphrase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserSSHKeyPassphrase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserSSHKeyPassphrase: %w", err)
	}
	return oldValue.LocalUserSSHKeyPassphrase, nil
}

// ClearLocalUserSSHKeyPassphrase clears the value of the "local_user_ssh_key_passphrase" field.
func (m *TaskMutation) ClearLocalUserSSHKeyPassphrase() {
	m.local_user_ssh_key_passphrase = nil
	m.clearedFields[task.FieldLocalUserSSHKeyPassphrase] = struct{}{}
}

// LocalUserSSHKeyPassphraseCleared returns if the "local_user_ssh_key_passphrase" field was cleared in this mutation.
func (m *TaskMutation) LocalUserSSHKeyPassphraseCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserSSHKeyPassphrase]
	return ok
}

// ResetLocalUserSSHKeyPassphrase resets all changes to the "local_user_ssh_key_passphrase" field.
func (m *TaskMutation) ResetLocalUserSSHKeyPassphrase() {
	m.local_user_ssh_key_passphrase = nil
	delete(m.clearedFields, task.FieldLocalUserSSHKeyPassphrase)
}

// SetLocalUserSSHKeyType sets the "local_user_ssh_key_type" field.
func (m *TaskMutation) SetLocalUserSSHKeyType(s string) {
	m.local_user_ssh_key_type = &s
}

// LocalUserSSHKeyType returns the value of the "local_user_ssh_key_type" field in the mutation.
func (m *TaskMutation) LocalUserSSHKeyType() (r string, exists bool) {
	v := m.local_user_ssh_key_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserSSHKeyType returns the old "local_user_ssh_key_type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserSSHKeyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserSSHKeyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserSSHKeyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserSSHKeyType: %w", err)
	}
	return oldValue.LocalUserSSHKeyType, nil
}

// ClearLocalUserSSHKeyType clears the value of the "local_user_ssh_key_type" field.
func (m *TaskMutation) ClearLocalUserSSHKeyType() {
	m.local_user_ssh_key_type = nil
	m.clearedFields[task.FieldLocalUserSSHKeyType] = struct{}{}
}

// LocalUserSSHKeyTypeCleared returns if the "local_user_ssh_key_type" field was cleared in this mutation.
func (m *TaskMutation) LocalUserSSHKeyTypeCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserSSHKeyType]
	return ok
}

// ResetLocalUserSSHKeyType resets all changes to the "local_user_ssh_key_type" field.
func (m *TaskMutation) ResetLocalUserSSHKeyType() {
	m.local_user_ssh_key_type = nil
	delete(m.clearedFields, task.FieldLocalUserSSHKeyType)
}

// SetLocalUserUmask sets the "local_user_umask" field.
func (m *TaskMutation) SetLocalUserUmask(s string) {
	m.local_user_umask = &s
}

// LocalUserUmask returns the value of the "local_user_umask" field in the mutation.
func (m *TaskMutation) LocalUserUmask() (r string, exists bool) {
	v := m.local_user_umask
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalUserUmask returns the old "local_user_umask" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalUserUmask(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalUserUmask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalUserUmask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalUserUmask: %w", err)
	}
	return oldValue.LocalUserUmask, nil
}

// ClearLocalUserUmask clears the value of the "local_user_umask" field.
func (m *TaskMutation) ClearLocalUserUmask() {
	m.local_user_umask = nil
	m.clearedFields[task.FieldLocalUserUmask] = struct{}{}
}

// LocalUserUmaskCleared returns if the "local_user_umask" field was cleared in this mutation.
func (m *TaskMutation) LocalUserUmaskCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalUserUmask]
	return ok
}

// ResetLocalUserUmask resets all changes to the "local_user_umask" field.
func (m *TaskMutation) ResetLocalUserUmask() {
	m.local_user_umask = nil
	delete(m.clearedFields, task.FieldLocalUserUmask)
}

// SetLocalGroupID sets the "local_group_id" field.
func (m *TaskMutation) SetLocalGroupID(s string) {
	m.local_group_id = &s
}

// LocalGroupID returns the value of the "local_group_id" field in the mutation.
func (m *TaskMutation) LocalGroupID() (r string, exists bool) {
	v := m.local_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalGroupID returns the old "local_group_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalGroupID: %w", err)
	}
	return oldValue.LocalGroupID, nil
}

// ClearLocalGroupID clears the value of the "local_group_id" field.
func (m *TaskMutation) ClearLocalGroupID() {
	m.local_group_id = nil
	m.clearedFields[task.FieldLocalGroupID] = struct{}{}
}

// LocalGroupIDCleared returns if the "local_group_id" field was cleared in this mutation.
func (m *TaskMutation) LocalGroupIDCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalGroupID]
	return ok
}

// ResetLocalGroupID resets all changes to the "local_group_id" field.
func (m *TaskMutation) ResetLocalGroupID() {
	m.local_group_id = nil
	delete(m.clearedFields, task.FieldLocalGroupID)
}

// SetLocalGroupName sets the "local_group_name" field.
func (m *TaskMutation) SetLocalGroupName(s string) {
	m.local_group_name = &s
}

// LocalGroupName returns the value of the "local_group_name" field in the mutation.
func (m *TaskMutation) LocalGroupName() (r string, exists bool) {
	v := m.local_group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalGroupName returns the old "local_group_name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalGroupName: %w", err)
	}
	return oldValue.LocalGroupName, nil
}

// ClearLocalGroupName clears the value of the "local_group_name" field.
func (m *TaskMutation) ClearLocalGroupName() {
	m.local_group_name = nil
	m.clearedFields[task.FieldLocalGroupName] = struct{}{}
}

// LocalGroupNameCleared returns if the "local_group_name" field was cleared in this mutation.
func (m *TaskMutation) LocalGroupNameCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalGroupName]
	return ok
}

// ResetLocalGroupName resets all changes to the "local_group_name" field.
func (m *TaskMutation) ResetLocalGroupName() {
	m.local_group_name = nil
	delete(m.clearedFields, task.FieldLocalGroupName)
}

// SetLocalGroupDescription sets the "local_group_description" field.
func (m *TaskMutation) SetLocalGroupDescription(s string) {
	m.local_group_description = &s
}

// LocalGroupDescription returns the value of the "local_group_description" field in the mutation.
func (m *TaskMutation) LocalGroupDescription() (r string, exists bool) {
	v := m.local_group_description
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalGroupDescription returns the old "local_group_description" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalGroupDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalGroupDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalGroupDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalGroupDescription: %w", err)
	}
	return oldValue.LocalGroupDescription, nil
}

// ClearLocalGroupDescription clears the value of the "local_group_description" field.
func (m *TaskMutation) ClearLocalGroupDescription() {
	m.local_group_description = nil
	m.clearedFields[task.FieldLocalGroupDescription] = struct{}{}
}

// LocalGroupDescriptionCleared returns if the "local_group_description" field was cleared in this mutation.
func (m *TaskMutation) LocalGroupDescriptionCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalGroupDescription]
	return ok
}

// ResetLocalGroupDescription resets all changes to the "local_group_description" field.
func (m *TaskMutation) ResetLocalGroupDescription() {
	m.local_group_description = nil
	delete(m.clearedFields, task.FieldLocalGroupDescription)
}

// SetLocalGroupSystem sets the "local_group_system" field.
func (m *TaskMutation) SetLocalGroupSystem(b bool) {
	m.local_group_system = &b
}

// LocalGroupSystem returns the value of the "local_group_system" field in the mutation.
func (m *TaskMutation) LocalGroupSystem() (r bool, exists bool) {
	v := m.local_group_system
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalGroupSystem returns the old "local_group_system" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalGroupSystem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalGroupSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalGroupSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalGroupSystem: %w", err)
	}
	return oldValue.LocalGroupSystem, nil
}

// ClearLocalGroupSystem clears the value of the "local_group_system" field.
func (m *TaskMutation) ClearLocalGroupSystem() {
	m.local_group_system = nil
	m.clearedFields[task.FieldLocalGroupSystem] = struct{}{}
}

// LocalGroupSystemCleared returns if the "local_group_system" field was cleared in this mutation.
func (m *TaskMutation) LocalGroupSystemCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalGroupSystem]
	return ok
}

// ResetLocalGroupSystem resets all changes to the "local_group_system" field.
func (m *TaskMutation) ResetLocalGroupSystem() {
	m.local_group_system = nil
	delete(m.clearedFields, task.FieldLocalGroupSystem)
}

// SetLocalGroupForce sets the "local_group_force" field.
func (m *TaskMutation) SetLocalGroupForce(b bool) {
	m.local_group_force = &b
}

// LocalGroupForce returns the value of the "local_group_force" field in the mutation.
func (m *TaskMutation) LocalGroupForce() (r bool, exists bool) {
	v := m.local_group_force
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalGroupForce returns the old "local_group_force" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalGroupForce(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalGroupForce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalGroupForce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalGroupForce: %w", err)
	}
	return oldValue.LocalGroupForce, nil
}

// ClearLocalGroupForce clears the value of the "local_group_force" field.
func (m *TaskMutation) ClearLocalGroupForce() {
	m.local_group_force = nil
	m.clearedFields[task.FieldLocalGroupForce] = struct{}{}
}

// LocalGroupForceCleared returns if the "local_group_force" field was cleared in this mutation.
func (m *TaskMutation) LocalGroupForceCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalGroupForce]
	return ok
}

// ResetLocalGroupForce resets all changes to the "local_group_force" field.
func (m *TaskMutation) ResetLocalGroupForce() {
	m.local_group_force = nil
	delete(m.clearedFields, task.FieldLocalGroupForce)
}

// SetLocalGroupMembers sets the "local_group_members" field.
func (m *TaskMutation) SetLocalGroupMembers(s string) {
	m.local_group_members = &s
}

// LocalGroupMembers returns the value of the "local_group_members" field in the mutation.
func (m *TaskMutation) LocalGroupMembers() (r string, exists bool) {
	v := m.local_group_members
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalGroupMembers returns the old "local_group_members" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalGroupMembers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalGroupMembers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalGroupMembers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalGroupMembers: %w", err)
	}
	return oldValue.LocalGroupMembers, nil
}

// ClearLocalGroupMembers clears the value of the "local_group_members" field.
func (m *TaskMutation) ClearLocalGroupMembers() {
	m.local_group_members = nil
	m.clearedFields[task.FieldLocalGroupMembers] = struct{}{}
}

// LocalGroupMembersCleared returns if the "local_group_members" field was cleared in this mutation.
func (m *TaskMutation) LocalGroupMembersCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalGroupMembers]
	return ok
}

// ResetLocalGroupMembers resets all changes to the "local_group_members" field.
func (m *TaskMutation) ResetLocalGroupMembers() {
	m.local_group_members = nil
	delete(m.clearedFields, task.FieldLocalGroupMembers)
}

// SetLocalGroupMembersToInclude sets the "local_group_members_to_include" field.
func (m *TaskMutation) SetLocalGroupMembersToInclude(s string) {
	m.local_group_members_to_include = &s
}

// LocalGroupMembersToInclude returns the value of the "local_group_members_to_include" field in the mutation.
func (m *TaskMutation) LocalGroupMembersToInclude() (r string, exists bool) {
	v := m.local_group_members_to_include
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalGroupMembersToInclude returns the old "local_group_members_to_include" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalGroupMembersToInclude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalGroupMembersToInclude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalGroupMembersToInclude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalGroupMembersToInclude: %w", err)
	}
	return oldValue.LocalGroupMembersToInclude, nil
}

// ClearLocalGroupMembersToInclude clears the value of the "local_group_members_to_include" field.
func (m *TaskMutation) ClearLocalGroupMembersToInclude() {
	m.local_group_members_to_include = nil
	m.clearedFields[task.FieldLocalGroupMembersToInclude] = struct{}{}
}

// LocalGroupMembersToIncludeCleared returns if the "local_group_members_to_include" field was cleared in this mutation.
func (m *TaskMutation) LocalGroupMembersToIncludeCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalGroupMembersToInclude]
	return ok
}

// ResetLocalGroupMembersToInclude resets all changes to the "local_group_members_to_include" field.
func (m *TaskMutation) ResetLocalGroupMembersToInclude() {
	m.local_group_members_to_include = nil
	delete(m.clearedFields, task.FieldLocalGroupMembersToInclude)
}

// SetLocalGroupMembersToExclude sets the "local_group_members_to_exclude" field.
func (m *TaskMutation) SetLocalGroupMembersToExclude(s string) {
	m.local_group_members_to_exclude = &s
}

// LocalGroupMembersToExclude returns the value of the "local_group_members_to_exclude" field in the mutation.
func (m *TaskMutation) LocalGroupMembersToExclude() (r string, exists bool) {
	v := m.local_group_members_to_exclude
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalGroupMembersToExclude returns the old "local_group_members_to_exclude" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLocalGroupMembersToExclude(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalGroupMembersToExclude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalGroupMembersToExclude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalGroupMembersToExclude: %w", err)
	}
	return oldValue.LocalGroupMembersToExclude, nil
}

// ClearLocalGroupMembersToExclude clears the value of the "local_group_members_to_exclude" field.
func (m *TaskMutation) ClearLocalGroupMembersToExclude() {
	m.local_group_members_to_exclude = nil
	m.clearedFields[task.FieldLocalGroupMembersToExclude] = struct{}{}
}

// LocalGroupMembersToExcludeCleared returns if the "local_group_members_to_exclude" field was cleared in this mutation.
func (m *TaskMutation) LocalGroupMembersToExcludeCleared() bool {
	_, ok := m.clearedFields[task.FieldLocalGroupMembersToExclude]
	return ok
}

// ResetLocalGroupMembersToExclude resets all changes to the "local_group_members_to_exclude" field.
func (m *TaskMutation) ResetLocalGroupMembersToExclude() {
	m.local_group_members_to_exclude = nil
	delete(m.clearedFields, task.FieldLocalGroupMembersToExclude)
}

// SetMsiProductid sets the "msi_productid" field.
func (m *TaskMutation) SetMsiProductid(s string) {
	m.msi_productid = &s
}

// MsiProductid returns the value of the "msi_productid" field in the mutation.
func (m *TaskMutation) MsiProductid() (r string, exists bool) {
	v := m.msi_productid
	if v == nil {
		return
	}
	return *v, true
}

// OldMsiProductid returns the old "msi_productid" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldMsiProductid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsiProductid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsiProductid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsiProductid: %w", err)
	}
	return oldValue.MsiProductid, nil
}

// ClearMsiProductid clears the value of the "msi_productid" field.
func (m *TaskMutation) ClearMsiProductid() {
	m.msi_productid = nil
	m.clearedFields[task.FieldMsiProductid] = struct{}{}
}

// MsiProductidCleared returns if the "msi_productid" field was cleared in this mutation.
func (m *TaskMutation) MsiProductidCleared() bool {
	_, ok := m.clearedFields[task.FieldMsiProductid]
	return ok
}

// ResetMsiProductid resets all changes to the "msi_productid" field.
func (m *TaskMutation) ResetMsiProductid() {
	m.msi_productid = nil
	delete(m.clearedFields, task.FieldMsiProductid)
}

// SetMsiPath sets the "msi_path" field.
func (m *TaskMutation) SetMsiPath(s string) {
	m.msi_path = &s
}

// MsiPath returns the value of the "msi_path" field in the mutation.
func (m *TaskMutation) MsiPath() (r string, exists bool) {
	v := m.msi_path
	if v == nil {
		return
	}
	return *v, true
}

// OldMsiPath returns the old "msi_path" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldMsiPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsiPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsiPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsiPath: %w", err)
	}
	return oldValue.MsiPath, nil
}

// ClearMsiPath clears the value of the "msi_path" field.
func (m *TaskMutation) ClearMsiPath() {
	m.msi_path = nil
	m.clearedFields[task.FieldMsiPath] = struct{}{}
}

// MsiPathCleared returns if the "msi_path" field was cleared in this mutation.
func (m *TaskMutation) MsiPathCleared() bool {
	_, ok := m.clearedFields[task.FieldMsiPath]
	return ok
}

// ResetMsiPath resets all changes to the "msi_path" field.
func (m *TaskMutation) ResetMsiPath() {
	m.msi_path = nil
	delete(m.clearedFields, task.FieldMsiPath)
}

// SetMsiArguments sets the "msi_arguments" field.
func (m *TaskMutation) SetMsiArguments(s string) {
	m.msi_arguments = &s
}

// MsiArguments returns the value of the "msi_arguments" field in the mutation.
func (m *TaskMutation) MsiArguments() (r string, exists bool) {
	v := m.msi_arguments
	if v == nil {
		return
	}
	return *v, true
}

// OldMsiArguments returns the old "msi_arguments" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldMsiArguments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsiArguments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsiArguments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsiArguments: %w", err)
	}
	return oldValue.MsiArguments, nil
}

// ClearMsiArguments clears the value of the "msi_arguments" field.
func (m *TaskMutation) ClearMsiArguments() {
	m.msi_arguments = nil
	m.clearedFields[task.FieldMsiArguments] = struct{}{}
}

// MsiArgumentsCleared returns if the "msi_arguments" field was cleared in this mutation.
func (m *TaskMutation) MsiArgumentsCleared() bool {
	_, ok := m.clearedFields[task.FieldMsiArguments]
	return ok
}

// ResetMsiArguments resets all changes to the "msi_arguments" field.
func (m *TaskMutation) ResetMsiArguments() {
	m.msi_arguments = nil
	delete(m.clearedFields, task.FieldMsiArguments)
}

// SetMsiFileHash sets the "msi_file_hash" field.
func (m *TaskMutation) SetMsiFileHash(s string) {
	m.msi_file_hash = &s
}

// MsiFileHash returns the value of the "msi_file_hash" field in the mutation.
func (m *TaskMutation) MsiFileHash() (r string, exists bool) {
	v := m.msi_file_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldMsiFileHash returns the old "msi_file_hash" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldMsiFileHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsiFileHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsiFileHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsiFileHash: %w", err)
	}
	return oldValue.MsiFileHash, nil
}

// ClearMsiFileHash clears the value of the "msi_file_hash" field.
func (m *TaskMutation) ClearMsiFileHash() {
	m.msi_file_hash = nil
	m.clearedFields[task.FieldMsiFileHash] = struct{}{}
}

// MsiFileHashCleared returns if the "msi_file_hash" field was cleared in this mutation.
func (m *TaskMutation) MsiFileHashCleared() bool {
	_, ok := m.clearedFields[task.FieldMsiFileHash]
	return ok
}

// ResetMsiFileHash resets all changes to the "msi_file_hash" field.
func (m *TaskMutation) ResetMsiFileHash() {
	m.msi_file_hash = nil
	delete(m.clearedFields, task.FieldMsiFileHash)
}

// SetMsiFileHashAlg sets the "msi_file_hash_alg" field.
func (m *TaskMutation) SetMsiFileHashAlg(tfha task.MsiFileHashAlg) {
	m.msi_file_hash_alg = &tfha
}

// MsiFileHashAlg returns the value of the "msi_file_hash_alg" field in the mutation.
func (m *TaskMutation) MsiFileHashAlg() (r task.MsiFileHashAlg, exists bool) {
	v := m.msi_file_hash_alg
	if v == nil {
		return
	}
	return *v, true
}

// OldMsiFileHashAlg returns the old "msi_file_hash_alg" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldMsiFileHashAlg(ctx context.Context) (v task.MsiFileHashAlg, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsiFileHashAlg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsiFileHashAlg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsiFileHashAlg: %w", err)
	}
	return oldValue.MsiFileHashAlg, nil
}

// ClearMsiFileHashAlg clears the value of the "msi_file_hash_alg" field.
func (m *TaskMutation) ClearMsiFileHashAlg() {
	m.msi_file_hash_alg = nil
	m.clearedFields[task.FieldMsiFileHashAlg] = struct{}{}
}

// MsiFileHashAlgCleared returns if the "msi_file_hash_alg" field was cleared in this mutation.
func (m *TaskMutation) MsiFileHashAlgCleared() bool {
	_, ok := m.clearedFields[task.FieldMsiFileHashAlg]
	return ok
}

// ResetMsiFileHashAlg resets all changes to the "msi_file_hash_alg" field.
func (m *TaskMutation) ResetMsiFileHashAlg() {
	m.msi_file_hash_alg = nil
	delete(m.clearedFields, task.FieldMsiFileHashAlg)
}

// SetMsiLogPath sets the "msi_log_path" field.
func (m *TaskMutation) SetMsiLogPath(s string) {
	m.msi_log_path = &s
}

// MsiLogPath returns the value of the "msi_log_path" field in the mutation.
func (m *TaskMutation) MsiLogPath() (r string, exists bool) {
	v := m.msi_log_path
	if v == nil {
		return
	}
	return *v, true
}

// OldMsiLogPath returns the old "msi_log_path" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldMsiLogPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsiLogPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsiLogPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsiLogPath: %w", err)
	}
	return oldValue.MsiLogPath, nil
}

// ClearMsiLogPath clears the value of the "msi_log_path" field.
func (m *TaskMutation) ClearMsiLogPath() {
	m.msi_log_path = nil
	m.clearedFields[task.FieldMsiLogPath] = struct{}{}
}

// MsiLogPathCleared returns if the "msi_log_path" field was cleared in this mutation.
func (m *TaskMutation) MsiLogPathCleared() bool {
	_, ok := m.clearedFields[task.FieldMsiLogPath]
	return ok
}

// ResetMsiLogPath resets all changes to the "msi_log_path" field.
func (m *TaskMutation) ResetMsiLogPath() {
	m.msi_log_path = nil
	delete(m.clearedFields, task.FieldMsiLogPath)
}

// SetScript sets the "script" field.
func (m *TaskMutation) SetScript(s string) {
	m.script = &s
}

// Script returns the value of the "script" field in the mutation.
func (m *TaskMutation) Script() (r string, exists bool) {
	v := m.script
	if v == nil {
		return
	}
	return *v, true
}

// OldScript returns the old "script" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldScript(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScript is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScript requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScript: %w", err)
	}
	return oldValue.Script, nil
}

// ClearScript clears the value of the "script" field.
func (m *TaskMutation) ClearScript() {
	m.script = nil
	m.clearedFields[task.FieldScript] = struct{}{}
}

// ScriptCleared returns if the "script" field was cleared in this mutation.
func (m *TaskMutation) ScriptCleared() bool {
	_, ok := m.clearedFields[task.FieldScript]
	return ok
}

// ResetScript resets all changes to the "script" field.
func (m *TaskMutation) ResetScript() {
	m.script = nil
	delete(m.clearedFields, task.FieldScript)
}

// SetScriptExecutable sets the "script_executable" field.
func (m *TaskMutation) SetScriptExecutable(s string) {
	m.script_executable = &s
}

// ScriptExecutable returns the value of the "script_executable" field in the mutation.
func (m *TaskMutation) ScriptExecutable() (r string, exists bool) {
	v := m.script_executable
	if v == nil {
		return
	}
	return *v, true
}

// OldScriptExecutable returns the old "script_executable" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldScriptExecutable(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScriptExecutable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScriptExecutable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScriptExecutable: %w", err)
	}
	return oldValue.ScriptExecutable, nil
}

// ClearScriptExecutable clears the value of the "script_executable" field.
func (m *TaskMutation) ClearScriptExecutable() {
	m.script_executable = nil
	m.clearedFields[task.FieldScriptExecutable] = struct{}{}
}

// ScriptExecutableCleared returns if the "script_executable" field was cleared in this mutation.
func (m *TaskMutation) ScriptExecutableCleared() bool {
	_, ok := m.clearedFields[task.FieldScriptExecutable]
	return ok
}

// ResetScriptExecutable resets all changes to the "script_executable" field.
func (m *TaskMutation) ResetScriptExecutable() {
	m.script_executable = nil
	delete(m.clearedFields, task.FieldScriptExecutable)
}

// SetScriptCreates sets the "script_creates" field.
func (m *TaskMutation) SetScriptCreates(s string) {
	m.script_creates = &s
}

// ScriptCreates returns the value of the "script_creates" field in the mutation.
func (m *TaskMutation) ScriptCreates() (r string, exists bool) {
	v := m.script_creates
	if v == nil {
		return
	}
	return *v, true
}

// OldScriptCreates returns the old "script_creates" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldScriptCreates(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScriptCreates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScriptCreates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScriptCreates: %w", err)
	}
	return oldValue.ScriptCreates, nil
}

// ClearScriptCreates clears the value of the "script_creates" field.
func (m *TaskMutation) ClearScriptCreates() {
	m.script_creates = nil
	m.clearedFields[task.FieldScriptCreates] = struct{}{}
}

// ScriptCreatesCleared returns if the "script_creates" field was cleared in this mutation.
func (m *TaskMutation) ScriptCreatesCleared() bool {
	_, ok := m.clearedFields[task.FieldScriptCreates]
	return ok
}

// ResetScriptCreates resets all changes to the "script_creates" field.
func (m *TaskMutation) ResetScriptCreates() {
	m.script_creates = nil
	delete(m.clearedFields, task.FieldScriptCreates)
}

// SetScriptRun sets the "script_run" field.
func (m *TaskMutation) SetScriptRun(tr task.ScriptRun) {
	m.script_run = &tr
}

// ScriptRun returns the value of the "script_run" field in the mutation.
func (m *TaskMutation) ScriptRun() (r task.ScriptRun, exists bool) {
	v := m.script_run
	if v == nil {
		return
	}
	return *v, true
}

// OldScriptRun returns the old "script_run" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldScriptRun(ctx context.Context) (v task.ScriptRun, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScriptRun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScriptRun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScriptRun: %w", err)
	}
	return oldValue.ScriptRun, nil
}

// ClearScriptRun clears the value of the "script_run" field.
func (m *TaskMutation) ClearScriptRun() {
	m.script_run = nil
	m.clearedFields[task.FieldScriptRun] = struct{}{}
}

// ScriptRunCleared returns if the "script_run" field was cleared in this mutation.
func (m *TaskMutation) ScriptRunCleared() bool {
	_, ok := m.clearedFields[task.FieldScriptRun]
	return ok
}

// ResetScriptRun resets all changes to the "script_run" field.
func (m *TaskMutation) ResetScriptRun() {
	m.script_run = nil
	delete(m.clearedFields, task.FieldScriptRun)
}

// SetAgentType sets the "agent_type" field.
func (m *TaskMutation) SetAgentType(tt task.AgentType) {
	m.agent_type = &tt
}

// AgentType returns the value of the "agent_type" field in the mutation.
func (m *TaskMutation) AgentType() (r task.AgentType, exists bool) {
	v := m.agent_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentType returns the old "agent_type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAgentType(ctx context.Context) (v task.AgentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentType: %w", err)
	}
	return oldValue.AgentType, nil
}

// ClearAgentType clears the value of the "agent_type" field.
func (m *TaskMutation) ClearAgentType() {
	m.agent_type = nil
	m.clearedFields[task.FieldAgentType] = struct{}{}
}

// AgentTypeCleared returns if the "agent_type" field was cleared in this mutation.
func (m *TaskMutation) AgentTypeCleared() bool {
	_, ok := m.clearedFields[task.FieldAgentType]
	return ok
}

// ResetAgentType resets all changes to the "agent_type" field.
func (m *TaskMutation) ResetAgentType() {
	m.agent_type = nil
	delete(m.clearedFields, task.FieldAgentType)
}

// SetWhen sets the "when" field.
func (m *TaskMutation) SetWhen(t time.Time) {
	m.when = &t
}

// When returns the value of the "when" field in the mutation.
func (m *TaskMutation) When() (r time.Time, exists bool) {
	v := m.when
	if v == nil {
		return
	}
	return *v, true
}

// OldWhen returns the old "when" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldWhen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhen: %w", err)
	}
	return oldValue.When, nil
}

// ClearWhen clears the value of the "when" field.
func (m *TaskMutation) ClearWhen() {
	m.when = nil
	m.clearedFields[task.FieldWhen] = struct{}{}
}

// WhenCleared returns if the "when" field was cleared in this mutation.
func (m *TaskMutation) WhenCleared() bool {
	_, ok := m.clearedFields[task.FieldWhen]
	return ok
}

// ResetWhen resets all changes to the "when" field.
func (m *TaskMutation) ResetWhen() {
	m.when = nil
	delete(m.clearedFields, task.FieldWhen)
}

// SetBrewUpdate sets the "brew_update" field.
func (m *TaskMutation) SetBrewUpdate(b bool) {
	m.brew_update = &b
}

// BrewUpdate returns the value of the "brew_update" field in the mutation.
func (m *TaskMutation) BrewUpdate() (r bool, exists bool) {
	v := m.brew_update
	if v == nil {
		return
	}
	return *v, true
}

// OldBrewUpdate returns the old "brew_update" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldBrewUpdate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrewUpdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrewUpdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrewUpdate: %w", err)
	}
	return oldValue.BrewUpdate, nil
}

// ClearBrewUpdate clears the value of the "brew_update" field.
func (m *TaskMutation) ClearBrewUpdate() {
	m.brew_update = nil
	m.clearedFields[task.FieldBrewUpdate] = struct{}{}
}

// BrewUpdateCleared returns if the "brew_update" field was cleared in this mutation.
func (m *TaskMutation) BrewUpdateCleared() bool {
	_, ok := m.clearedFields[task.FieldBrewUpdate]
	return ok
}

// ResetBrewUpdate resets all changes to the "brew_update" field.
func (m *TaskMutation) ResetBrewUpdate() {
	m.brew_update = nil
	delete(m.clearedFields, task.FieldBrewUpdate)
}

// SetBrewUpgradeAll sets the "brew_upgrade_all" field.
func (m *TaskMutation) SetBrewUpgradeAll(b bool) {
	m.brew_upgrade_all = &b
}

// BrewUpgradeAll returns the value of the "brew_upgrade_all" field in the mutation.
func (m *TaskMutation) BrewUpgradeAll() (r bool, exists bool) {
	v := m.brew_upgrade_all
	if v == nil {
		return
	}
	return *v, true
}

// OldBrewUpgradeAll returns the old "brew_upgrade_all" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldBrewUpgradeAll(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrewUpgradeAll is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrewUpgradeAll requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrewUpgradeAll: %w", err)
	}
	return oldValue.BrewUpgradeAll, nil
}

// ClearBrewUpgradeAll clears the value of the "brew_upgrade_all" field.
func (m *TaskMutation) ClearBrewUpgradeAll() {
	m.brew_upgrade_all = nil
	m.clearedFields[task.FieldBrewUpgradeAll] = struct{}{}
}

// BrewUpgradeAllCleared returns if the "brew_upgrade_all" field was cleared in this mutation.
func (m *TaskMutation) BrewUpgradeAllCleared() bool {
	_, ok := m.clearedFields[task.FieldBrewUpgradeAll]
	return ok
}

// ResetBrewUpgradeAll resets all changes to the "brew_upgrade_all" field.
func (m *TaskMutation) ResetBrewUpgradeAll() {
	m.brew_upgrade_all = nil
	delete(m.clearedFields, task.FieldBrewUpgradeAll)
}

// SetBrewUpgradeOptions sets the "brew_upgrade_options" field.
func (m *TaskMutation) SetBrewUpgradeOptions(s string) {
	m.brew_upgrade_options = &s
}

// BrewUpgradeOptions returns the value of the "brew_upgrade_options" field in the mutation.
func (m *TaskMutation) BrewUpgradeOptions() (r string, exists bool) {
	v := m.brew_upgrade_options
	if v == nil {
		return
	}
	return *v, true
}

// OldBrewUpgradeOptions returns the old "brew_upgrade_options" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldBrewUpgradeOptions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrewUpgradeOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrewUpgradeOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrewUpgradeOptions: %w", err)
	}
	return oldValue.BrewUpgradeOptions, nil
}

// ClearBrewUpgradeOptions clears the value of the "brew_upgrade_options" field.
func (m *TaskMutation) ClearBrewUpgradeOptions() {
	m.brew_upgrade_options = nil
	m.clearedFields[task.FieldBrewUpgradeOptions] = struct{}{}
}

// BrewUpgradeOptionsCleared returns if the "brew_upgrade_options" field was cleared in this mutation.
func (m *TaskMutation) BrewUpgradeOptionsCleared() bool {
	_, ok := m.clearedFields[task.FieldBrewUpgradeOptions]
	return ok
}

// ResetBrewUpgradeOptions resets all changes to the "brew_upgrade_options" field.
func (m *TaskMutation) ResetBrewUpgradeOptions() {
	m.brew_upgrade_options = nil
	delete(m.clearedFields, task.FieldBrewUpgradeOptions)
}

// SetBrewInstallOptions sets the "brew_install_options" field.
func (m *TaskMutation) SetBrewInstallOptions(s string) {
	m.brew_install_options = &s
}

// BrewInstallOptions returns the value of the "brew_install_options" field in the mutation.
func (m *TaskMutation) BrewInstallOptions() (r string, exists bool) {
	v := m.brew_install_options
	if v == nil {
		return
	}
	return *v, true
}

// OldBrewInstallOptions returns the old "brew_install_options" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldBrewInstallOptions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrewInstallOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrewInstallOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrewInstallOptions: %w", err)
	}
	return oldValue.BrewInstallOptions, nil
}

// ClearBrewInstallOptions clears the value of the "brew_install_options" field.
func (m *TaskMutation) ClearBrewInstallOptions() {
	m.brew_install_options = nil
	m.clearedFields[task.FieldBrewInstallOptions] = struct{}{}
}

// BrewInstallOptionsCleared returns if the "brew_install_options" field was cleared in this mutation.
func (m *TaskMutation) BrewInstallOptionsCleared() bool {
	_, ok := m.clearedFields[task.FieldBrewInstallOptions]
	return ok
}

// ResetBrewInstallOptions resets all changes to the "brew_install_options" field.
func (m *TaskMutation) ResetBrewInstallOptions() {
	m.brew_install_options = nil
	delete(m.clearedFields, task.FieldBrewInstallOptions)
}

// SetBrewGreedy sets the "brew_greedy" field.
func (m *TaskMutation) SetBrewGreedy(b bool) {
	m.brew_greedy = &b
}

// BrewGreedy returns the value of the "brew_greedy" field in the mutation.
func (m *TaskMutation) BrewGreedy() (r bool, exists bool) {
	v := m.brew_greedy
	if v == nil {
		return
	}
	return *v, true
}

// OldBrewGreedy returns the old "brew_greedy" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldBrewGreedy(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrewGreedy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrewGreedy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrewGreedy: %w", err)
	}
	return oldValue.BrewGreedy, nil
}

// ClearBrewGreedy clears the value of the "brew_greedy" field.
func (m *TaskMutation) ClearBrewGreedy() {
	m.brew_greedy = nil
	m.clearedFields[task.FieldBrewGreedy] = struct{}{}
}

// BrewGreedyCleared returns if the "brew_greedy" field was cleared in this mutation.
func (m *TaskMutation) BrewGreedyCleared() bool {
	_, ok := m.clearedFields[task.FieldBrewGreedy]
	return ok
}

// ResetBrewGreedy resets all changes to the "brew_greedy" field.
func (m *TaskMutation) ResetBrewGreedy() {
	m.brew_greedy = nil
	delete(m.clearedFields, task.FieldBrewGreedy)
}

// SetPackageVersion sets the "package_version" field.
func (m *TaskMutation) SetPackageVersion(s string) {
	m.package_version = &s
}

// PackageVersion returns the value of the "package_version" field in the mutation.
func (m *TaskMutation) PackageVersion() (r string, exists bool) {
	v := m.package_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageVersion returns the old "package_version" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPackageVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageVersion: %w", err)
	}
	return oldValue.PackageVersion, nil
}

// ClearPackageVersion clears the value of the "package_version" field.
func (m *TaskMutation) ClearPackageVersion() {
	m.package_version = nil
	m.clearedFields[task.FieldPackageVersion] = struct{}{}
}

// PackageVersionCleared returns if the "package_version" field was cleared in this mutation.
func (m *TaskMutation) PackageVersionCleared() bool {
	_, ok := m.clearedFields[task.FieldPackageVersion]
	return ok
}

// ResetPackageVersion resets all changes to the "package_version" field.
func (m *TaskMutation) ResetPackageVersion() {
	m.package_version = nil
	delete(m.clearedFields, task.FieldPackageVersion)
}

// SetAptAllowDowngrade sets the "apt_allow_downgrade" field.
func (m *TaskMutation) SetAptAllowDowngrade(b bool) {
	m.apt_allow_downgrade = &b
}

// AptAllowDowngrade returns the value of the "apt_allow_downgrade" field in the mutation.
func (m *TaskMutation) AptAllowDowngrade() (r bool, exists bool) {
	v := m.apt_allow_downgrade
	if v == nil {
		return
	}
	return *v, true
}

// OldAptAllowDowngrade returns the old "apt_allow_downgrade" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAptAllowDowngrade(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAptAllowDowngrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAptAllowDowngrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAptAllowDowngrade: %w", err)
	}
	return oldValue.AptAllowDowngrade, nil
}

// ClearAptAllowDowngrade clears the value of the "apt_allow_downgrade" field.
func (m *TaskMutation) ClearAptAllowDowngrade() {
	m.apt_allow_downgrade = nil
	m.clearedFields[task.FieldAptAllowDowngrade] = struct{}{}
}

// AptAllowDowngradeCleared returns if the "apt_allow_downgrade" field was cleared in this mutation.
func (m *TaskMutation) AptAllowDowngradeCleared() bool {
	_, ok := m.clearedFields[task.FieldAptAllowDowngrade]
	return ok
}

// ResetAptAllowDowngrade resets all changes to the "apt_allow_downgrade" field.
func (m *TaskMutation) ResetAptAllowDowngrade() {
	m.apt_allow_downgrade = nil
	delete(m.clearedFields, task.FieldAptAllowDowngrade)
}

// SetAptDeb sets the "apt_deb" field.
func (m *TaskMutation) SetAptDeb(s string) {
	m.apt_deb = &s
}

// AptDeb returns the value of the "apt_deb" field in the mutation.
func (m *TaskMutation) AptDeb() (r string, exists bool) {
	v := m.apt_deb
	if v == nil {
		return
	}
	return *v, true
}

// OldAptDeb returns the old "apt_deb" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAptDeb(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAptDeb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAptDeb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAptDeb: %w", err)
	}
	return oldValue.AptDeb, nil
}

// ClearAptDeb clears the value of the "apt_deb" field.
func (m *TaskMutation) ClearAptDeb() {
	m.apt_deb = nil
	m.clearedFields[task.FieldAptDeb] = struct{}{}
}

// AptDebCleared returns if the "apt_deb" field was cleared in this mutation.
func (m *TaskMutation) AptDebCleared() bool {
	_, ok := m.clearedFields[task.FieldAptDeb]
	return ok
}

// ResetAptDeb resets all changes to the "apt_deb" field.
func (m *TaskMutation) ResetAptDeb() {
	m.apt_deb = nil
	delete(m.clearedFields, task.FieldAptDeb)
}

// SetAptDpkgOptions sets the "apt_dpkg_options" field.
func (m *TaskMutation) SetAptDpkgOptions(s string) {
	m.apt_dpkg_options = &s
}

// AptDpkgOptions returns the value of the "apt_dpkg_options" field in the mutation.
func (m *TaskMutation) AptDpkgOptions() (r string, exists bool) {
	v := m.apt_dpkg_options
	if v == nil {
		return
	}
	return *v, true
}

// OldAptDpkgOptions returns the old "apt_dpkg_options" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAptDpkgOptions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAptDpkgOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAptDpkgOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAptDpkgOptions: %w", err)
	}
	return oldValue.AptDpkgOptions, nil
}

// ClearAptDpkgOptions clears the value of the "apt_dpkg_options" field.
func (m *TaskMutation) ClearAptDpkgOptions() {
	m.apt_dpkg_options = nil
	m.clearedFields[task.FieldAptDpkgOptions] = struct{}{}
}

// AptDpkgOptionsCleared returns if the "apt_dpkg_options" field was cleared in this mutation.
func (m *TaskMutation) AptDpkgOptionsCleared() bool {
	_, ok := m.clearedFields[task.FieldAptDpkgOptions]
	return ok
}

// ResetAptDpkgOptions resets all changes to the "apt_dpkg_options" field.
func (m *TaskMutation) ResetAptDpkgOptions() {
	m.apt_dpkg_options = nil
	delete(m.clearedFields, task.FieldAptDpkgOptions)
}

// SetAptFailOnAutoremove sets the "apt_fail_on_autoremove" field.
func (m *TaskMutation) SetAptFailOnAutoremove(b bool) {
	m.apt_fail_on_autoremove = &b
}

// AptFailOnAutoremove returns the value of the "apt_fail_on_autoremove" field in the mutation.
func (m *TaskMutation) AptFailOnAutoremove() (r bool, exists bool) {
	v := m.apt_fail_on_autoremove
	if v == nil {
		return
	}
	return *v, true
}

// OldAptFailOnAutoremove returns the old "apt_fail_on_autoremove" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAptFailOnAutoremove(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAptFailOnAutoremove is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAptFailOnAutoremove requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAptFailOnAutoremove: %w", err)
	}
	return oldValue.AptFailOnAutoremove, nil
}

// ClearAptFailOnAutoremove clears the value of the "apt_fail_on_autoremove" field.
func (m *TaskMutation) ClearAptFailOnAutoremove() {
	m.apt_fail_on_autoremove = nil
	m.clearedFields[task.FieldAptFailOnAutoremove] = struct{}{}
}

// AptFailOnAutoremoveCleared returns if the "apt_fail_on_autoremove" field was cleared in this mutation.
func (m *TaskMutation) AptFailOnAutoremoveCleared() bool {
	_, ok := m.clearedFields[task.FieldAptFailOnAutoremove]
	return ok
}

// ResetAptFailOnAutoremove resets all changes to the "apt_fail_on_autoremove" field.
func (m *TaskMutation) ResetAptFailOnAutoremove() {
	m.apt_fail_on_autoremove = nil
	delete(m.clearedFields, task.FieldAptFailOnAutoremove)
}

// SetAptForce sets the "apt_force" field.
func (m *TaskMutation) SetAptForce(b bool) {
	m.apt_force = &b
}

// AptForce returns the value of the "apt_force" field in the mutation.
func (m *TaskMutation) AptForce() (r bool, exists bool) {
	v := m.apt_force
	if v == nil {
		return
	}
	return *v, true
}

// OldAptForce returns the old "apt_force" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAptForce(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAptForce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAptForce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAptForce: %w", err)
	}
	return oldValue.AptForce, nil
}

// ClearAptForce clears the value of the "apt_force" field.
func (m *TaskMutation) ClearAptForce() {
	m.apt_force = nil
	m.clearedFields[task.FieldAptForce] = struct{}{}
}

// AptForceCleared returns if the "apt_force" field was cleared in this mutation.
func (m *TaskMutation) AptForceCleared() bool {
	_, ok := m.clearedFields[task.FieldAptForce]
	return ok
}

// ResetAptForce resets all changes to the "apt_force" field.
func (m *TaskMutation) ResetAptForce() {
	m.apt_force = nil
	delete(m.clearedFields, task.FieldAptForce)
}

// SetAptInstallRecommends sets the "apt_install_recommends" field.
func (m *TaskMutation) SetAptInstallRecommends(b bool) {
	m.apt_install_recommends = &b
}

// AptInstallRecommends returns the value of the "apt_install_recommends" field in the mutation.
func (m *TaskMutation) AptInstallRecommends() (r bool, exists bool) {
	v := m.apt_install_recommends
	if v == nil {
		return
	}
	return *v, true
}

// OldAptInstallRecommends returns the old "apt_install_recommends" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAptInstallRecommends(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAptInstallRecommends is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAptInstallRecommends requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAptInstallRecommends: %w", err)
	}
	return oldValue.AptInstallRecommends, nil
}

// ClearAptInstallRecommends clears the value of the "apt_install_recommends" field.
func (m *TaskMutation) ClearAptInstallRecommends() {
	m.apt_install_recommends = nil
	m.clearedFields[task.FieldAptInstallRecommends] = struct{}{}
}

// AptInstallRecommendsCleared returns if the "apt_install_recommends" field was cleared in this mutation.
func (m *TaskMutation) AptInstallRecommendsCleared() bool {
	_, ok := m.clearedFields[task.FieldAptInstallRecommends]
	return ok
}

// ResetAptInstallRecommends resets all changes to the "apt_install_recommends" field.
func (m *TaskMutation) ResetAptInstallRecommends() {
	m.apt_install_recommends = nil
	delete(m.clearedFields, task.FieldAptInstallRecommends)
}

// SetAptName sets the "apt_name" field.
func (m *TaskMutation) SetAptName(s string) {
	m.apt_name = &s
}

// AptName returns the value of the "apt_name" field in the mutation.
func (m *TaskMutation) AptName() (r string, exists bool) {
	v := m.apt_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAptName returns the old "apt_name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAptName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAptName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAptName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAptName: %w", err)
	}
	return oldValue.AptName, nil
}

// ClearAptName clears the value of the "apt_name" field.
func (m *TaskMutation) ClearAptName() {
	m.apt_name = nil
	m.clearedFields[task.FieldAptName] = struct{}{}
}

// AptNameCleared returns if the "apt_name" field was cleared in this mutation.
func (m *TaskMutation) AptNameCleared() bool {
	_, ok := m.clearedFields[task.FieldAptName]
	return ok
}

// ResetAptName resets all changes to the "apt_name" field.
func (m *TaskMutation) ResetAptName() {
	m.apt_name = nil
	delete(m.clearedFields, task.FieldAptName)
}

// SetAptOnlyUpgrade sets the "apt_only_upgrade" field.
func (m *TaskMutation) SetAptOnlyUpgrade(b bool) {
	m.apt_only_upgrade = &b
}

// AptOnlyUpgrade returns the value of the "apt_only_upgrade" field in the mutation.
func (m *TaskMutation) AptOnlyUpgrade() (r bool, exists bool) {
	v := m.apt_only_upgrade
	if v == nil {
		return
	}
	return *v, true
}

// OldAptOnlyUpgrade returns the old "apt_only_upgrade" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAptOnlyUpgrade(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAptOnlyUpgrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAptOnlyUpgrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAptOnlyUpgrade: %w", err)
	}
	return oldValue.AptOnlyUpgrade, nil
}

// ClearAptOnlyUpgrade clears the value of the "apt_only_upgrade" field.
func (m *TaskMutation) ClearAptOnlyUpgrade() {
	m.apt_only_upgrade = nil
	m.clearedFields[task.FieldAptOnlyUpgrade] = struct{}{}
}

// AptOnlyUpgradeCleared returns if the "apt_only_upgrade" field was cleared in this mutation.
func (m *TaskMutation) AptOnlyUpgradeCleared() bool {
	_, ok := m.clearedFields[task.FieldAptOnlyUpgrade]
	return ok
}

// ResetAptOnlyUpgrade resets all changes to the "apt_only_upgrade" field.
func (m *TaskMutation) ResetAptOnlyUpgrade() {
	m.apt_only_upgrade = nil
	delete(m.clearedFields, task.FieldAptOnlyUpgrade)
}

// SetAptPurge sets the "apt_purge" field.
func (m *TaskMutation) SetAptPurge(b bool) {
	m.apt_purge = &b
}

// AptPurge returns the value of the "apt_purge" field in the mutation.
func (m *TaskMutation) AptPurge() (r bool, exists bool) {
	v := m.apt_purge
	if v == nil {
		return
	}
	return *v, true
}

// OldAptPurge returns the old "apt_purge" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAptPurge(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAptPurge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAptPurge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAptPurge: %w", err)
	}
	return oldValue.AptPurge, nil
}

// ClearAptPurge clears the value of the "apt_purge" field.
func (m *TaskMutation) ClearAptPurge() {
	m.apt_purge = nil
	m.clearedFields[task.FieldAptPurge] = struct{}{}
}

// AptPurgeCleared returns if the "apt_purge" field was cleared in this mutation.
func (m *TaskMutation) AptPurgeCleared() bool {
	_, ok := m.clearedFields[task.FieldAptPurge]
	return ok
}

// ResetAptPurge resets all changes to the "apt_purge" field.
func (m *TaskMutation) ResetAptPurge() {
	m.apt_purge = nil
	delete(m.clearedFields, task.FieldAptPurge)
}

// SetAptUpdateCache sets the "apt_update_cache" field.
func (m *TaskMutation) SetAptUpdateCache(b bool) {
	m.apt_update_cache = &b
}

// AptUpdateCache returns the value of the "apt_update_cache" field in the mutation.
func (m *TaskMutation) AptUpdateCache() (r bool, exists bool) {
	v := m.apt_update_cache
	if v == nil {
		return
	}
	return *v, true
}

// OldAptUpdateCache returns the old "apt_update_cache" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAptUpdateCache(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAptUpdateCache is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAptUpdateCache requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAptUpdateCache: %w", err)
	}
	return oldValue.AptUpdateCache, nil
}

// ClearAptUpdateCache clears the value of the "apt_update_cache" field.
func (m *TaskMutation) ClearAptUpdateCache() {
	m.apt_update_cache = nil
	m.clearedFields[task.FieldAptUpdateCache] = struct{}{}
}

// AptUpdateCacheCleared returns if the "apt_update_cache" field was cleared in this mutation.
func (m *TaskMutation) AptUpdateCacheCleared() bool {
	_, ok := m.clearedFields[task.FieldAptUpdateCache]
	return ok
}

// ResetAptUpdateCache resets all changes to the "apt_update_cache" field.
func (m *TaskMutation) ResetAptUpdateCache() {
	m.apt_update_cache = nil
	delete(m.clearedFields, task.FieldAptUpdateCache)
}

// SetAptUpgradeType sets the "apt_upgrade_type" field.
func (m *TaskMutation) SetAptUpgradeType(tut task.AptUpgradeType) {
	m.apt_upgrade_type = &tut
}

// AptUpgradeType returns the value of the "apt_upgrade_type" field in the mutation.
func (m *TaskMutation) AptUpgradeType() (r task.AptUpgradeType, exists bool) {
	v := m.apt_upgrade_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAptUpgradeType returns the old "apt_upgrade_type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAptUpgradeType(ctx context.Context) (v task.AptUpgradeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAptUpgradeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAptUpgradeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAptUpgradeType: %w", err)
	}
	return oldValue.AptUpgradeType, nil
}

// ClearAptUpgradeType clears the value of the "apt_upgrade_type" field.
func (m *TaskMutation) ClearAptUpgradeType() {
	m.apt_upgrade_type = nil
	m.clearedFields[task.FieldAptUpgradeType] = struct{}{}
}

// AptUpgradeTypeCleared returns if the "apt_upgrade_type" field was cleared in this mutation.
func (m *TaskMutation) AptUpgradeTypeCleared() bool {
	_, ok := m.clearedFields[task.FieldAptUpgradeType]
	return ok
}

// ResetAptUpgradeType resets all changes to the "apt_upgrade_type" field.
func (m *TaskMutation) ResetAptUpgradeType() {
	m.apt_upgrade_type = nil
	delete(m.clearedFields, task.FieldAptUpgradeType)
}

// SetVersion sets the "version" field.
func (m *TaskMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *TaskMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *TaskMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *TaskMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ClearVersion clears the value of the "version" field.
func (m *TaskMutation) ClearVersion() {
	m.version = nil
	m.addversion = nil
	m.clearedFields[task.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *TaskMutation) VersionCleared() bool {
	_, ok := m.clearedFields[task.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *TaskMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
	delete(m.clearedFields, task.FieldVersion)
}

// SetTenant sets the "tenant" field.
func (m *TaskMutation) SetTenant(i int) {
	m.tenant = &i
	m.addtenant = nil
}

// Tenant returns the value of the "tenant" field in the mutation.
func (m *TaskMutation) Tenant() (r int, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenant returns the old "tenant" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTenant(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenant: %w", err)
	}
	return oldValue.Tenant, nil
}

// AddTenant adds i to the "tenant" field.
func (m *TaskMutation) AddTenant(i int) {
	if m.addtenant != nil {
		*m.addtenant += i
	} else {
		m.addtenant = &i
	}
}

// AddedTenant returns the value that was added to the "tenant" field in this mutation.
func (m *TaskMutation) AddedTenant() (r int, exists bool) {
	v := m.addtenant
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenant clears the value of the "tenant" field.
func (m *TaskMutation) ClearTenant() {
	m.tenant = nil
	m.addtenant = nil
	m.clearedFields[task.FieldTenant] = struct{}{}
}

// TenantCleared returns if the "tenant" field was cleared in this mutation.
func (m *TaskMutation) TenantCleared() bool {
	_, ok := m.clearedFields[task.FieldTenant]
	return ok
}

// ResetTenant resets all changes to the "tenant" field.
func (m *TaskMutation) ResetTenant() {
	m.tenant = nil
	m.addtenant = nil
	delete(m.clearedFields, task.FieldTenant)
}

// SetNetbirdGroups sets the "netbird_groups" field.
func (m *TaskMutation) SetNetbirdGroups(s string) {
	m.netbird_groups = &s
}

// NetbirdGroups returns the value of the "netbird_groups" field in the mutation.
func (m *TaskMutation) NetbirdGroups() (r string, exists bool) {
	v := m.netbird_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldNetbirdGroups returns the old "netbird_groups" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldNetbirdGroups(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetbirdGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetbirdGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetbirdGroups: %w", err)
	}
	return oldValue.NetbirdGroups, nil
}

// ClearNetbirdGroups clears the value of the "netbird_groups" field.
func (m *TaskMutation) ClearNetbirdGroups() {
	m.netbird_groups = nil
	m.clearedFields[task.FieldNetbirdGroups] = struct{}{}
}

// NetbirdGroupsCleared returns if the "netbird_groups" field was cleared in this mutation.
func (m *TaskMutation) NetbirdGroupsCleared() bool {
	_, ok := m.clearedFields[task.FieldNetbirdGroups]
	return ok
}

// ResetNetbirdGroups resets all changes to the "netbird_groups" field.
func (m *TaskMutation) ResetNetbirdGroups() {
	m.netbird_groups = nil
	delete(m.clearedFields, task.FieldNetbirdGroups)
}

// SetNetbirdAllowExtraDNSLabels sets the "netbird_allow_extra_dns_labels" field.
func (m *TaskMutation) SetNetbirdAllowExtraDNSLabels(b bool) {
	m.netbird_allow_extra_dns_labels = &b
}

// NetbirdAllowExtraDNSLabels returns the value of the "netbird_allow_extra_dns_labels" field in the mutation.
func (m *TaskMutation) NetbirdAllowExtraDNSLabels() (r bool, exists bool) {
	v := m.netbird_allow_extra_dns_labels
	if v == nil {
		return
	}
	return *v, true
}

// OldNetbirdAllowExtraDNSLabels returns the old "netbird_allow_extra_dns_labels" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldNetbirdAllowExtraDNSLabels(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetbirdAllowExtraDNSLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetbirdAllowExtraDNSLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetbirdAllowExtraDNSLabels: %w", err)
	}
	return oldValue.NetbirdAllowExtraDNSLabels, nil
}

// ClearNetbirdAllowExtraDNSLabels clears the value of the "netbird_allow_extra_dns_labels" field.
func (m *TaskMutation) ClearNetbirdAllowExtraDNSLabels() {
	m.netbird_allow_extra_dns_labels = nil
	m.clearedFields[task.FieldNetbirdAllowExtraDNSLabels] = struct{}{}
}

// NetbirdAllowExtraDNSLabelsCleared returns if the "netbird_allow_extra_dns_labels" field was cleared in this mutation.
func (m *TaskMutation) NetbirdAllowExtraDNSLabelsCleared() bool {
	_, ok := m.clearedFields[task.FieldNetbirdAllowExtraDNSLabels]
	return ok
}

// ResetNetbirdAllowExtraDNSLabels resets all changes to the "netbird_allow_extra_dns_labels" field.
func (m *TaskMutation) ResetNetbirdAllowExtraDNSLabels() {
	m.netbird_allow_extra_dns_labels = nil
	delete(m.clearedFields, task.FieldNetbirdAllowExtraDNSLabels)
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *TaskMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *TaskMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *TaskMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *TaskMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *TaskMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *TaskMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *TaskMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *TaskMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *TaskMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *TaskMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *TaskMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *TaskMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 88)
	if m.name != nil {
		fields = append(fields, task.FieldName)
	}
	if m._type != nil {
		fields = append(fields, task.FieldType)
	}
	if m.package_id != nil {
		fields = append(fields, task.FieldPackageID)
	}
	if m.package_name != nil {
		fields = append(fields, task.FieldPackageName)
	}
	if m.package_latest != nil {
		fields = append(fields, task.FieldPackageLatest)
	}
	if m.registry_key != nil {
		fields = append(fields, task.FieldRegistryKey)
	}
	if m.registry_key_value_name != nil {
		fields = append(fields, task.FieldRegistryKeyValueName)
	}
	if m.registry_key_value_type != nil {
		fields = append(fields, task.FieldRegistryKeyValueType)
	}
	if m.registry_key_value_data != nil {
		fields = append(fields, task.FieldRegistryKeyValueData)
	}
	if m.registry_hex != nil {
		fields = append(fields, task.FieldRegistryHex)
	}
	if m.registry_force != nil {
		fields = append(fields, task.FieldRegistryForce)
	}
	if m.local_user_username != nil {
		fields = append(fields, task.FieldLocalUserUsername)
	}
	if m.local_user_description != nil {
		fields = append(fields, task.FieldLocalUserDescription)
	}
	if m.local_user_disable != nil {
		fields = append(fields, task.FieldLocalUserDisable)
	}
	if m.local_user_fullname != nil {
		fields = append(fields, task.FieldLocalUserFullname)
	}
	if m.local_user_password != nil {
		fields = append(fields, task.FieldLocalUserPassword)
	}
	if m.local_user_password_change_not_allowed != nil {
		fields = append(fields, task.FieldLocalUserPasswordChangeNotAllowed)
	}
	if m.local_user_password_change_required != nil {
		fields = append(fields, task.FieldLocalUserPasswordChangeRequired)
	}
	if m.local_user_password_never_expires != nil {
		fields = append(fields, task.FieldLocalUserPasswordNeverExpires)
	}
	if m.local_user_append != nil {
		fields = append(fields, task.FieldLocalUserAppend)
	}
	if m.local_user_create_home != nil {
		fields = append(fields, task.FieldLocalUserCreateHome)
	}
	if m.local_user_expires != nil {
		fields = append(fields, task.FieldLocalUserExpires)
	}
	if m.local_user_force != nil {
		fields = append(fields, task.FieldLocalUserForce)
	}
	if m.local_user_generate_ssh_key != nil {
		fields = append(fields, task.FieldLocalUserGenerateSSHKey)
	}
	if m.local_user_group != nil {
		fields = append(fields, task.FieldLocalUserGroup)
	}
	if m.local_user_groups != nil {
		fields = append(fields, task.FieldLocalUserGroups)
	}
	if m.local_user_home != nil {
		fields = append(fields, task.FieldLocalUserHome)
	}
	if m.local_user_move_home != nil {
		fields = append(fields, task.FieldLocalUserMoveHome)
	}
	if m.local_user_nonunique != nil {
		fields = append(fields, task.FieldLocalUserNonunique)
	}
	if m.local_user_password_expire_account_disable != nil {
		fields = append(fields, task.FieldLocalUserPasswordExpireAccountDisable)
	}
	if m.local_user_password_expire_max != nil {
		fields = append(fields, task.FieldLocalUserPasswordExpireMax)
	}
	if m.local_user_password_expire_min != nil {
		fields = append(fields, task.FieldLocalUserPasswordExpireMin)
	}
	if m.local_user_password_expire_warn != nil {
		fields = append(fields, task.FieldLocalUserPasswordExpireWarn)
	}
	if m.local_user_password_lock != nil {
		fields = append(fields, task.FieldLocalUserPasswordLock)
	}
	if m.local_user_seuser != nil {
		fields = append(fields, task.FieldLocalUserSeuser)
	}
	if m.local_user_shell != nil {
		fields = append(fields, task.FieldLocalUserShell)
	}
	if m.local_user_skeleton != nil {
		fields = append(fields, task.FieldLocalUserSkeleton)
	}
	if m.local_user_system != nil {
		fields = append(fields, task.FieldLocalUserSystem)
	}
	if m.local_user_id != nil {
		fields = append(fields, task.FieldLocalUserID)
	}
	if m.local_user_id_max != nil {
		fields = append(fields, task.FieldLocalUserIDMax)
	}
	if m.local_user_id_min != nil {
		fields = append(fields, task.FieldLocalUserIDMin)
	}
	if m.local_user_ssh_key_bits != nil {
		fields = append(fields, task.FieldLocalUserSSHKeyBits)
	}
	if m.local_user_ssh_key_comment != nil {
		fields = append(fields, task.FieldLocalUserSSHKeyComment)
	}
	if m.local_user_ssh_key_file != nil {
		fields = append(fields, task.FieldLocalUserSSHKeyFile)
	}
	if m.local_user_ssh_key_passphrase != nil {
		fields = append(fields, task.FieldLocalUserSSHKeyPassphrase)
	}
	if m.local_user_ssh_key_type != nil {
		fields = append(fields, task.FieldLocalUserSSHKeyType)
	}
	if m.local_user_umask != nil {
		fields = append(fields, task.FieldLocalUserUmask)
	}
	if m.local_group_id != nil {
		fields = append(fields, task.FieldLocalGroupID)
	}
	if m.local_group_name != nil {
		fields = append(fields, task.FieldLocalGroupName)
	}
	if m.local_group_description != nil {
		fields = append(fields, task.FieldLocalGroupDescription)
	}
	if m.local_group_system != nil {
		fields = append(fields, task.FieldLocalGroupSystem)
	}
	if m.local_group_force != nil {
		fields = append(fields, task.FieldLocalGroupForce)
	}
	if m.local_group_members != nil {
		fields = append(fields, task.FieldLocalGroupMembers)
	}
	if m.local_group_members_to_include != nil {
		fields = append(fields, task.FieldLocalGroupMembersToInclude)
	}
	if m.local_group_members_to_exclude != nil {
		fields = append(fields, task.FieldLocalGroupMembersToExclude)
	}
	if m.msi_productid != nil {
		fields = append(fields, task.FieldMsiProductid)
	}
	if m.msi_path != nil {
		fields = append(fields, task.FieldMsiPath)
	}
	if m.msi_arguments != nil {
		fields = append(fields, task.FieldMsiArguments)
	}
	if m.msi_file_hash != nil {
		fields = append(fields, task.FieldMsiFileHash)
	}
	if m.msi_file_hash_alg != nil {
		fields = append(fields, task.FieldMsiFileHashAlg)
	}
	if m.msi_log_path != nil {
		fields = append(fields, task.FieldMsiLogPath)
	}
	if m.script != nil {
		fields = append(fields, task.FieldScript)
	}
	if m.script_executable != nil {
		fields = append(fields, task.FieldScriptExecutable)
	}
	if m.script_creates != nil {
		fields = append(fields, task.FieldScriptCreates)
	}
	if m.script_run != nil {
		fields = append(fields, task.FieldScriptRun)
	}
	if m.agent_type != nil {
		fields = append(fields, task.FieldAgentType)
	}
	if m.when != nil {
		fields = append(fields, task.FieldWhen)
	}
	if m.brew_update != nil {
		fields = append(fields, task.FieldBrewUpdate)
	}
	if m.brew_upgrade_all != nil {
		fields = append(fields, task.FieldBrewUpgradeAll)
	}
	if m.brew_upgrade_options != nil {
		fields = append(fields, task.FieldBrewUpgradeOptions)
	}
	if m.brew_install_options != nil {
		fields = append(fields, task.FieldBrewInstallOptions)
	}
	if m.brew_greedy != nil {
		fields = append(fields, task.FieldBrewGreedy)
	}
	if m.package_version != nil {
		fields = append(fields, task.FieldPackageVersion)
	}
	if m.apt_allow_downgrade != nil {
		fields = append(fields, task.FieldAptAllowDowngrade)
	}
	if m.apt_deb != nil {
		fields = append(fields, task.FieldAptDeb)
	}
	if m.apt_dpkg_options != nil {
		fields = append(fields, task.FieldAptDpkgOptions)
	}
	if m.apt_fail_on_autoremove != nil {
		fields = append(fields, task.FieldAptFailOnAutoremove)
	}
	if m.apt_force != nil {
		fields = append(fields, task.FieldAptForce)
	}
	if m.apt_install_recommends != nil {
		fields = append(fields, task.FieldAptInstallRecommends)
	}
	if m.apt_name != nil {
		fields = append(fields, task.FieldAptName)
	}
	if m.apt_only_upgrade != nil {
		fields = append(fields, task.FieldAptOnlyUpgrade)
	}
	if m.apt_purge != nil {
		fields = append(fields, task.FieldAptPurge)
	}
	if m.apt_update_cache != nil {
		fields = append(fields, task.FieldAptUpdateCache)
	}
	if m.apt_upgrade_type != nil {
		fields = append(fields, task.FieldAptUpgradeType)
	}
	if m.version != nil {
		fields = append(fields, task.FieldVersion)
	}
	if m.tenant != nil {
		fields = append(fields, task.FieldTenant)
	}
	if m.netbird_groups != nil {
		fields = append(fields, task.FieldNetbirdGroups)
	}
	if m.netbird_allow_extra_dns_labels != nil {
		fields = append(fields, task.FieldNetbirdAllowExtraDNSLabels)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldName:
		return m.Name()
	case task.FieldType:
		return m.GetType()
	case task.FieldPackageID:
		return m.PackageID()
	case task.FieldPackageName:
		return m.PackageName()
	case task.FieldPackageLatest:
		return m.PackageLatest()
	case task.FieldRegistryKey:
		return m.RegistryKey()
	case task.FieldRegistryKeyValueName:
		return m.RegistryKeyValueName()
	case task.FieldRegistryKeyValueType:
		return m.RegistryKeyValueType()
	case task.FieldRegistryKeyValueData:
		return m.RegistryKeyValueData()
	case task.FieldRegistryHex:
		return m.RegistryHex()
	case task.FieldRegistryForce:
		return m.RegistryForce()
	case task.FieldLocalUserUsername:
		return m.LocalUserUsername()
	case task.FieldLocalUserDescription:
		return m.LocalUserDescription()
	case task.FieldLocalUserDisable:
		return m.LocalUserDisable()
	case task.FieldLocalUserFullname:
		return m.LocalUserFullname()
	case task.FieldLocalUserPassword:
		return m.LocalUserPassword()
	case task.FieldLocalUserPasswordChangeNotAllowed:
		return m.LocalUserPasswordChangeNotAllowed()
	case task.FieldLocalUserPasswordChangeRequired:
		return m.LocalUserPasswordChangeRequired()
	case task.FieldLocalUserPasswordNeverExpires:
		return m.LocalUserPasswordNeverExpires()
	case task.FieldLocalUserAppend:
		return m.LocalUserAppend()
	case task.FieldLocalUserCreateHome:
		return m.LocalUserCreateHome()
	case task.FieldLocalUserExpires:
		return m.LocalUserExpires()
	case task.FieldLocalUserForce:
		return m.LocalUserForce()
	case task.FieldLocalUserGenerateSSHKey:
		return m.LocalUserGenerateSSHKey()
	case task.FieldLocalUserGroup:
		return m.LocalUserGroup()
	case task.FieldLocalUserGroups:
		return m.LocalUserGroups()
	case task.FieldLocalUserHome:
		return m.LocalUserHome()
	case task.FieldLocalUserMoveHome:
		return m.LocalUserMoveHome()
	case task.FieldLocalUserNonunique:
		return m.LocalUserNonunique()
	case task.FieldLocalUserPasswordExpireAccountDisable:
		return m.LocalUserPasswordExpireAccountDisable()
	case task.FieldLocalUserPasswordExpireMax:
		return m.LocalUserPasswordExpireMax()
	case task.FieldLocalUserPasswordExpireMin:
		return m.LocalUserPasswordExpireMin()
	case task.FieldLocalUserPasswordExpireWarn:
		return m.LocalUserPasswordExpireWarn()
	case task.FieldLocalUserPasswordLock:
		return m.LocalUserPasswordLock()
	case task.FieldLocalUserSeuser:
		return m.LocalUserSeuser()
	case task.FieldLocalUserShell:
		return m.LocalUserShell()
	case task.FieldLocalUserSkeleton:
		return m.LocalUserSkeleton()
	case task.FieldLocalUserSystem:
		return m.LocalUserSystem()
	case task.FieldLocalUserID:
		return m.LocalUserID()
	case task.FieldLocalUserIDMax:
		return m.LocalUserIDMax()
	case task.FieldLocalUserIDMin:
		return m.LocalUserIDMin()
	case task.FieldLocalUserSSHKeyBits:
		return m.LocalUserSSHKeyBits()
	case task.FieldLocalUserSSHKeyComment:
		return m.LocalUserSSHKeyComment()
	case task.FieldLocalUserSSHKeyFile:
		return m.LocalUserSSHKeyFile()
	case task.FieldLocalUserSSHKeyPassphrase:
		return m.LocalUserSSHKeyPassphrase()
	case task.FieldLocalUserSSHKeyType:
		return m.LocalUserSSHKeyType()
	case task.FieldLocalUserUmask:
		return m.LocalUserUmask()
	case task.FieldLocalGroupID:
		return m.LocalGroupID()
	case task.FieldLocalGroupName:
		return m.LocalGroupName()
	case task.FieldLocalGroupDescription:
		return m.LocalGroupDescription()
	case task.FieldLocalGroupSystem:
		return m.LocalGroupSystem()
	case task.FieldLocalGroupForce:
		return m.LocalGroupForce()
	case task.FieldLocalGroupMembers:
		return m.LocalGroupMembers()
	case task.FieldLocalGroupMembersToInclude:
		return m.LocalGroupMembersToInclude()
	case task.FieldLocalGroupMembersToExclude:
		return m.LocalGroupMembersToExclude()
	case task.FieldMsiProductid:
		return m.MsiProductid()
	case task.FieldMsiPath:
		return m.MsiPath()
	case task.FieldMsiArguments:
		return m.MsiArguments()
	case task.FieldMsiFileHash:
		return m.MsiFileHash()
	case task.FieldMsiFileHashAlg:
		return m.MsiFileHashAlg()
	case task.FieldMsiLogPath:
		return m.MsiLogPath()
	case task.FieldScript:
		return m.Script()
	case task.FieldScriptExecutable:
		return m.ScriptExecutable()
	case task.FieldScriptCreates:
		return m.ScriptCreates()
	case task.FieldScriptRun:
		return m.ScriptRun()
	case task.FieldAgentType:
		return m.AgentType()
	case task.FieldWhen:
		return m.When()
	case task.FieldBrewUpdate:
		return m.BrewUpdate()
	case task.FieldBrewUpgradeAll:
		return m.BrewUpgradeAll()
	case task.FieldBrewUpgradeOptions:
		return m.BrewUpgradeOptions()
	case task.FieldBrewInstallOptions:
		return m.BrewInstallOptions()
	case task.FieldBrewGreedy:
		return m.BrewGreedy()
	case task.FieldPackageVersion:
		return m.PackageVersion()
	case task.FieldAptAllowDowngrade:
		return m.AptAllowDowngrade()
	case task.FieldAptDeb:
		return m.AptDeb()
	case task.FieldAptDpkgOptions:
		return m.AptDpkgOptions()
	case task.FieldAptFailOnAutoremove:
		return m.AptFailOnAutoremove()
	case task.FieldAptForce:
		return m.AptForce()
	case task.FieldAptInstallRecommends:
		return m.AptInstallRecommends()
	case task.FieldAptName:
		return m.AptName()
	case task.FieldAptOnlyUpgrade:
		return m.AptOnlyUpgrade()
	case task.FieldAptPurge:
		return m.AptPurge()
	case task.FieldAptUpdateCache:
		return m.AptUpdateCache()
	case task.FieldAptUpgradeType:
		return m.AptUpgradeType()
	case task.FieldVersion:
		return m.Version()
	case task.FieldTenant:
		return m.Tenant()
	case task.FieldNetbirdGroups:
		return m.NetbirdGroups()
	case task.FieldNetbirdAllowExtraDNSLabels:
		return m.NetbirdAllowExtraDNSLabels()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldName:
		return m.OldName(ctx)
	case task.FieldType:
		return m.OldType(ctx)
	case task.FieldPackageID:
		return m.OldPackageID(ctx)
	case task.FieldPackageName:
		return m.OldPackageName(ctx)
	case task.FieldPackageLatest:
		return m.OldPackageLatest(ctx)
	case task.FieldRegistryKey:
		return m.OldRegistryKey(ctx)
	case task.FieldRegistryKeyValueName:
		return m.OldRegistryKeyValueName(ctx)
	case task.FieldRegistryKeyValueType:
		return m.OldRegistryKeyValueType(ctx)
	case task.FieldRegistryKeyValueData:
		return m.OldRegistryKeyValueData(ctx)
	case task.FieldRegistryHex:
		return m.OldRegistryHex(ctx)
	case task.FieldRegistryForce:
		return m.OldRegistryForce(ctx)
	case task.FieldLocalUserUsername:
		return m.OldLocalUserUsername(ctx)
	case task.FieldLocalUserDescription:
		return m.OldLocalUserDescription(ctx)
	case task.FieldLocalUserDisable:
		return m.OldLocalUserDisable(ctx)
	case task.FieldLocalUserFullname:
		return m.OldLocalUserFullname(ctx)
	case task.FieldLocalUserPassword:
		return m.OldLocalUserPassword(ctx)
	case task.FieldLocalUserPasswordChangeNotAllowed:
		return m.OldLocalUserPasswordChangeNotAllowed(ctx)
	case task.FieldLocalUserPasswordChangeRequired:
		return m.OldLocalUserPasswordChangeRequired(ctx)
	case task.FieldLocalUserPasswordNeverExpires:
		return m.OldLocalUserPasswordNeverExpires(ctx)
	case task.FieldLocalUserAppend:
		return m.OldLocalUserAppend(ctx)
	case task.FieldLocalUserCreateHome:
		return m.OldLocalUserCreateHome(ctx)
	case task.FieldLocalUserExpires:
		return m.OldLocalUserExpires(ctx)
	case task.FieldLocalUserForce:
		return m.OldLocalUserForce(ctx)
	case task.FieldLocalUserGenerateSSHKey:
		return m.OldLocalUserGenerateSSHKey(ctx)
	case task.FieldLocalUserGroup:
		return m.OldLocalUserGroup(ctx)
	case task.FieldLocalUserGroups:
		return m.OldLocalUserGroups(ctx)
	case task.FieldLocalUserHome:
		return m.OldLocalUserHome(ctx)
	case task.FieldLocalUserMoveHome:
		return m.OldLocalUserMoveHome(ctx)
	case task.FieldLocalUserNonunique:
		return m.OldLocalUserNonunique(ctx)
	case task.FieldLocalUserPasswordExpireAccountDisable:
		return m.OldLocalUserPasswordExpireAccountDisable(ctx)
	case task.FieldLocalUserPasswordExpireMax:
		return m.OldLocalUserPasswordExpireMax(ctx)
	case task.FieldLocalUserPasswordExpireMin:
		return m.OldLocalUserPasswordExpireMin(ctx)
	case task.FieldLocalUserPasswordExpireWarn:
		return m.OldLocalUserPasswordExpireWarn(ctx)
	case task.FieldLocalUserPasswordLock:
		return m.OldLocalUserPasswordLock(ctx)
	case task.FieldLocalUserSeuser:
		return m.OldLocalUserSeuser(ctx)
	case task.FieldLocalUserShell:
		return m.OldLocalUserShell(ctx)
	case task.FieldLocalUserSkeleton:
		return m.OldLocalUserSkeleton(ctx)
	case task.FieldLocalUserSystem:
		return m.OldLocalUserSystem(ctx)
	case task.FieldLocalUserID:
		return m.OldLocalUserID(ctx)
	case task.FieldLocalUserIDMax:
		return m.OldLocalUserIDMax(ctx)
	case task.FieldLocalUserIDMin:
		return m.OldLocalUserIDMin(ctx)
	case task.FieldLocalUserSSHKeyBits:
		return m.OldLocalUserSSHKeyBits(ctx)
	case task.FieldLocalUserSSHKeyComment:
		return m.OldLocalUserSSHKeyComment(ctx)
	case task.FieldLocalUserSSHKeyFile:
		return m.OldLocalUserSSHKeyFile(ctx)
	case task.FieldLocalUserSSHKeyPassphrase:
		return m.OldLocalUserSSHKeyPassphrase(ctx)
	case task.FieldLocalUserSSHKeyType:
		return m.OldLocalUserSSHKeyType(ctx)
	case task.FieldLocalUserUmask:
		return m.OldLocalUserUmask(ctx)
	case task.FieldLocalGroupID:
		return m.OldLocalGroupID(ctx)
	case task.FieldLocalGroupName:
		return m.OldLocalGroupName(ctx)
	case task.FieldLocalGroupDescription:
		return m.OldLocalGroupDescription(ctx)
	case task.FieldLocalGroupSystem:
		return m.OldLocalGroupSystem(ctx)
	case task.FieldLocalGroupForce:
		return m.OldLocalGroupForce(ctx)
	case task.FieldLocalGroupMembers:
		return m.OldLocalGroupMembers(ctx)
	case task.FieldLocalGroupMembersToInclude:
		return m.OldLocalGroupMembersToInclude(ctx)
	case task.FieldLocalGroupMembersToExclude:
		return m.OldLocalGroupMembersToExclude(ctx)
	case task.FieldMsiProductid:
		return m.OldMsiProductid(ctx)
	case task.FieldMsiPath:
		return m.OldMsiPath(ctx)
	case task.FieldMsiArguments:
		return m.OldMsiArguments(ctx)
	case task.FieldMsiFileHash:
		return m.OldMsiFileHash(ctx)
	case task.FieldMsiFileHashAlg:
		return m.OldMsiFileHashAlg(ctx)
	case task.FieldMsiLogPath:
		return m.OldMsiLogPath(ctx)
	case task.FieldScript:
		return m.OldScript(ctx)
	case task.FieldScriptExecutable:
		return m.OldScriptExecutable(ctx)
	case task.FieldScriptCreates:
		return m.OldScriptCreates(ctx)
	case task.FieldScriptRun:
		return m.OldScriptRun(ctx)
	case task.FieldAgentType:
		return m.OldAgentType(ctx)
	case task.FieldWhen:
		return m.OldWhen(ctx)
	case task.FieldBrewUpdate:
		return m.OldBrewUpdate(ctx)
	case task.FieldBrewUpgradeAll:
		return m.OldBrewUpgradeAll(ctx)
	case task.FieldBrewUpgradeOptions:
		return m.OldBrewUpgradeOptions(ctx)
	case task.FieldBrewInstallOptions:
		return m.OldBrewInstallOptions(ctx)
	case task.FieldBrewGreedy:
		return m.OldBrewGreedy(ctx)
	case task.FieldPackageVersion:
		return m.OldPackageVersion(ctx)
	case task.FieldAptAllowDowngrade:
		return m.OldAptAllowDowngrade(ctx)
	case task.FieldAptDeb:
		return m.OldAptDeb(ctx)
	case task.FieldAptDpkgOptions:
		return m.OldAptDpkgOptions(ctx)
	case task.FieldAptFailOnAutoremove:
		return m.OldAptFailOnAutoremove(ctx)
	case task.FieldAptForce:
		return m.OldAptForce(ctx)
	case task.FieldAptInstallRecommends:
		return m.OldAptInstallRecommends(ctx)
	case task.FieldAptName:
		return m.OldAptName(ctx)
	case task.FieldAptOnlyUpgrade:
		return m.OldAptOnlyUpgrade(ctx)
	case task.FieldAptPurge:
		return m.OldAptPurge(ctx)
	case task.FieldAptUpdateCache:
		return m.OldAptUpdateCache(ctx)
	case task.FieldAptUpgradeType:
		return m.OldAptUpgradeType(ctx)
	case task.FieldVersion:
		return m.OldVersion(ctx)
	case task.FieldTenant:
		return m.OldTenant(ctx)
	case task.FieldNetbirdGroups:
		return m.OldNetbirdGroups(ctx)
	case task.FieldNetbirdAllowExtraDNSLabels:
		return m.OldNetbirdAllowExtraDNSLabels(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case task.FieldType:
		v, ok := value.(task.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case task.FieldPackageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case task.FieldPackageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageName(v)
		return nil
	case task.FieldPackageLatest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageLatest(v)
		return nil
	case task.FieldRegistryKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistryKey(v)
		return nil
	case task.FieldRegistryKeyValueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistryKeyValueName(v)
		return nil
	case task.FieldRegistryKeyValueType:
		v, ok := value.(task.RegistryKeyValueType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistryKeyValueType(v)
		return nil
	case task.FieldRegistryKeyValueData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistryKeyValueData(v)
		return nil
	case task.FieldRegistryHex:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistryHex(v)
		return nil
	case task.FieldRegistryForce:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistryForce(v)
		return nil
	case task.FieldLocalUserUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserUsername(v)
		return nil
	case task.FieldLocalUserDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserDescription(v)
		return nil
	case task.FieldLocalUserDisable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserDisable(v)
		return nil
	case task.FieldLocalUserFullname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserFullname(v)
		return nil
	case task.FieldLocalUserPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserPassword(v)
		return nil
	case task.FieldLocalUserPasswordChangeNotAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserPasswordChangeNotAllowed(v)
		return nil
	case task.FieldLocalUserPasswordChangeRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserPasswordChangeRequired(v)
		return nil
	case task.FieldLocalUserPasswordNeverExpires:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserPasswordNeverExpires(v)
		return nil
	case task.FieldLocalUserAppend:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserAppend(v)
		return nil
	case task.FieldLocalUserCreateHome:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserCreateHome(v)
		return nil
	case task.FieldLocalUserExpires:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserExpires(v)
		return nil
	case task.FieldLocalUserForce:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserForce(v)
		return nil
	case task.FieldLocalUserGenerateSSHKey:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserGenerateSSHKey(v)
		return nil
	case task.FieldLocalUserGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserGroup(v)
		return nil
	case task.FieldLocalUserGroups:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserGroups(v)
		return nil
	case task.FieldLocalUserHome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserHome(v)
		return nil
	case task.FieldLocalUserMoveHome:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserMoveHome(v)
		return nil
	case task.FieldLocalUserNonunique:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserNonunique(v)
		return nil
	case task.FieldLocalUserPasswordExpireAccountDisable:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserPasswordExpireAccountDisable(v)
		return nil
	case task.FieldLocalUserPasswordExpireMax:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserPasswordExpireMax(v)
		return nil
	case task.FieldLocalUserPasswordExpireMin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserPasswordExpireMin(v)
		return nil
	case task.FieldLocalUserPasswordExpireWarn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserPasswordExpireWarn(v)
		return nil
	case task.FieldLocalUserPasswordLock:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserPasswordLock(v)
		return nil
	case task.FieldLocalUserSeuser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserSeuser(v)
		return nil
	case task.FieldLocalUserShell:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserShell(v)
		return nil
	case task.FieldLocalUserSkeleton:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserSkeleton(v)
		return nil
	case task.FieldLocalUserSystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserSystem(v)
		return nil
	case task.FieldLocalUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserID(v)
		return nil
	case task.FieldLocalUserIDMax:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserIDMax(v)
		return nil
	case task.FieldLocalUserIDMin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserIDMin(v)
		return nil
	case task.FieldLocalUserSSHKeyBits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserSSHKeyBits(v)
		return nil
	case task.FieldLocalUserSSHKeyComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserSSHKeyComment(v)
		return nil
	case task.FieldLocalUserSSHKeyFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserSSHKeyFile(v)
		return nil
	case task.FieldLocalUserSSHKeyPassphrase:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserSSHKeyPassphrase(v)
		return nil
	case task.FieldLocalUserSSHKeyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserSSHKeyType(v)
		return nil
	case task.FieldLocalUserUmask:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalUserUmask(v)
		return nil
	case task.FieldLocalGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalGroupID(v)
		return nil
	case task.FieldLocalGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalGroupName(v)
		return nil
	case task.FieldLocalGroupDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalGroupDescription(v)
		return nil
	case task.FieldLocalGroupSystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalGroupSystem(v)
		return nil
	case task.FieldLocalGroupForce:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalGroupForce(v)
		return nil
	case task.FieldLocalGroupMembers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalGroupMembers(v)
		return nil
	case task.FieldLocalGroupMembersToInclude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalGroupMembersToInclude(v)
		return nil
	case task.FieldLocalGroupMembersToExclude:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalGroupMembersToExclude(v)
		return nil
	case task.FieldMsiProductid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsiProductid(v)
		return nil
	case task.FieldMsiPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsiPath(v)
		return nil
	case task.FieldMsiArguments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsiArguments(v)
		return nil
	case task.FieldMsiFileHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsiFileHash(v)
		return nil
	case task.FieldMsiFileHashAlg:
		v, ok := value.(task.MsiFileHashAlg)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsiFileHashAlg(v)
		return nil
	case task.FieldMsiLogPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsiLogPath(v)
		return nil
	case task.FieldScript:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScript(v)
		return nil
	case task.FieldScriptExecutable:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScriptExecutable(v)
		return nil
	case task.FieldScriptCreates:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScriptCreates(v)
		return nil
	case task.FieldScriptRun:
		v, ok := value.(task.ScriptRun)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScriptRun(v)
		return nil
	case task.FieldAgentType:
		v, ok := value.(task.AgentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentType(v)
		return nil
	case task.FieldWhen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhen(v)
		return nil
	case task.FieldBrewUpdate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrewUpdate(v)
		return nil
	case task.FieldBrewUpgradeAll:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrewUpgradeAll(v)
		return nil
	case task.FieldBrewUpgradeOptions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrewUpgradeOptions(v)
		return nil
	case task.FieldBrewInstallOptions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrewInstallOptions(v)
		return nil
	case task.FieldBrewGreedy:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrewGreedy(v)
		return nil
	case task.FieldPackageVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageVersion(v)
		return nil
	case task.FieldAptAllowDowngrade:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAptAllowDowngrade(v)
		return nil
	case task.FieldAptDeb:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAptDeb(v)
		return nil
	case task.FieldAptDpkgOptions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAptDpkgOptions(v)
		return nil
	case task.FieldAptFailOnAutoremove:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAptFailOnAutoremove(v)
		return nil
	case task.FieldAptForce:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAptForce(v)
		return nil
	case task.FieldAptInstallRecommends:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAptInstallRecommends(v)
		return nil
	case task.FieldAptName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAptName(v)
		return nil
	case task.FieldAptOnlyUpgrade:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAptOnlyUpgrade(v)
		return nil
	case task.FieldAptPurge:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAptPurge(v)
		return nil
	case task.FieldAptUpdateCache:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAptUpdateCache(v)
		return nil
	case task.FieldAptUpgradeType:
		v, ok := value.(task.AptUpgradeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAptUpgradeType(v)
		return nil
	case task.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case task.FieldTenant:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenant(v)
		return nil
	case task.FieldNetbirdGroups:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetbirdGroups(v)
		return nil
	case task.FieldNetbirdAllowExtraDNSLabels:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetbirdAllowExtraDNSLabels(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, task.FieldVersion)
	}
	if m.addtenant != nil {
		fields = append(fields, task.FieldTenant)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldVersion:
		return m.AddedVersion()
	case task.FieldTenant:
		return m.AddedTenant()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case task.FieldTenant:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenant(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldPackageID) {
		fields = append(fields, task.FieldPackageID)
	}
	if m.FieldCleared(task.FieldPackageName) {
		fields = append(fields, task.FieldPackageName)
	}
	if m.FieldCleared(task.FieldPackageLatest) {
		fields = append(fields, task.FieldPackageLatest)
	}
	if m.FieldCleared(task.FieldRegistryKey) {
		fields = append(fields, task.FieldRegistryKey)
	}
	if m.FieldCleared(task.FieldRegistryKeyValueName) {
		fields = append(fields, task.FieldRegistryKeyValueName)
	}
	if m.FieldCleared(task.FieldRegistryKeyValueType) {
		fields = append(fields, task.FieldRegistryKeyValueType)
	}
	if m.FieldCleared(task.FieldRegistryKeyValueData) {
		fields = append(fields, task.FieldRegistryKeyValueData)
	}
	if m.FieldCleared(task.FieldRegistryHex) {
		fields = append(fields, task.FieldRegistryHex)
	}
	if m.FieldCleared(task.FieldRegistryForce) {
		fields = append(fields, task.FieldRegistryForce)
	}
	if m.FieldCleared(task.FieldLocalUserUsername) {
		fields = append(fields, task.FieldLocalUserUsername)
	}
	if m.FieldCleared(task.FieldLocalUserDescription) {
		fields = append(fields, task.FieldLocalUserDescription)
	}
	if m.FieldCleared(task.FieldLocalUserDisable) {
		fields = append(fields, task.FieldLocalUserDisable)
	}
	if m.FieldCleared(task.FieldLocalUserFullname) {
		fields = append(fields, task.FieldLocalUserFullname)
	}
	if m.FieldCleared(task.FieldLocalUserPassword) {
		fields = append(fields, task.FieldLocalUserPassword)
	}
	if m.FieldCleared(task.FieldLocalUserPasswordChangeNotAllowed) {
		fields = append(fields, task.FieldLocalUserPasswordChangeNotAllowed)
	}
	if m.FieldCleared(task.FieldLocalUserPasswordChangeRequired) {
		fields = append(fields, task.FieldLocalUserPasswordChangeRequired)
	}
	if m.FieldCleared(task.FieldLocalUserPasswordNeverExpires) {
		fields = append(fields, task.FieldLocalUserPasswordNeverExpires)
	}
	if m.FieldCleared(task.FieldLocalUserAppend) {
		fields = append(fields, task.FieldLocalUserAppend)
	}
	if m.FieldCleared(task.FieldLocalUserCreateHome) {
		fields = append(fields, task.FieldLocalUserCreateHome)
	}
	if m.FieldCleared(task.FieldLocalUserExpires) {
		fields = append(fields, task.FieldLocalUserExpires)
	}
	if m.FieldCleared(task.FieldLocalUserForce) {
		fields = append(fields, task.FieldLocalUserForce)
	}
	if m.FieldCleared(task.FieldLocalUserGenerateSSHKey) {
		fields = append(fields, task.FieldLocalUserGenerateSSHKey)
	}
	if m.FieldCleared(task.FieldLocalUserGroup) {
		fields = append(fields, task.FieldLocalUserGroup)
	}
	if m.FieldCleared(task.FieldLocalUserGroups) {
		fields = append(fields, task.FieldLocalUserGroups)
	}
	if m.FieldCleared(task.FieldLocalUserHome) {
		fields = append(fields, task.FieldLocalUserHome)
	}
	if m.FieldCleared(task.FieldLocalUserMoveHome) {
		fields = append(fields, task.FieldLocalUserMoveHome)
	}
	if m.FieldCleared(task.FieldLocalUserNonunique) {
		fields = append(fields, task.FieldLocalUserNonunique)
	}
	if m.FieldCleared(task.FieldLocalUserPasswordExpireAccountDisable) {
		fields = append(fields, task.FieldLocalUserPasswordExpireAccountDisable)
	}
	if m.FieldCleared(task.FieldLocalUserPasswordExpireMax) {
		fields = append(fields, task.FieldLocalUserPasswordExpireMax)
	}
	if m.FieldCleared(task.FieldLocalUserPasswordExpireMin) {
		fields = append(fields, task.FieldLocalUserPasswordExpireMin)
	}
	if m.FieldCleared(task.FieldLocalUserPasswordExpireWarn) {
		fields = append(fields, task.FieldLocalUserPasswordExpireWarn)
	}
	if m.FieldCleared(task.FieldLocalUserPasswordLock) {
		fields = append(fields, task.FieldLocalUserPasswordLock)
	}
	if m.FieldCleared(task.FieldLocalUserSeuser) {
		fields = append(fields, task.FieldLocalUserSeuser)
	}
	if m.FieldCleared(task.FieldLocalUserShell) {
		fields = append(fields, task.FieldLocalUserShell)
	}
	if m.FieldCleared(task.FieldLocalUserSkeleton) {
		fields = append(fields, task.FieldLocalUserSkeleton)
	}
	if m.FieldCleared(task.FieldLocalUserSystem) {
		fields = append(fields, task.FieldLocalUserSystem)
	}
	if m.FieldCleared(task.FieldLocalUserID) {
		fields = append(fields, task.FieldLocalUserID)
	}
	if m.FieldCleared(task.FieldLocalUserIDMax) {
		fields = append(fields, task.FieldLocalUserIDMax)
	}
	if m.FieldCleared(task.FieldLocalUserIDMin) {
		fields = append(fields, task.FieldLocalUserIDMin)
	}
	if m.FieldCleared(task.FieldLocalUserSSHKeyBits) {
		fields = append(fields, task.FieldLocalUserSSHKeyBits)
	}
	if m.FieldCleared(task.FieldLocalUserSSHKeyComment) {
		fields = append(fields, task.FieldLocalUserSSHKeyComment)
	}
	if m.FieldCleared(task.FieldLocalUserSSHKeyFile) {
		fields = append(fields, task.FieldLocalUserSSHKeyFile)
	}
	if m.FieldCleared(task.FieldLocalUserSSHKeyPassphrase) {
		fields = append(fields, task.FieldLocalUserSSHKeyPassphrase)
	}
	if m.FieldCleared(task.FieldLocalUserSSHKeyType) {
		fields = append(fields, task.FieldLocalUserSSHKeyType)
	}
	if m.FieldCleared(task.FieldLocalUserUmask) {
		fields = append(fields, task.FieldLocalUserUmask)
	}
	if m.FieldCleared(task.FieldLocalGroupID) {
		fields = append(fields, task.FieldLocalGroupID)
	}
	if m.FieldCleared(task.FieldLocalGroupName) {
		fields = append(fields, task.FieldLocalGroupName)
	}
	if m.FieldCleared(task.FieldLocalGroupDescription) {
		fields = append(fields, task.FieldLocalGroupDescription)
	}
	if m.FieldCleared(task.FieldLocalGroupSystem) {
		fields = append(fields, task.FieldLocalGroupSystem)
	}
	if m.FieldCleared(task.FieldLocalGroupForce) {
		fields = append(fields, task.FieldLocalGroupForce)
	}
	if m.FieldCleared(task.FieldLocalGroupMembers) {
		fields = append(fields, task.FieldLocalGroupMembers)
	}
	if m.FieldCleared(task.FieldLocalGroupMembersToInclude) {
		fields = append(fields, task.FieldLocalGroupMembersToInclude)
	}
	if m.FieldCleared(task.FieldLocalGroupMembersToExclude) {
		fields = append(fields, task.FieldLocalGroupMembersToExclude)
	}
	if m.FieldCleared(task.FieldMsiProductid) {
		fields = append(fields, task.FieldMsiProductid)
	}
	if m.FieldCleared(task.FieldMsiPath) {
		fields = append(fields, task.FieldMsiPath)
	}
	if m.FieldCleared(task.FieldMsiArguments) {
		fields = append(fields, task.FieldMsiArguments)
	}
	if m.FieldCleared(task.FieldMsiFileHash) {
		fields = append(fields, task.FieldMsiFileHash)
	}
	if m.FieldCleared(task.FieldMsiFileHashAlg) {
		fields = append(fields, task.FieldMsiFileHashAlg)
	}
	if m.FieldCleared(task.FieldMsiLogPath) {
		fields = append(fields, task.FieldMsiLogPath)
	}
	if m.FieldCleared(task.FieldScript) {
		fields = append(fields, task.FieldScript)
	}
	if m.FieldCleared(task.FieldScriptExecutable) {
		fields = append(fields, task.FieldScriptExecutable)
	}
	if m.FieldCleared(task.FieldScriptCreates) {
		fields = append(fields, task.FieldScriptCreates)
	}
	if m.FieldCleared(task.FieldScriptRun) {
		fields = append(fields, task.FieldScriptRun)
	}
	if m.FieldCleared(task.FieldAgentType) {
		fields = append(fields, task.FieldAgentType)
	}
	if m.FieldCleared(task.FieldWhen) {
		fields = append(fields, task.FieldWhen)
	}
	if m.FieldCleared(task.FieldBrewUpdate) {
		fields = append(fields, task.FieldBrewUpdate)
	}
	if m.FieldCleared(task.FieldBrewUpgradeAll) {
		fields = append(fields, task.FieldBrewUpgradeAll)
	}
	if m.FieldCleared(task.FieldBrewUpgradeOptions) {
		fields = append(fields, task.FieldBrewUpgradeOptions)
	}
	if m.FieldCleared(task.FieldBrewInstallOptions) {
		fields = append(fields, task.FieldBrewInstallOptions)
	}
	if m.FieldCleared(task.FieldBrewGreedy) {
		fields = append(fields, task.FieldBrewGreedy)
	}
	if m.FieldCleared(task.FieldPackageVersion) {
		fields = append(fields, task.FieldPackageVersion)
	}
	if m.FieldCleared(task.FieldAptAllowDowngrade) {
		fields = append(fields, task.FieldAptAllowDowngrade)
	}
	if m.FieldCleared(task.FieldAptDeb) {
		fields = append(fields, task.FieldAptDeb)
	}
	if m.FieldCleared(task.FieldAptDpkgOptions) {
		fields = append(fields, task.FieldAptDpkgOptions)
	}
	if m.FieldCleared(task.FieldAptFailOnAutoremove) {
		fields = append(fields, task.FieldAptFailOnAutoremove)
	}
	if m.FieldCleared(task.FieldAptForce) {
		fields = append(fields, task.FieldAptForce)
	}
	if m.FieldCleared(task.FieldAptInstallRecommends) {
		fields = append(fields, task.FieldAptInstallRecommends)
	}
	if m.FieldCleared(task.FieldAptName) {
		fields = append(fields, task.FieldAptName)
	}
	if m.FieldCleared(task.FieldAptOnlyUpgrade) {
		fields = append(fields, task.FieldAptOnlyUpgrade)
	}
	if m.FieldCleared(task.FieldAptPurge) {
		fields = append(fields, task.FieldAptPurge)
	}
	if m.FieldCleared(task.FieldAptUpdateCache) {
		fields = append(fields, task.FieldAptUpdateCache)
	}
	if m.FieldCleared(task.FieldAptUpgradeType) {
		fields = append(fields, task.FieldAptUpgradeType)
	}
	if m.FieldCleared(task.FieldVersion) {
		fields = append(fields, task.FieldVersion)
	}
	if m.FieldCleared(task.FieldTenant) {
		fields = append(fields, task.FieldTenant)
	}
	if m.FieldCleared(task.FieldNetbirdGroups) {
		fields = append(fields, task.FieldNetbirdGroups)
	}
	if m.FieldCleared(task.FieldNetbirdAllowExtraDNSLabels) {
		fields = append(fields, task.FieldNetbirdAllowExtraDNSLabels)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldPackageID:
		m.ClearPackageID()
		return nil
	case task.FieldPackageName:
		m.ClearPackageName()
		return nil
	case task.FieldPackageLatest:
		m.ClearPackageLatest()
		return nil
	case task.FieldRegistryKey:
		m.ClearRegistryKey()
		return nil
	case task.FieldRegistryKeyValueName:
		m.ClearRegistryKeyValueName()
		return nil
	case task.FieldRegistryKeyValueType:
		m.ClearRegistryKeyValueType()
		return nil
	case task.FieldRegistryKeyValueData:
		m.ClearRegistryKeyValueData()
		return nil
	case task.FieldRegistryHex:
		m.ClearRegistryHex()
		return nil
	case task.FieldRegistryForce:
		m.ClearRegistryForce()
		return nil
	case task.FieldLocalUserUsername:
		m.ClearLocalUserUsername()
		return nil
	case task.FieldLocalUserDescription:
		m.ClearLocalUserDescription()
		return nil
	case task.FieldLocalUserDisable:
		m.ClearLocalUserDisable()
		return nil
	case task.FieldLocalUserFullname:
		m.ClearLocalUserFullname()
		return nil
	case task.FieldLocalUserPassword:
		m.ClearLocalUserPassword()
		return nil
	case task.FieldLocalUserPasswordChangeNotAllowed:
		m.ClearLocalUserPasswordChangeNotAllowed()
		return nil
	case task.FieldLocalUserPasswordChangeRequired:
		m.ClearLocalUserPasswordChangeRequired()
		return nil
	case task.FieldLocalUserPasswordNeverExpires:
		m.ClearLocalUserPasswordNeverExpires()
		return nil
	case task.FieldLocalUserAppend:
		m.ClearLocalUserAppend()
		return nil
	case task.FieldLocalUserCreateHome:
		m.ClearLocalUserCreateHome()
		return nil
	case task.FieldLocalUserExpires:
		m.ClearLocalUserExpires()
		return nil
	case task.FieldLocalUserForce:
		m.ClearLocalUserForce()
		return nil
	case task.FieldLocalUserGenerateSSHKey:
		m.ClearLocalUserGenerateSSHKey()
		return nil
	case task.FieldLocalUserGroup:
		m.ClearLocalUserGroup()
		return nil
	case task.FieldLocalUserGroups:
		m.ClearLocalUserGroups()
		return nil
	case task.FieldLocalUserHome:
		m.ClearLocalUserHome()
		return nil
	case task.FieldLocalUserMoveHome:
		m.ClearLocalUserMoveHome()
		return nil
	case task.FieldLocalUserNonunique:
		m.ClearLocalUserNonunique()
		return nil
	case task.FieldLocalUserPasswordExpireAccountDisable:
		m.ClearLocalUserPasswordExpireAccountDisable()
		return nil
	case task.FieldLocalUserPasswordExpireMax:
		m.ClearLocalUserPasswordExpireMax()
		return nil
	case task.FieldLocalUserPasswordExpireMin:
		m.ClearLocalUserPasswordExpireMin()
		return nil
	case task.FieldLocalUserPasswordExpireWarn:
		m.ClearLocalUserPasswordExpireWarn()
		return nil
	case task.FieldLocalUserPasswordLock:
		m.ClearLocalUserPasswordLock()
		return nil
	case task.FieldLocalUserSeuser:
		m.ClearLocalUserSeuser()
		return nil
	case task.FieldLocalUserShell:
		m.ClearLocalUserShell()
		return nil
	case task.FieldLocalUserSkeleton:
		m.ClearLocalUserSkeleton()
		return nil
	case task.FieldLocalUserSystem:
		m.ClearLocalUserSystem()
		return nil
	case task.FieldLocalUserID:
		m.ClearLocalUserID()
		return nil
	case task.FieldLocalUserIDMax:
		m.ClearLocalUserIDMax()
		return nil
	case task.FieldLocalUserIDMin:
		m.ClearLocalUserIDMin()
		return nil
	case task.FieldLocalUserSSHKeyBits:
		m.ClearLocalUserSSHKeyBits()
		return nil
	case task.FieldLocalUserSSHKeyComment:
		m.ClearLocalUserSSHKeyComment()
		return nil
	case task.FieldLocalUserSSHKeyFile:
		m.ClearLocalUserSSHKeyFile()
		return nil
	case task.FieldLocalUserSSHKeyPassphrase:
		m.ClearLocalUserSSHKeyPassphrase()
		return nil
	case task.FieldLocalUserSSHKeyType:
		m.ClearLocalUserSSHKeyType()
		return nil
	case task.FieldLocalUserUmask:
		m.ClearLocalUserUmask()
		return nil
	case task.FieldLocalGroupID:
		m.ClearLocalGroupID()
		return nil
	case task.FieldLocalGroupName:
		m.ClearLocalGroupName()
		return nil
	case task.FieldLocalGroupDescription:
		m.ClearLocalGroupDescription()
		return nil
	case task.FieldLocalGroupSystem:
		m.ClearLocalGroupSystem()
		return nil
	case task.FieldLocalGroupForce:
		m.ClearLocalGroupForce()
		return nil
	case task.FieldLocalGroupMembers:
		m.ClearLocalGroupMembers()
		return nil
	case task.FieldLocalGroupMembersToInclude:
		m.ClearLocalGroupMembersToInclude()
		return nil
	case task.FieldLocalGroupMembersToExclude:
		m.ClearLocalGroupMembersToExclude()
		return nil
	case task.FieldMsiProductid:
		m.ClearMsiProductid()
		return nil
	case task.FieldMsiPath:
		m.ClearMsiPath()
		return nil
	case task.FieldMsiArguments:
		m.ClearMsiArguments()
		return nil
	case task.FieldMsiFileHash:
		m.ClearMsiFileHash()
		return nil
	case task.FieldMsiFileHashAlg:
		m.ClearMsiFileHashAlg()
		return nil
	case task.FieldMsiLogPath:
		m.ClearMsiLogPath()
		return nil
	case task.FieldScript:
		m.ClearScript()
		return nil
	case task.FieldScriptExecutable:
		m.ClearScriptExecutable()
		return nil
	case task.FieldScriptCreates:
		m.ClearScriptCreates()
		return nil
	case task.FieldScriptRun:
		m.ClearScriptRun()
		return nil
	case task.FieldAgentType:
		m.ClearAgentType()
		return nil
	case task.FieldWhen:
		m.ClearWhen()
		return nil
	case task.FieldBrewUpdate:
		m.ClearBrewUpdate()
		return nil
	case task.FieldBrewUpgradeAll:
		m.ClearBrewUpgradeAll()
		return nil
	case task.FieldBrewUpgradeOptions:
		m.ClearBrewUpgradeOptions()
		return nil
	case task.FieldBrewInstallOptions:
		m.ClearBrewInstallOptions()
		return nil
	case task.FieldBrewGreedy:
		m.ClearBrewGreedy()
		return nil
	case task.FieldPackageVersion:
		m.ClearPackageVersion()
		return nil
	case task.FieldAptAllowDowngrade:
		m.ClearAptAllowDowngrade()
		return nil
	case task.FieldAptDeb:
		m.ClearAptDeb()
		return nil
	case task.FieldAptDpkgOptions:
		m.ClearAptDpkgOptions()
		return nil
	case task.FieldAptFailOnAutoremove:
		m.ClearAptFailOnAutoremove()
		return nil
	case task.FieldAptForce:
		m.ClearAptForce()
		return nil
	case task.FieldAptInstallRecommends:
		m.ClearAptInstallRecommends()
		return nil
	case task.FieldAptName:
		m.ClearAptName()
		return nil
	case task.FieldAptOnlyUpgrade:
		m.ClearAptOnlyUpgrade()
		return nil
	case task.FieldAptPurge:
		m.ClearAptPurge()
		return nil
	case task.FieldAptUpdateCache:
		m.ClearAptUpdateCache()
		return nil
	case task.FieldAptUpgradeType:
		m.ClearAptUpgradeType()
		return nil
	case task.FieldVersion:
		m.ClearVersion()
		return nil
	case task.FieldTenant:
		m.ClearTenant()
		return nil
	case task.FieldNetbirdGroups:
		m.ClearNetbirdGroups()
		return nil
	case task.FieldNetbirdAllowExtraDNSLabels:
		m.ClearNetbirdAllowExtraDNSLabels()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldName:
		m.ResetName()
		return nil
	case task.FieldType:
		m.ResetType()
		return nil
	case task.FieldPackageID:
		m.ResetPackageID()
		return nil
	case task.FieldPackageName:
		m.ResetPackageName()
		return nil
	case task.FieldPackageLatest:
		m.ResetPackageLatest()
		return nil
	case task.FieldRegistryKey:
		m.ResetRegistryKey()
		return nil
	case task.FieldRegistryKeyValueName:
		m.ResetRegistryKeyValueName()
		return nil
	case task.FieldRegistryKeyValueType:
		m.ResetRegistryKeyValueType()
		return nil
	case task.FieldRegistryKeyValueData:
		m.ResetRegistryKeyValueData()
		return nil
	case task.FieldRegistryHex:
		m.ResetRegistryHex()
		return nil
	case task.FieldRegistryForce:
		m.ResetRegistryForce()
		return nil
	case task.FieldLocalUserUsername:
		m.ResetLocalUserUsername()
		return nil
	case task.FieldLocalUserDescription:
		m.ResetLocalUserDescription()
		return nil
	case task.FieldLocalUserDisable:
		m.ResetLocalUserDisable()
		return nil
	case task.FieldLocalUserFullname:
		m.ResetLocalUserFullname()
		return nil
	case task.FieldLocalUserPassword:
		m.ResetLocalUserPassword()
		return nil
	case task.FieldLocalUserPasswordChangeNotAllowed:
		m.ResetLocalUserPasswordChangeNotAllowed()
		return nil
	case task.FieldLocalUserPasswordChangeRequired:
		m.ResetLocalUserPasswordChangeRequired()
		return nil
	case task.FieldLocalUserPasswordNeverExpires:
		m.ResetLocalUserPasswordNeverExpires()
		return nil
	case task.FieldLocalUserAppend:
		m.ResetLocalUserAppend()
		return nil
	case task.FieldLocalUserCreateHome:
		m.ResetLocalUserCreateHome()
		return nil
	case task.FieldLocalUserExpires:
		m.ResetLocalUserExpires()
		return nil
	case task.FieldLocalUserForce:
		m.ResetLocalUserForce()
		return nil
	case task.FieldLocalUserGenerateSSHKey:
		m.ResetLocalUserGenerateSSHKey()
		return nil
	case task.FieldLocalUserGroup:
		m.ResetLocalUserGroup()
		return nil
	case task.FieldLocalUserGroups:
		m.ResetLocalUserGroups()
		return nil
	case task.FieldLocalUserHome:
		m.ResetLocalUserHome()
		return nil
	case task.FieldLocalUserMoveHome:
		m.ResetLocalUserMoveHome()
		return nil
	case task.FieldLocalUserNonunique:
		m.ResetLocalUserNonunique()
		return nil
	case task.FieldLocalUserPasswordExpireAccountDisable:
		m.ResetLocalUserPasswordExpireAccountDisable()
		return nil
	case task.FieldLocalUserPasswordExpireMax:
		m.ResetLocalUserPasswordExpireMax()
		return nil
	case task.FieldLocalUserPasswordExpireMin:
		m.ResetLocalUserPasswordExpireMin()
		return nil
	case task.FieldLocalUserPasswordExpireWarn:
		m.ResetLocalUserPasswordExpireWarn()
		return nil
	case task.FieldLocalUserPasswordLock:
		m.ResetLocalUserPasswordLock()
		return nil
	case task.FieldLocalUserSeuser:
		m.ResetLocalUserSeuser()
		return nil
	case task.FieldLocalUserShell:
		m.ResetLocalUserShell()
		return nil
	case task.FieldLocalUserSkeleton:
		m.ResetLocalUserSkeleton()
		return nil
	case task.FieldLocalUserSystem:
		m.ResetLocalUserSystem()
		return nil
	case task.FieldLocalUserID:
		m.ResetLocalUserID()
		return nil
	case task.FieldLocalUserIDMax:
		m.ResetLocalUserIDMax()
		return nil
	case task.FieldLocalUserIDMin:
		m.ResetLocalUserIDMin()
		return nil
	case task.FieldLocalUserSSHKeyBits:
		m.ResetLocalUserSSHKeyBits()
		return nil
	case task.FieldLocalUserSSHKeyComment:
		m.ResetLocalUserSSHKeyComment()
		return nil
	case task.FieldLocalUserSSHKeyFile:
		m.ResetLocalUserSSHKeyFile()
		return nil
	case task.FieldLocalUserSSHKeyPassphrase:
		m.ResetLocalUserSSHKeyPassphrase()
		return nil
	case task.FieldLocalUserSSHKeyType:
		m.ResetLocalUserSSHKeyType()
		return nil
	case task.FieldLocalUserUmask:
		m.ResetLocalUserUmask()
		return nil
	case task.FieldLocalGroupID:
		m.ResetLocalGroupID()
		return nil
	case task.FieldLocalGroupName:
		m.ResetLocalGroupName()
		return nil
	case task.FieldLocalGroupDescription:
		m.ResetLocalGroupDescription()
		return nil
	case task.FieldLocalGroupSystem:
		m.ResetLocalGroupSystem()
		return nil
	case task.FieldLocalGroupForce:
		m.ResetLocalGroupForce()
		return nil
	case task.FieldLocalGroupMembers:
		m.ResetLocalGroupMembers()
		return nil
	case task.FieldLocalGroupMembersToInclude:
		m.ResetLocalGroupMembersToInclude()
		return nil
	case task.FieldLocalGroupMembersToExclude:
		m.ResetLocalGroupMembersToExclude()
		return nil
	case task.FieldMsiProductid:
		m.ResetMsiProductid()
		return nil
	case task.FieldMsiPath:
		m.ResetMsiPath()
		return nil
	case task.FieldMsiArguments:
		m.ResetMsiArguments()
		return nil
	case task.FieldMsiFileHash:
		m.ResetMsiFileHash()
		return nil
	case task.FieldMsiFileHashAlg:
		m.ResetMsiFileHashAlg()
		return nil
	case task.FieldMsiLogPath:
		m.ResetMsiLogPath()
		return nil
	case task.FieldScript:
		m.ResetScript()
		return nil
	case task.FieldScriptExecutable:
		m.ResetScriptExecutable()
		return nil
	case task.FieldScriptCreates:
		m.ResetScriptCreates()
		return nil
	case task.FieldScriptRun:
		m.ResetScriptRun()
		return nil
	case task.FieldAgentType:
		m.ResetAgentType()
		return nil
	case task.FieldWhen:
		m.ResetWhen()
		return nil
	case task.FieldBrewUpdate:
		m.ResetBrewUpdate()
		return nil
	case task.FieldBrewUpgradeAll:
		m.ResetBrewUpgradeAll()
		return nil
	case task.FieldBrewUpgradeOptions:
		m.ResetBrewUpgradeOptions()
		return nil
	case task.FieldBrewInstallOptions:
		m.ResetBrewInstallOptions()
		return nil
	case task.FieldBrewGreedy:
		m.ResetBrewGreedy()
		return nil
	case task.FieldPackageVersion:
		m.ResetPackageVersion()
		return nil
	case task.FieldAptAllowDowngrade:
		m.ResetAptAllowDowngrade()
		return nil
	case task.FieldAptDeb:
		m.ResetAptDeb()
		return nil
	case task.FieldAptDpkgOptions:
		m.ResetAptDpkgOptions()
		return nil
	case task.FieldAptFailOnAutoremove:
		m.ResetAptFailOnAutoremove()
		return nil
	case task.FieldAptForce:
		m.ResetAptForce()
		return nil
	case task.FieldAptInstallRecommends:
		m.ResetAptInstallRecommends()
		return nil
	case task.FieldAptName:
		m.ResetAptName()
		return nil
	case task.FieldAptOnlyUpgrade:
		m.ResetAptOnlyUpgrade()
		return nil
	case task.FieldAptPurge:
		m.ResetAptPurge()
		return nil
	case task.FieldAptUpdateCache:
		m.ResetAptUpdateCache()
		return nil
	case task.FieldAptUpgradeType:
		m.ResetAptUpgradeType()
		return nil
	case task.FieldVersion:
		m.ResetVersion()
		return nil
	case task.FieldTenant:
		m.ResetTenant()
		return nil
	case task.FieldNetbirdGroups:
		m.ResetNetbirdGroups()
		return nil
	case task.FieldNetbirdAllowExtraDNSLabels:
		m.ResetNetbirdAllowExtraDNSLabels()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tags != nil {
		edges = append(edges, task.EdgeTags)
	}
	if m.profile != nil {
		edges = append(edges, task.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtags != nil {
		edges = append(edges, task.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtags {
		edges = append(edges, task.EdgeTags)
	}
	if m.clearedprofile {
		edges = append(edges, task.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeTags:
		return m.clearedtags
	case task.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeTags:
		m.ResetTags()
		return nil
	case task.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op              Op
	typ             string
	id              *int
	description     *string
	is_default      *bool
	created         *time.Time
	modified        *time.Time
	clearedFields   map[string]struct{}
	sites           map[int]struct{}
	removedsites    map[int]struct{}
	clearedsites    bool
	settings        *int
	clearedsettings bool
	tags            map[int]struct{}
	removedtags     map[int]struct{}
	clearedtags     bool
	metadata        map[int]struct{}
	removedmetadata map[int]struct{}
	clearedmetadata bool
	rustdesk        map[int]struct{}
	removedrustdesk map[int]struct{}
	clearedrustdesk bool
	netbird         *int
	clearednetbird  bool
	done            bool
	oldValue        func(context.Context) (*Tenant, error)
	predicates      []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id int) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *TenantMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TenantMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TenantMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tenant.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TenantMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TenantMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tenant.FieldDescription)
}

// SetIsDefault sets the "is_default" field.
func (m *TenantMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *TenantMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "is_default" field.
func (m *TenantMutation) ClearIsDefault() {
	m.is_default = nil
	m.clearedFields[tenant.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "is_default" field was cleared in this mutation.
func (m *TenantMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[tenant.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *TenantMutation) ResetIsDefault() {
	m.is_default = nil
	delete(m.clearedFields, tenant.FieldIsDefault)
}

// SetCreated sets the "created" field.
func (m *TenantMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *TenantMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ClearCreated clears the value of the "created" field.
func (m *TenantMutation) ClearCreated() {
	m.created = nil
	m.clearedFields[tenant.FieldCreated] = struct{}{}
}

// CreatedCleared returns if the "created" field was cleared in this mutation.
func (m *TenantMutation) CreatedCleared() bool {
	_, ok := m.clearedFields[tenant.FieldCreated]
	return ok
}

// ResetCreated resets all changes to the "created" field.
func (m *TenantMutation) ResetCreated() {
	m.created = nil
	delete(m.clearedFields, tenant.FieldCreated)
}

// SetModified sets the "modified" field.
func (m *TenantMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *TenantMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ClearModified clears the value of the "modified" field.
func (m *TenantMutation) ClearModified() {
	m.modified = nil
	m.clearedFields[tenant.FieldModified] = struct{}{}
}

// ModifiedCleared returns if the "modified" field was cleared in this mutation.
func (m *TenantMutation) ModifiedCleared() bool {
	_, ok := m.clearedFields[tenant.FieldModified]
	return ok
}

// ResetModified resets all changes to the "modified" field.
func (m *TenantMutation) ResetModified() {
	m.modified = nil
	delete(m.clearedFields, tenant.FieldModified)
}

// AddSiteIDs adds the "sites" edge to the Site entity by ids.
func (m *TenantMutation) AddSiteIDs(ids ...int) {
	if m.sites == nil {
		m.sites = make(map[int]struct{})
	}
	for i := range ids {
		m.sites[ids[i]] = struct{}{}
	}
}

// ClearSites clears the "sites" edge to the Site entity.
func (m *TenantMutation) ClearSites() {
	m.clearedsites = true
}

// SitesCleared reports if the "sites" edge to the Site entity was cleared.
func (m *TenantMutation) SitesCleared() bool {
	return m.clearedsites
}

// RemoveSiteIDs removes the "sites" edge to the Site entity by IDs.
func (m *TenantMutation) RemoveSiteIDs(ids ...int) {
	if m.removedsites == nil {
		m.removedsites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sites, ids[i])
		m.removedsites[ids[i]] = struct{}{}
	}
}

// RemovedSites returns the removed IDs of the "sites" edge to the Site entity.
func (m *TenantMutation) RemovedSitesIDs() (ids []int) {
	for id := range m.removedsites {
		ids = append(ids, id)
	}
	return
}

// SitesIDs returns the "sites" edge IDs in the mutation.
func (m *TenantMutation) SitesIDs() (ids []int) {
	for id := range m.sites {
		ids = append(ids, id)
	}
	return
}

// ResetSites resets all changes to the "sites" edge.
func (m *TenantMutation) ResetSites() {
	m.sites = nil
	m.clearedsites = false
	m.removedsites = nil
}

// SetSettingsID sets the "settings" edge to the Settings entity by id.
func (m *TenantMutation) SetSettingsID(id int) {
	m.settings = &id
}

// ClearSettings clears the "settings" edge to the Settings entity.
func (m *TenantMutation) ClearSettings() {
	m.clearedsettings = true
}

// SettingsCleared reports if the "settings" edge to the Settings entity was cleared.
func (m *TenantMutation) SettingsCleared() bool {
	return m.clearedsettings
}

// SettingsID returns the "settings" edge ID in the mutation.
func (m *TenantMutation) SettingsID() (id int, exists bool) {
	if m.settings != nil {
		return *m.settings, true
	}
	return
}

// SettingsIDs returns the "settings" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettingsID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) SettingsIDs() (ids []int) {
	if id := m.settings; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettings resets all changes to the "settings" edge.
func (m *TenantMutation) ResetSettings() {
	m.settings = nil
	m.clearedsettings = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *TenantMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *TenantMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *TenantMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *TenantMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *TenantMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *TenantMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *TenantMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddMetadatumIDs adds the "metadata" edge to the OrgMetadata entity by ids.
func (m *TenantMutation) AddMetadatumIDs(ids ...int) {
	if m.metadata == nil {
		m.metadata = make(map[int]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the OrgMetadata entity.
func (m *TenantMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the OrgMetadata entity was cleared.
func (m *TenantMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the OrgMetadata entity by IDs.
func (m *TenantMutation) RemoveMetadatumIDs(ids ...int) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the OrgMetadata entity.
func (m *TenantMutation) RemovedMetadataIDs() (ids []int) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *TenantMutation) MetadataIDs() (ids []int) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *TenantMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// AddRustdeskIDs adds the "rustdesk" edge to the Rustdesk entity by ids.
func (m *TenantMutation) AddRustdeskIDs(ids ...int) {
	if m.rustdesk == nil {
		m.rustdesk = make(map[int]struct{})
	}
	for i := range ids {
		m.rustdesk[ids[i]] = struct{}{}
	}
}

// ClearRustdesk clears the "rustdesk" edge to the Rustdesk entity.
func (m *TenantMutation) ClearRustdesk() {
	m.clearedrustdesk = true
}

// RustdeskCleared reports if the "rustdesk" edge to the Rustdesk entity was cleared.
func (m *TenantMutation) RustdeskCleared() bool {
	return m.clearedrustdesk
}

// RemoveRustdeskIDs removes the "rustdesk" edge to the Rustdesk entity by IDs.
func (m *TenantMutation) RemoveRustdeskIDs(ids ...int) {
	if m.removedrustdesk == nil {
		m.removedrustdesk = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rustdesk, ids[i])
		m.removedrustdesk[ids[i]] = struct{}{}
	}
}

// RemovedRustdesk returns the removed IDs of the "rustdesk" edge to the Rustdesk entity.
func (m *TenantMutation) RemovedRustdeskIDs() (ids []int) {
	for id := range m.removedrustdesk {
		ids = append(ids, id)
	}
	return
}

// RustdeskIDs returns the "rustdesk" edge IDs in the mutation.
func (m *TenantMutation) RustdeskIDs() (ids []int) {
	for id := range m.rustdesk {
		ids = append(ids, id)
	}
	return
}

// ResetRustdesk resets all changes to the "rustdesk" edge.
func (m *TenantMutation) ResetRustdesk() {
	m.rustdesk = nil
	m.clearedrustdesk = false
	m.removedrustdesk = nil
}

// SetNetbirdID sets the "netbird" edge to the NetbirdSettings entity by id.
func (m *TenantMutation) SetNetbirdID(id int) {
	m.netbird = &id
}

// ClearNetbird clears the "netbird" edge to the NetbirdSettings entity.
func (m *TenantMutation) ClearNetbird() {
	m.clearednetbird = true
}

// NetbirdCleared reports if the "netbird" edge to the NetbirdSettings entity was cleared.
func (m *TenantMutation) NetbirdCleared() bool {
	return m.clearednetbird
}

// NetbirdID returns the "netbird" edge ID in the mutation.
func (m *TenantMutation) NetbirdID() (id int, exists bool) {
	if m.netbird != nil {
		return *m.netbird, true
	}
	return
}

// NetbirdIDs returns the "netbird" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NetbirdID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) NetbirdIDs() (ids []int) {
	if id := m.netbird; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNetbird resets all changes to the "netbird" edge.
func (m *TenantMutation) ResetNetbird() {
	m.netbird = nil
	m.clearednetbird = false
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.description != nil {
		fields = append(fields, tenant.FieldDescription)
	}
	if m.is_default != nil {
		fields = append(fields, tenant.FieldIsDefault)
	}
	if m.created != nil {
		fields = append(fields, tenant.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, tenant.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldDescription:
		return m.Description()
	case tenant.FieldIsDefault:
		return m.IsDefault()
	case tenant.FieldCreated:
		return m.Created()
	case tenant.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldDescription:
		return m.OldDescription(ctx)
	case tenant.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case tenant.FieldCreated:
		return m.OldCreated(ctx)
	case tenant.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tenant.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case tenant.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case tenant.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldDescription) {
		fields = append(fields, tenant.FieldDescription)
	}
	if m.FieldCleared(tenant.FieldIsDefault) {
		fields = append(fields, tenant.FieldIsDefault)
	}
	if m.FieldCleared(tenant.FieldCreated) {
		fields = append(fields, tenant.FieldCreated)
	}
	if m.FieldCleared(tenant.FieldModified) {
		fields = append(fields, tenant.FieldModified)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldDescription:
		m.ClearDescription()
		return nil
	case tenant.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	case tenant.FieldCreated:
		m.ClearCreated()
		return nil
	case tenant.FieldModified:
		m.ClearModified()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldDescription:
		m.ResetDescription()
		return nil
	case tenant.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case tenant.FieldCreated:
		m.ResetCreated()
		return nil
	case tenant.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.sites != nil {
		edges = append(edges, tenant.EdgeSites)
	}
	if m.settings != nil {
		edges = append(edges, tenant.EdgeSettings)
	}
	if m.tags != nil {
		edges = append(edges, tenant.EdgeTags)
	}
	if m.metadata != nil {
		edges = append(edges, tenant.EdgeMetadata)
	}
	if m.rustdesk != nil {
		edges = append(edges, tenant.EdgeRustdesk)
	}
	if m.netbird != nil {
		edges = append(edges, tenant.EdgeNetbird)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeSites:
		ids := make([]ent.Value, 0, len(m.sites))
		for id := range m.sites {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeSettings:
		if id := m.settings; id != nil {
			return []ent.Value{*id}
		}
	case tenant.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRustdesk:
		ids := make([]ent.Value, 0, len(m.rustdesk))
		for id := range m.rustdesk {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeNetbird:
		if id := m.netbird; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedsites != nil {
		edges = append(edges, tenant.EdgeSites)
	}
	if m.removedtags != nil {
		edges = append(edges, tenant.EdgeTags)
	}
	if m.removedmetadata != nil {
		edges = append(edges, tenant.EdgeMetadata)
	}
	if m.removedrustdesk != nil {
		edges = append(edges, tenant.EdgeRustdesk)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeSites:
		ids := make([]ent.Value, 0, len(m.removedsites))
		for id := range m.removedsites {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeRustdesk:
		ids := make([]ent.Value, 0, len(m.removedrustdesk))
		for id := range m.removedrustdesk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedsites {
		edges = append(edges, tenant.EdgeSites)
	}
	if m.clearedsettings {
		edges = append(edges, tenant.EdgeSettings)
	}
	if m.clearedtags {
		edges = append(edges, tenant.EdgeTags)
	}
	if m.clearedmetadata {
		edges = append(edges, tenant.EdgeMetadata)
	}
	if m.clearedrustdesk {
		edges = append(edges, tenant.EdgeRustdesk)
	}
	if m.clearednetbird {
		edges = append(edges, tenant.EdgeNetbird)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	switch name {
	case tenant.EdgeSites:
		return m.clearedsites
	case tenant.EdgeSettings:
		return m.clearedsettings
	case tenant.EdgeTags:
		return m.clearedtags
	case tenant.EdgeMetadata:
		return m.clearedmetadata
	case tenant.EdgeRustdesk:
		return m.clearedrustdesk
	case tenant.EdgeNetbird:
		return m.clearednetbird
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	switch name {
	case tenant.EdgeSettings:
		m.ClearSettings()
		return nil
	case tenant.EdgeNetbird:
		m.ClearNetbird()
		return nil
	}
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	switch name {
	case tenant.EdgeSites:
		m.ResetSites()
		return nil
	case tenant.EdgeSettings:
		m.ResetSettings()
		return nil
	case tenant.EdgeTags:
		m.ResetTags()
		return nil
	case tenant.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case tenant.EdgeRustdesk:
		m.ResetRustdesk()
		return nil
	case tenant.EdgeNetbird:
		m.ResetNetbird()
		return nil
	}
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// UpdateMutation represents an operation that mutates the Update nodes in the graph.
type UpdateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	date          *time.Time
	support_url   *string
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Update, error)
	predicates    []predicate.Update
}

var _ ent.Mutation = (*UpdateMutation)(nil)

// updateOption allows management of the mutation configuration using functional options.
type updateOption func(*UpdateMutation)

// newUpdateMutation creates new mutation for the Update entity.
func newUpdateMutation(c config, op Op, opts ...updateOption) *UpdateMutation {
	m := &UpdateMutation{
		config:        c,
		op:            op,
		typ:           TypeUpdate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpdateID sets the ID field of the mutation.
func withUpdateID(id int) updateOption {
	return func(m *UpdateMutation) {
		var (
			err   error
			once  sync.Once
			value *Update
		)
		m.oldValue = func(ctx context.Context) (*Update, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Update.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpdate sets the old Update of the mutation.
func withUpdate(node *Update) updateOption {
	return func(m *UpdateMutation) {
		m.oldValue = func(context.Context) (*Update, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpdateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpdateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpdateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpdateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Update.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *UpdateMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *UpdateMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Update entity.
// If the Update object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpdateMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *UpdateMutation) ResetTitle() {
	m.title = nil
}

// SetDate sets the "date" field.
func (m *UpdateMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *UpdateMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Update entity.
// If the Update object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpdateMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *UpdateMutation) ResetDate() {
	m.date = nil
}

// SetSupportURL sets the "support_url" field.
func (m *UpdateMutation) SetSupportURL(s string) {
	m.support_url = &s
}

// SupportURL returns the value of the "support_url" field in the mutation.
func (m *UpdateMutation) SupportURL() (r string, exists bool) {
	v := m.support_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportURL returns the old "support_url" field's value of the Update entity.
// If the Update object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpdateMutation) OldSupportURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportURL: %w", err)
	}
	return oldValue.SupportURL, nil
}

// ClearSupportURL clears the value of the "support_url" field.
func (m *UpdateMutation) ClearSupportURL() {
	m.support_url = nil
	m.clearedFields[update.FieldSupportURL] = struct{}{}
}

// SupportURLCleared returns if the "support_url" field was cleared in this mutation.
func (m *UpdateMutation) SupportURLCleared() bool {
	_, ok := m.clearedFields[update.FieldSupportURL]
	return ok
}

// ResetSupportURL resets all changes to the "support_url" field.
func (m *UpdateMutation) ResetSupportURL() {
	m.support_url = nil
	delete(m.clearedFields, update.FieldSupportURL)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *UpdateMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *UpdateMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *UpdateMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *UpdateMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *UpdateMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *UpdateMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the UpdateMutation builder.
func (m *UpdateMutation) Where(ps ...predicate.Update) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpdateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpdateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Update, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpdateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpdateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Update).
func (m *UpdateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpdateMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.title != nil {
		fields = append(fields, update.FieldTitle)
	}
	if m.date != nil {
		fields = append(fields, update.FieldDate)
	}
	if m.support_url != nil {
		fields = append(fields, update.FieldSupportURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpdateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case update.FieldTitle:
		return m.Title()
	case update.FieldDate:
		return m.Date()
	case update.FieldSupportURL:
		return m.SupportURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpdateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case update.FieldTitle:
		return m.OldTitle(ctx)
	case update.FieldDate:
		return m.OldDate(ctx)
	case update.FieldSupportURL:
		return m.OldSupportURL(ctx)
	}
	return nil, fmt.Errorf("unknown Update field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpdateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case update.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case update.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case update.FieldSupportURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportURL(v)
		return nil
	}
	return fmt.Errorf("unknown Update field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpdateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpdateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpdateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Update numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpdateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(update.FieldSupportURL) {
		fields = append(fields, update.FieldSupportURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpdateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpdateMutation) ClearField(name string) error {
	switch name {
	case update.FieldSupportURL:
		m.ClearSupportURL()
		return nil
	}
	return fmt.Errorf("unknown Update nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpdateMutation) ResetField(name string) error {
	switch name {
	case update.FieldTitle:
		m.ResetTitle()
		return nil
	case update.FieldDate:
		m.ResetDate()
		return nil
	case update.FieldSupportURL:
		m.ResetSupportURL()
		return nil
	}
	return fmt.Errorf("unknown Update field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpdateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, update.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpdateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case update.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpdateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpdateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpdateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, update.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpdateMutation) EdgeCleared(name string) bool {
	switch name {
	case update.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpdateMutation) ClearEdge(name string) error {
	switch name {
	case update.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Update unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpdateMutation) ResetEdge(name string) error {
	switch name {
	case update.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Update edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                              Op
	typ                             string
	id                              *string
	name                            *string
	email                           *string
	phone                           *string
	country                         *string
	email_verified                  *bool
	register                        *string
	cert_clear_password             *string
	expiry                          *time.Time
	openid                          *bool
	passwd                          *bool
	use2fa                          *bool
	created                         *time.Time
	modified                        *time.Time
	access_token                    *string
	refresh_token                   *string
	id_token                        *string
	token_type                      *string
	token_expiry                    *int
	addtoken_expiry                 *int
	hash                            *string
	totp_secret                     *string
	totp_secret_confirmed           *bool
	forgot_password_code            *string
	forgot_password_code_expires_at *time.Time
	new_user_token                  *string
	clearedFields                   map[string]struct{}
	sessions                        map[string]struct{}
	removedsessions                 map[string]struct{}
	clearedsessions                 bool
	recoverycodes                   map[int]struct{}
	removedrecoverycodes            map[int]struct{}
	clearedrecoverycodes            bool
	done                            bool
	oldValue                        func(context.Context) (*User, error)
	predicates                      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetCountry sets the "country" field.
func (m *UserMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *UserMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *UserMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[user.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *UserMutation) CountryCleared() bool {
	_, ok := m.clearedFields[user.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *UserMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, user.FieldCountry)
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetRegister sets the "register" field.
func (m *UserMutation) SetRegister(s string) {
	m.register = &s
}

// Register returns the value of the "register" field in the mutation.
func (m *UserMutation) Register() (r string, exists bool) {
	v := m.register
	if v == nil {
		return
	}
	return *v, true
}

// OldRegister returns the old "register" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRegister(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegister is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegister requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegister: %w", err)
	}
	return oldValue.Register, nil
}

// ResetRegister resets all changes to the "register" field.
func (m *UserMutation) ResetRegister() {
	m.register = nil
}

// SetCertClearPassword sets the "cert_clear_password" field.
func (m *UserMutation) SetCertClearPassword(s string) {
	m.cert_clear_password = &s
}

// CertClearPassword returns the value of the "cert_clear_password" field in the mutation.
func (m *UserMutation) CertClearPassword() (r string, exists bool) {
	v := m.cert_clear_password
	if v == nil {
		return
	}
	return *v, true
}

// OldCertClearPassword returns the old "cert_clear_password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCertClearPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertClearPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertClearPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertClearPassword: %w", err)
	}
	return oldValue.CertClearPassword, nil
}

// ClearCertClearPassword clears the value of the "cert_clear_password" field.
func (m *UserMutation) ClearCertClearPassword() {
	m.cert_clear_password = nil
	m.clearedFields[user.FieldCertClearPassword] = struct{}{}
}

// CertClearPasswordCleared returns if the "cert_clear_password" field was cleared in this mutation.
func (m *UserMutation) CertClearPasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldCertClearPassword]
	return ok
}

// ResetCertClearPassword resets all changes to the "cert_clear_password" field.
func (m *UserMutation) ResetCertClearPassword() {
	m.cert_clear_password = nil
	delete(m.clearedFields, user.FieldCertClearPassword)
}

// SetExpiry sets the "expiry" field.
func (m *UserMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *UserMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ClearExpiry clears the value of the "expiry" field.
func (m *UserMutation) ClearExpiry() {
	m.expiry = nil
	m.clearedFields[user.FieldExpiry] = struct{}{}
}

// ExpiryCleared returns if the "expiry" field was cleared in this mutation.
func (m *UserMutation) ExpiryCleared() bool {
	_, ok := m.clearedFields[user.FieldExpiry]
	return ok
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *UserMutation) ResetExpiry() {
	m.expiry = nil
	delete(m.clearedFields, user.FieldExpiry)
}

// SetOpenid sets the "openid" field.
func (m *UserMutation) SetOpenid(b bool) {
	m.openid = &b
}

// Openid returns the value of the "openid" field in the mutation.
func (m *UserMutation) Openid() (r bool, exists bool) {
	v := m.openid
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenid returns the old "openid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOpenid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenid: %w", err)
	}
	return oldValue.Openid, nil
}

// ClearOpenid clears the value of the "openid" field.
func (m *UserMutation) ClearOpenid() {
	m.openid = nil
	m.clearedFields[user.FieldOpenid] = struct{}{}
}

// OpenidCleared returns if the "openid" field was cleared in this mutation.
func (m *UserMutation) OpenidCleared() bool {
	_, ok := m.clearedFields[user.FieldOpenid]
	return ok
}

// ResetOpenid resets all changes to the "openid" field.
func (m *UserMutation) ResetOpenid() {
	m.openid = nil
	delete(m.clearedFields, user.FieldOpenid)
}

// SetPasswd sets the "passwd" field.
func (m *UserMutation) SetPasswd(b bool) {
	m.passwd = &b
}

// Passwd returns the value of the "passwd" field in the mutation.
func (m *UserMutation) Passwd() (r bool, exists bool) {
	v := m.passwd
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswd returns the old "passwd" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswd(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswd: %w", err)
	}
	return oldValue.Passwd, nil
}

// ClearPasswd clears the value of the "passwd" field.
func (m *UserMutation) ClearPasswd() {
	m.passwd = nil
	m.clearedFields[user.FieldPasswd] = struct{}{}
}

// PasswdCleared returns if the "passwd" field was cleared in this mutation.
func (m *UserMutation) PasswdCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswd]
	return ok
}

// ResetPasswd resets all changes to the "passwd" field.
func (m *UserMutation) ResetPasswd() {
	m.passwd = nil
	delete(m.clearedFields, user.FieldPasswd)
}

// SetUse2fa sets the "use2fa" field.
func (m *UserMutation) SetUse2fa(b bool) {
	m.use2fa = &b
}

// Use2fa returns the value of the "use2fa" field in the mutation.
func (m *UserMutation) Use2fa() (r bool, exists bool) {
	v := m.use2fa
	if v == nil {
		return
	}
	return *v, true
}

// OldUse2fa returns the old "use2fa" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUse2fa(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUse2fa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUse2fa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUse2fa: %w", err)
	}
	return oldValue.Use2fa, nil
}

// ClearUse2fa clears the value of the "use2fa" field.
func (m *UserMutation) ClearUse2fa() {
	m.use2fa = nil
	m.clearedFields[user.FieldUse2fa] = struct{}{}
}

// Use2faCleared returns if the "use2fa" field was cleared in this mutation.
func (m *UserMutation) Use2faCleared() bool {
	_, ok := m.clearedFields[user.FieldUse2fa]
	return ok
}

// ResetUse2fa resets all changes to the "use2fa" field.
func (m *UserMutation) ResetUse2fa() {
	m.use2fa = nil
	delete(m.clearedFields, user.FieldUse2fa)
}

// SetCreated sets the "created" field.
func (m *UserMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *UserMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ClearCreated clears the value of the "created" field.
func (m *UserMutation) ClearCreated() {
	m.created = nil
	m.clearedFields[user.FieldCreated] = struct{}{}
}

// CreatedCleared returns if the "created" field was cleared in this mutation.
func (m *UserMutation) CreatedCleared() bool {
	_, ok := m.clearedFields[user.FieldCreated]
	return ok
}

// ResetCreated resets all changes to the "created" field.
func (m *UserMutation) ResetCreated() {
	m.created = nil
	delete(m.clearedFields, user.FieldCreated)
}

// SetModified sets the "modified" field.
func (m *UserMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *UserMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ClearModified clears the value of the "modified" field.
func (m *UserMutation) ClearModified() {
	m.modified = nil
	m.clearedFields[user.FieldModified] = struct{}{}
}

// ModifiedCleared returns if the "modified" field was cleared in this mutation.
func (m *UserMutation) ModifiedCleared() bool {
	_, ok := m.clearedFields[user.FieldModified]
	return ok
}

// ResetModified resets all changes to the "modified" field.
func (m *UserMutation) ResetModified() {
	m.modified = nil
	delete(m.clearedFields, user.FieldModified)
}

// SetAccessToken sets the "access_token" field.
func (m *UserMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *UserMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ClearAccessToken clears the value of the "access_token" field.
func (m *UserMutation) ClearAccessToken() {
	m.access_token = nil
	m.clearedFields[user.FieldAccessToken] = struct{}{}
}

// AccessTokenCleared returns if the "access_token" field was cleared in this mutation.
func (m *UserMutation) AccessTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldAccessToken]
	return ok
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *UserMutation) ResetAccessToken() {
	m.access_token = nil
	delete(m.clearedFields, user.FieldAccessToken)
}

// SetRefreshToken sets the "refresh_token" field.
func (m *UserMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *UserMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "refresh_token" field.
func (m *UserMutation) ClearRefreshToken() {
	m.refresh_token = nil
	m.clearedFields[user.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "refresh_token" field was cleared in this mutation.
func (m *UserMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *UserMutation) ResetRefreshToken() {
	m.refresh_token = nil
	delete(m.clearedFields, user.FieldRefreshToken)
}

// SetIDToken sets the "id_token" field.
func (m *UserMutation) SetIDToken(s string) {
	m.id_token = &s
}

// IDToken returns the value of the "id_token" field in the mutation.
func (m *UserMutation) IDToken() (r string, exists bool) {
	v := m.id_token
	if v == nil {
		return
	}
	return *v, true
}

// OldIDToken returns the old "id_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIDToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDToken: %w", err)
	}
	return oldValue.IDToken, nil
}

// ClearIDToken clears the value of the "id_token" field.
func (m *UserMutation) ClearIDToken() {
	m.id_token = nil
	m.clearedFields[user.FieldIDToken] = struct{}{}
}

// IDTokenCleared returns if the "id_token" field was cleared in this mutation.
func (m *UserMutation) IDTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldIDToken]
	return ok
}

// ResetIDToken resets all changes to the "id_token" field.
func (m *UserMutation) ResetIDToken() {
	m.id_token = nil
	delete(m.clearedFields, user.FieldIDToken)
}

// SetTokenType sets the "token_type" field.
func (m *UserMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *UserMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ClearTokenType clears the value of the "token_type" field.
func (m *UserMutation) ClearTokenType() {
	m.token_type = nil
	m.clearedFields[user.FieldTokenType] = struct{}{}
}

// TokenTypeCleared returns if the "token_type" field was cleared in this mutation.
func (m *UserMutation) TokenTypeCleared() bool {
	_, ok := m.clearedFields[user.FieldTokenType]
	return ok
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *UserMutation) ResetTokenType() {
	m.token_type = nil
	delete(m.clearedFields, user.FieldTokenType)
}

// SetTokenExpiry sets the "token_expiry" field.
func (m *UserMutation) SetTokenExpiry(i int) {
	m.token_expiry = &i
	m.addtoken_expiry = nil
}

// TokenExpiry returns the value of the "token_expiry" field in the mutation.
func (m *UserMutation) TokenExpiry() (r int, exists bool) {
	v := m.token_expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenExpiry returns the old "token_expiry" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTokenExpiry(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenExpiry: %w", err)
	}
	return oldValue.TokenExpiry, nil
}

// AddTokenExpiry adds i to the "token_expiry" field.
func (m *UserMutation) AddTokenExpiry(i int) {
	if m.addtoken_expiry != nil {
		*m.addtoken_expiry += i
	} else {
		m.addtoken_expiry = &i
	}
}

// AddedTokenExpiry returns the value that was added to the "token_expiry" field in this mutation.
func (m *UserMutation) AddedTokenExpiry() (r int, exists bool) {
	v := m.addtoken_expiry
	if v == nil {
		return
	}
	return *v, true
}

// ClearTokenExpiry clears the value of the "token_expiry" field.
func (m *UserMutation) ClearTokenExpiry() {
	m.token_expiry = nil
	m.addtoken_expiry = nil
	m.clearedFields[user.FieldTokenExpiry] = struct{}{}
}

// TokenExpiryCleared returns if the "token_expiry" field was cleared in this mutation.
func (m *UserMutation) TokenExpiryCleared() bool {
	_, ok := m.clearedFields[user.FieldTokenExpiry]
	return ok
}

// ResetTokenExpiry resets all changes to the "token_expiry" field.
func (m *UserMutation) ResetTokenExpiry() {
	m.token_expiry = nil
	m.addtoken_expiry = nil
	delete(m.clearedFields, user.FieldTokenExpiry)
}

// SetHash sets the "hash" field.
func (m *UserMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *UserMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ClearHash clears the value of the "hash" field.
func (m *UserMutation) ClearHash() {
	m.hash = nil
	m.clearedFields[user.FieldHash] = struct{}{}
}

// HashCleared returns if the "hash" field was cleared in this mutation.
func (m *UserMutation) HashCleared() bool {
	_, ok := m.clearedFields[user.FieldHash]
	return ok
}

// ResetHash resets all changes to the "hash" field.
func (m *UserMutation) ResetHash() {
	m.hash = nil
	delete(m.clearedFields, user.FieldHash)
}

// SetTotpSecret sets the "totp_secret" field.
func (m *UserMutation) SetTotpSecret(s string) {
	m.totp_secret = &s
}

// TotpSecret returns the value of the "totp_secret" field in the mutation.
func (m *UserMutation) TotpSecret() (r string, exists bool) {
	v := m.totp_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpSecret returns the old "totp_secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpSecret: %w", err)
	}
	return oldValue.TotpSecret, nil
}

// ClearTotpSecret clears the value of the "totp_secret" field.
func (m *UserMutation) ClearTotpSecret() {
	m.totp_secret = nil
	m.clearedFields[user.FieldTotpSecret] = struct{}{}
}

// TotpSecretCleared returns if the "totp_secret" field was cleared in this mutation.
func (m *UserMutation) TotpSecretCleared() bool {
	_, ok := m.clearedFields[user.FieldTotpSecret]
	return ok
}

// ResetTotpSecret resets all changes to the "totp_secret" field.
func (m *UserMutation) ResetTotpSecret() {
	m.totp_secret = nil
	delete(m.clearedFields, user.FieldTotpSecret)
}

// SetTotpSecretConfirmed sets the "totp_secret_confirmed" field.
func (m *UserMutation) SetTotpSecretConfirmed(b bool) {
	m.totp_secret_confirmed = &b
}

// TotpSecretConfirmed returns the value of the "totp_secret_confirmed" field in the mutation.
func (m *UserMutation) TotpSecretConfirmed() (r bool, exists bool) {
	v := m.totp_secret_confirmed
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpSecretConfirmed returns the old "totp_secret_confirmed" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpSecretConfirmed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpSecretConfirmed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpSecretConfirmed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpSecretConfirmed: %w", err)
	}
	return oldValue.TotpSecretConfirmed, nil
}

// ClearTotpSecretConfirmed clears the value of the "totp_secret_confirmed" field.
func (m *UserMutation) ClearTotpSecretConfirmed() {
	m.totp_secret_confirmed = nil
	m.clearedFields[user.FieldTotpSecretConfirmed] = struct{}{}
}

// TotpSecretConfirmedCleared returns if the "totp_secret_confirmed" field was cleared in this mutation.
func (m *UserMutation) TotpSecretConfirmedCleared() bool {
	_, ok := m.clearedFields[user.FieldTotpSecretConfirmed]
	return ok
}

// ResetTotpSecretConfirmed resets all changes to the "totp_secret_confirmed" field.
func (m *UserMutation) ResetTotpSecretConfirmed() {
	m.totp_secret_confirmed = nil
	delete(m.clearedFields, user.FieldTotpSecretConfirmed)
}

// SetForgotPasswordCode sets the "forgot_password_code" field.
func (m *UserMutation) SetForgotPasswordCode(s string) {
	m.forgot_password_code = &s
}

// ForgotPasswordCode returns the value of the "forgot_password_code" field in the mutation.
func (m *UserMutation) ForgotPasswordCode() (r string, exists bool) {
	v := m.forgot_password_code
	if v == nil {
		return
	}
	return *v, true
}

// OldForgotPasswordCode returns the old "forgot_password_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldForgotPasswordCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForgotPasswordCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForgotPasswordCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForgotPasswordCode: %w", err)
	}
	return oldValue.ForgotPasswordCode, nil
}

// ClearForgotPasswordCode clears the value of the "forgot_password_code" field.
func (m *UserMutation) ClearForgotPasswordCode() {
	m.forgot_password_code = nil
	m.clearedFields[user.FieldForgotPasswordCode] = struct{}{}
}

// ForgotPasswordCodeCleared returns if the "forgot_password_code" field was cleared in this mutation.
func (m *UserMutation) ForgotPasswordCodeCleared() bool {
	_, ok := m.clearedFields[user.FieldForgotPasswordCode]
	return ok
}

// ResetForgotPasswordCode resets all changes to the "forgot_password_code" field.
func (m *UserMutation) ResetForgotPasswordCode() {
	m.forgot_password_code = nil
	delete(m.clearedFields, user.FieldForgotPasswordCode)
}

// SetForgotPasswordCodeExpiresAt sets the "forgot_password_code_expires_at" field.
func (m *UserMutation) SetForgotPasswordCodeExpiresAt(t time.Time) {
	m.forgot_password_code_expires_at = &t
}

// ForgotPasswordCodeExpiresAt returns the value of the "forgot_password_code_expires_at" field in the mutation.
func (m *UserMutation) ForgotPasswordCodeExpiresAt() (r time.Time, exists bool) {
	v := m.forgot_password_code_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldForgotPasswordCodeExpiresAt returns the old "forgot_password_code_expires_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldForgotPasswordCodeExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForgotPasswordCodeExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForgotPasswordCodeExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForgotPasswordCodeExpiresAt: %w", err)
	}
	return oldValue.ForgotPasswordCodeExpiresAt, nil
}

// ClearForgotPasswordCodeExpiresAt clears the value of the "forgot_password_code_expires_at" field.
func (m *UserMutation) ClearForgotPasswordCodeExpiresAt() {
	m.forgot_password_code_expires_at = nil
	m.clearedFields[user.FieldForgotPasswordCodeExpiresAt] = struct{}{}
}

// ForgotPasswordCodeExpiresAtCleared returns if the "forgot_password_code_expires_at" field was cleared in this mutation.
func (m *UserMutation) ForgotPasswordCodeExpiresAtCleared() bool {
	_, ok := m.clearedFields[user.FieldForgotPasswordCodeExpiresAt]
	return ok
}

// ResetForgotPasswordCodeExpiresAt resets all changes to the "forgot_password_code_expires_at" field.
func (m *UserMutation) ResetForgotPasswordCodeExpiresAt() {
	m.forgot_password_code_expires_at = nil
	delete(m.clearedFields, user.FieldForgotPasswordCodeExpiresAt)
}

// SetNewUserToken sets the "new_user_token" field.
func (m *UserMutation) SetNewUserToken(s string) {
	m.new_user_token = &s
}

// NewUserToken returns the value of the "new_user_token" field in the mutation.
func (m *UserMutation) NewUserToken() (r string, exists bool) {
	v := m.new_user_token
	if v == nil {
		return
	}
	return *v, true
}

// OldNewUserToken returns the old "new_user_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNewUserToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewUserToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewUserToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewUserToken: %w", err)
	}
	return oldValue.NewUserToken, nil
}

// ClearNewUserToken clears the value of the "new_user_token" field.
func (m *UserMutation) ClearNewUserToken() {
	m.new_user_token = nil
	m.clearedFields[user.FieldNewUserToken] = struct{}{}
}

// NewUserTokenCleared returns if the "new_user_token" field was cleared in this mutation.
func (m *UserMutation) NewUserTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldNewUserToken]
	return ok
}

// ResetNewUserToken resets all changes to the "new_user_token" field.
func (m *UserMutation) ResetNewUserToken() {
	m.new_user_token = nil
	delete(m.clearedFields, user.FieldNewUserToken)
}

// AddSessionIDs adds the "sessions" edge to the Sessions entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...string) {
	if m.sessions == nil {
		m.sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Sessions entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Sessions entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Sessions entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...string) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Sessions entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []string) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []string) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddRecoverycodeIDs adds the "recoverycodes" edge to the RecoveryCode entity by ids.
func (m *UserMutation) AddRecoverycodeIDs(ids ...int) {
	if m.recoverycodes == nil {
		m.recoverycodes = make(map[int]struct{})
	}
	for i := range ids {
		m.recoverycodes[ids[i]] = struct{}{}
	}
}

// ClearRecoverycodes clears the "recoverycodes" edge to the RecoveryCode entity.
func (m *UserMutation) ClearRecoverycodes() {
	m.clearedrecoverycodes = true
}

// RecoverycodesCleared reports if the "recoverycodes" edge to the RecoveryCode entity was cleared.
func (m *UserMutation) RecoverycodesCleared() bool {
	return m.clearedrecoverycodes
}

// RemoveRecoverycodeIDs removes the "recoverycodes" edge to the RecoveryCode entity by IDs.
func (m *UserMutation) RemoveRecoverycodeIDs(ids ...int) {
	if m.removedrecoverycodes == nil {
		m.removedrecoverycodes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recoverycodes, ids[i])
		m.removedrecoverycodes[ids[i]] = struct{}{}
	}
}

// RemovedRecoverycodes returns the removed IDs of the "recoverycodes" edge to the RecoveryCode entity.
func (m *UserMutation) RemovedRecoverycodesIDs() (ids []int) {
	for id := range m.removedrecoverycodes {
		ids = append(ids, id)
	}
	return
}

// RecoverycodesIDs returns the "recoverycodes" edge IDs in the mutation.
func (m *UserMutation) RecoverycodesIDs() (ids []int) {
	for id := range m.recoverycodes {
		ids = append(ids, id)
	}
	return
}

// ResetRecoverycodes resets all changes to the "recoverycodes" edge.
func (m *UserMutation) ResetRecoverycodes() {
	m.recoverycodes = nil
	m.clearedrecoverycodes = false
	m.removedrecoverycodes = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.country != nil {
		fields = append(fields, user.FieldCountry)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.register != nil {
		fields = append(fields, user.FieldRegister)
	}
	if m.cert_clear_password != nil {
		fields = append(fields, user.FieldCertClearPassword)
	}
	if m.expiry != nil {
		fields = append(fields, user.FieldExpiry)
	}
	if m.openid != nil {
		fields = append(fields, user.FieldOpenid)
	}
	if m.passwd != nil {
		fields = append(fields, user.FieldPasswd)
	}
	if m.use2fa != nil {
		fields = append(fields, user.FieldUse2fa)
	}
	if m.created != nil {
		fields = append(fields, user.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, user.FieldModified)
	}
	if m.access_token != nil {
		fields = append(fields, user.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, user.FieldRefreshToken)
	}
	if m.id_token != nil {
		fields = append(fields, user.FieldIDToken)
	}
	if m.token_type != nil {
		fields = append(fields, user.FieldTokenType)
	}
	if m.token_expiry != nil {
		fields = append(fields, user.FieldTokenExpiry)
	}
	if m.hash != nil {
		fields = append(fields, user.FieldHash)
	}
	if m.totp_secret != nil {
		fields = append(fields, user.FieldTotpSecret)
	}
	if m.totp_secret_confirmed != nil {
		fields = append(fields, user.FieldTotpSecretConfirmed)
	}
	if m.forgot_password_code != nil {
		fields = append(fields, user.FieldForgotPasswordCode)
	}
	if m.forgot_password_code_expires_at != nil {
		fields = append(fields, user.FieldForgotPasswordCodeExpiresAt)
	}
	if m.new_user_token != nil {
		fields = append(fields, user.FieldNewUserToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldCountry:
		return m.Country()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldRegister:
		return m.Register()
	case user.FieldCertClearPassword:
		return m.CertClearPassword()
	case user.FieldExpiry:
		return m.Expiry()
	case user.FieldOpenid:
		return m.Openid()
	case user.FieldPasswd:
		return m.Passwd()
	case user.FieldUse2fa:
		return m.Use2fa()
	case user.FieldCreated:
		return m.Created()
	case user.FieldModified:
		return m.Modified()
	case user.FieldAccessToken:
		return m.AccessToken()
	case user.FieldRefreshToken:
		return m.RefreshToken()
	case user.FieldIDToken:
		return m.IDToken()
	case user.FieldTokenType:
		return m.TokenType()
	case user.FieldTokenExpiry:
		return m.TokenExpiry()
	case user.FieldHash:
		return m.Hash()
	case user.FieldTotpSecret:
		return m.TotpSecret()
	case user.FieldTotpSecretConfirmed:
		return m.TotpSecretConfirmed()
	case user.FieldForgotPasswordCode:
		return m.ForgotPasswordCode()
	case user.FieldForgotPasswordCodeExpiresAt:
		return m.ForgotPasswordCodeExpiresAt()
	case user.FieldNewUserToken:
		return m.NewUserToken()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldCountry:
		return m.OldCountry(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldRegister:
		return m.OldRegister(ctx)
	case user.FieldCertClearPassword:
		return m.OldCertClearPassword(ctx)
	case user.FieldExpiry:
		return m.OldExpiry(ctx)
	case user.FieldOpenid:
		return m.OldOpenid(ctx)
	case user.FieldPasswd:
		return m.OldPasswd(ctx)
	case user.FieldUse2fa:
		return m.OldUse2fa(ctx)
	case user.FieldCreated:
		return m.OldCreated(ctx)
	case user.FieldModified:
		return m.OldModified(ctx)
	case user.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case user.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case user.FieldIDToken:
		return m.OldIDToken(ctx)
	case user.FieldTokenType:
		return m.OldTokenType(ctx)
	case user.FieldTokenExpiry:
		return m.OldTokenExpiry(ctx)
	case user.FieldHash:
		return m.OldHash(ctx)
	case user.FieldTotpSecret:
		return m.OldTotpSecret(ctx)
	case user.FieldTotpSecretConfirmed:
		return m.OldTotpSecretConfirmed(ctx)
	case user.FieldForgotPasswordCode:
		return m.OldForgotPasswordCode(ctx)
	case user.FieldForgotPasswordCodeExpiresAt:
		return m.OldForgotPasswordCodeExpiresAt(ctx)
	case user.FieldNewUserToken:
		return m.OldNewUserToken(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldRegister:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegister(v)
		return nil
	case user.FieldCertClearPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertClearPassword(v)
		return nil
	case user.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case user.FieldOpenid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenid(v)
		return nil
	case user.FieldPasswd:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswd(v)
		return nil
	case user.FieldUse2fa:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUse2fa(v)
		return nil
	case user.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case user.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	case user.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case user.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case user.FieldIDToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDToken(v)
		return nil
	case user.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case user.FieldTokenExpiry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenExpiry(v)
		return nil
	case user.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case user.FieldTotpSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpSecret(v)
		return nil
	case user.FieldTotpSecretConfirmed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpSecretConfirmed(v)
		return nil
	case user.FieldForgotPasswordCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForgotPasswordCode(v)
		return nil
	case user.FieldForgotPasswordCodeExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForgotPasswordCodeExpiresAt(v)
		return nil
	case user.FieldNewUserToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewUserToken(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addtoken_expiry != nil {
		fields = append(fields, user.FieldTokenExpiry)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldTokenExpiry:
		return m.AddedTokenExpiry()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldTokenExpiry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldCountry) {
		fields = append(fields, user.FieldCountry)
	}
	if m.FieldCleared(user.FieldCertClearPassword) {
		fields = append(fields, user.FieldCertClearPassword)
	}
	if m.FieldCleared(user.FieldExpiry) {
		fields = append(fields, user.FieldExpiry)
	}
	if m.FieldCleared(user.FieldOpenid) {
		fields = append(fields, user.FieldOpenid)
	}
	if m.FieldCleared(user.FieldPasswd) {
		fields = append(fields, user.FieldPasswd)
	}
	if m.FieldCleared(user.FieldUse2fa) {
		fields = append(fields, user.FieldUse2fa)
	}
	if m.FieldCleared(user.FieldCreated) {
		fields = append(fields, user.FieldCreated)
	}
	if m.FieldCleared(user.FieldModified) {
		fields = append(fields, user.FieldModified)
	}
	if m.FieldCleared(user.FieldAccessToken) {
		fields = append(fields, user.FieldAccessToken)
	}
	if m.FieldCleared(user.FieldRefreshToken) {
		fields = append(fields, user.FieldRefreshToken)
	}
	if m.FieldCleared(user.FieldIDToken) {
		fields = append(fields, user.FieldIDToken)
	}
	if m.FieldCleared(user.FieldTokenType) {
		fields = append(fields, user.FieldTokenType)
	}
	if m.FieldCleared(user.FieldTokenExpiry) {
		fields = append(fields, user.FieldTokenExpiry)
	}
	if m.FieldCleared(user.FieldHash) {
		fields = append(fields, user.FieldHash)
	}
	if m.FieldCleared(user.FieldTotpSecret) {
		fields = append(fields, user.FieldTotpSecret)
	}
	if m.FieldCleared(user.FieldTotpSecretConfirmed) {
		fields = append(fields, user.FieldTotpSecretConfirmed)
	}
	if m.FieldCleared(user.FieldForgotPasswordCode) {
		fields = append(fields, user.FieldForgotPasswordCode)
	}
	if m.FieldCleared(user.FieldForgotPasswordCodeExpiresAt) {
		fields = append(fields, user.FieldForgotPasswordCodeExpiresAt)
	}
	if m.FieldCleared(user.FieldNewUserToken) {
		fields = append(fields, user.FieldNewUserToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldCountry:
		m.ClearCountry()
		return nil
	case user.FieldCertClearPassword:
		m.ClearCertClearPassword()
		return nil
	case user.FieldExpiry:
		m.ClearExpiry()
		return nil
	case user.FieldOpenid:
		m.ClearOpenid()
		return nil
	case user.FieldPasswd:
		m.ClearPasswd()
		return nil
	case user.FieldUse2fa:
		m.ClearUse2fa()
		return nil
	case user.FieldCreated:
		m.ClearCreated()
		return nil
	case user.FieldModified:
		m.ClearModified()
		return nil
	case user.FieldAccessToken:
		m.ClearAccessToken()
		return nil
	case user.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case user.FieldIDToken:
		m.ClearIDToken()
		return nil
	case user.FieldTokenType:
		m.ClearTokenType()
		return nil
	case user.FieldTokenExpiry:
		m.ClearTokenExpiry()
		return nil
	case user.FieldHash:
		m.ClearHash()
		return nil
	case user.FieldTotpSecret:
		m.ClearTotpSecret()
		return nil
	case user.FieldTotpSecretConfirmed:
		m.ClearTotpSecretConfirmed()
		return nil
	case user.FieldForgotPasswordCode:
		m.ClearForgotPasswordCode()
		return nil
	case user.FieldForgotPasswordCodeExpiresAt:
		m.ClearForgotPasswordCodeExpiresAt()
		return nil
	case user.FieldNewUserToken:
		m.ClearNewUserToken()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldCountry:
		m.ResetCountry()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldRegister:
		m.ResetRegister()
		return nil
	case user.FieldCertClearPassword:
		m.ResetCertClearPassword()
		return nil
	case user.FieldExpiry:
		m.ResetExpiry()
		return nil
	case user.FieldOpenid:
		m.ResetOpenid()
		return nil
	case user.FieldPasswd:
		m.ResetPasswd()
		return nil
	case user.FieldUse2fa:
		m.ResetUse2fa()
		return nil
	case user.FieldCreated:
		m.ResetCreated()
		return nil
	case user.FieldModified:
		m.ResetModified()
		return nil
	case user.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case user.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case user.FieldIDToken:
		m.ResetIDToken()
		return nil
	case user.FieldTokenType:
		m.ResetTokenType()
		return nil
	case user.FieldTokenExpiry:
		m.ResetTokenExpiry()
		return nil
	case user.FieldHash:
		m.ResetHash()
		return nil
	case user.FieldTotpSecret:
		m.ResetTotpSecret()
		return nil
	case user.FieldTotpSecretConfirmed:
		m.ResetTotpSecretConfirmed()
		return nil
	case user.FieldForgotPasswordCode:
		m.ResetForgotPasswordCode()
		return nil
	case user.FieldForgotPasswordCodeExpiresAt:
		m.ResetForgotPasswordCodeExpiresAt()
		return nil
	case user.FieldNewUserToken:
		m.ResetNewUserToken()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.recoverycodes != nil {
		edges = append(edges, user.EdgeRecoverycodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRecoverycodes:
		ids := make([]ent.Value, 0, len(m.recoverycodes))
		for id := range m.recoverycodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedrecoverycodes != nil {
		edges = append(edges, user.EdgeRecoverycodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRecoverycodes:
		ids := make([]ent.Value, 0, len(m.removedrecoverycodes))
		for id := range m.removedrecoverycodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedrecoverycodes {
		edges = append(edges, user.EdgeRecoverycodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeRecoverycodes:
		return m.clearedrecoverycodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeRecoverycodes:
		m.ResetRecoverycodes()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WingetConfigExclusionMutation represents an operation that mutates the WingetConfigExclusion nodes in the graph.
type WingetConfigExclusionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	package_id    *string
	when          *time.Time
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*WingetConfigExclusion, error)
	predicates    []predicate.WingetConfigExclusion
}

var _ ent.Mutation = (*WingetConfigExclusionMutation)(nil)

// wingetconfigexclusionOption allows management of the mutation configuration using functional options.
type wingetconfigexclusionOption func(*WingetConfigExclusionMutation)

// newWingetConfigExclusionMutation creates new mutation for the WingetConfigExclusion entity.
func newWingetConfigExclusionMutation(c config, op Op, opts ...wingetconfigexclusionOption) *WingetConfigExclusionMutation {
	m := &WingetConfigExclusionMutation{
		config:        c,
		op:            op,
		typ:           TypeWingetConfigExclusion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWingetConfigExclusionID sets the ID field of the mutation.
func withWingetConfigExclusionID(id int) wingetconfigexclusionOption {
	return func(m *WingetConfigExclusionMutation) {
		var (
			err   error
			once  sync.Once
			value *WingetConfigExclusion
		)
		m.oldValue = func(ctx context.Context) (*WingetConfigExclusion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WingetConfigExclusion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWingetConfigExclusion sets the old WingetConfigExclusion of the mutation.
func withWingetConfigExclusion(node *WingetConfigExclusion) wingetconfigexclusionOption {
	return func(m *WingetConfigExclusionMutation) {
		m.oldValue = func(context.Context) (*WingetConfigExclusion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WingetConfigExclusionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WingetConfigExclusionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WingetConfigExclusionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WingetConfigExclusionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WingetConfigExclusion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *WingetConfigExclusionMutation) SetPackageID(s string) {
	m.package_id = &s
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *WingetConfigExclusionMutation) PackageID() (r string, exists bool) {
	v := m.package_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the WingetConfigExclusion entity.
// If the WingetConfigExclusion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WingetConfigExclusionMutation) OldPackageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *WingetConfigExclusionMutation) ResetPackageID() {
	m.package_id = nil
}

// SetWhen sets the "when" field.
func (m *WingetConfigExclusionMutation) SetWhen(t time.Time) {
	m.when = &t
}

// When returns the value of the "when" field in the mutation.
func (m *WingetConfigExclusionMutation) When() (r time.Time, exists bool) {
	v := m.when
	if v == nil {
		return
	}
	return *v, true
}

// OldWhen returns the old "when" field's value of the WingetConfigExclusion entity.
// If the WingetConfigExclusion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WingetConfigExclusionMutation) OldWhen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhen: %w", err)
	}
	return oldValue.When, nil
}

// ClearWhen clears the value of the "when" field.
func (m *WingetConfigExclusionMutation) ClearWhen() {
	m.when = nil
	m.clearedFields[wingetconfigexclusion.FieldWhen] = struct{}{}
}

// WhenCleared returns if the "when" field was cleared in this mutation.
func (m *WingetConfigExclusionMutation) WhenCleared() bool {
	_, ok := m.clearedFields[wingetconfigexclusion.FieldWhen]
	return ok
}

// ResetWhen resets all changes to the "when" field.
func (m *WingetConfigExclusionMutation) ResetWhen() {
	m.when = nil
	delete(m.clearedFields, wingetconfigexclusion.FieldWhen)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *WingetConfigExclusionMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *WingetConfigExclusionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *WingetConfigExclusionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *WingetConfigExclusionMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *WingetConfigExclusionMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *WingetConfigExclusionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the WingetConfigExclusionMutation builder.
func (m *WingetConfigExclusionMutation) Where(ps ...predicate.WingetConfigExclusion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WingetConfigExclusionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WingetConfigExclusionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WingetConfigExclusion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WingetConfigExclusionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WingetConfigExclusionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WingetConfigExclusion).
func (m *WingetConfigExclusionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WingetConfigExclusionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.package_id != nil {
		fields = append(fields, wingetconfigexclusion.FieldPackageID)
	}
	if m.when != nil {
		fields = append(fields, wingetconfigexclusion.FieldWhen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WingetConfigExclusionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wingetconfigexclusion.FieldPackageID:
		return m.PackageID()
	case wingetconfigexclusion.FieldWhen:
		return m.When()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WingetConfigExclusionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wingetconfigexclusion.FieldPackageID:
		return m.OldPackageID(ctx)
	case wingetconfigexclusion.FieldWhen:
		return m.OldWhen(ctx)
	}
	return nil, fmt.Errorf("unknown WingetConfigExclusion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WingetConfigExclusionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wingetconfigexclusion.FieldPackageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case wingetconfigexclusion.FieldWhen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhen(v)
		return nil
	}
	return fmt.Errorf("unknown WingetConfigExclusion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WingetConfigExclusionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WingetConfigExclusionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WingetConfigExclusionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WingetConfigExclusion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WingetConfigExclusionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wingetconfigexclusion.FieldWhen) {
		fields = append(fields, wingetconfigexclusion.FieldWhen)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WingetConfigExclusionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WingetConfigExclusionMutation) ClearField(name string) error {
	switch name {
	case wingetconfigexclusion.FieldWhen:
		m.ClearWhen()
		return nil
	}
	return fmt.Errorf("unknown WingetConfigExclusion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WingetConfigExclusionMutation) ResetField(name string) error {
	switch name {
	case wingetconfigexclusion.FieldPackageID:
		m.ResetPackageID()
		return nil
	case wingetconfigexclusion.FieldWhen:
		m.ResetWhen()
		return nil
	}
	return fmt.Errorf("unknown WingetConfigExclusion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WingetConfigExclusionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, wingetconfigexclusion.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WingetConfigExclusionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wingetconfigexclusion.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WingetConfigExclusionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WingetConfigExclusionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WingetConfigExclusionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, wingetconfigexclusion.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WingetConfigExclusionMutation) EdgeCleared(name string) bool {
	switch name {
	case wingetconfigexclusion.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WingetConfigExclusionMutation) ClearEdge(name string) error {
	switch name {
	case wingetconfigexclusion.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown WingetConfigExclusion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WingetConfigExclusionMutation) ResetEdge(name string) error {
	switch name {
	case wingetconfigexclusion.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown WingetConfigExclusion edge %s", name)
}
