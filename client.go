// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/open-uem/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/open-uem/ent/agent"
	"github.com/open-uem/ent/antivirus"
	"github.com/open-uem/ent/app"
	"github.com/open-uem/ent/authentication"
	"github.com/open-uem/ent/certificate"
	"github.com/open-uem/ent/computer"
	"github.com/open-uem/ent/deployment"
	"github.com/open-uem/ent/logicaldisk"
	"github.com/open-uem/ent/memoryslot"
	"github.com/open-uem/ent/metadata"
	"github.com/open-uem/ent/monitor"
	"github.com/open-uem/ent/netbird"
	"github.com/open-uem/ent/netbirdsettings"
	"github.com/open-uem/ent/networkadapter"
	"github.com/open-uem/ent/operatingsystem"
	"github.com/open-uem/ent/orgmetadata"
	"github.com/open-uem/ent/physicaldisk"
	"github.com/open-uem/ent/printer"
	"github.com/open-uem/ent/profile"
	"github.com/open-uem/ent/profileissue"
	"github.com/open-uem/ent/recoverycode"
	"github.com/open-uem/ent/release"
	"github.com/open-uem/ent/revocation"
	"github.com/open-uem/ent/rustdesk"
	"github.com/open-uem/ent/server"
	"github.com/open-uem/ent/sessions"
	"github.com/open-uem/ent/settings"
	"github.com/open-uem/ent/share"
	"github.com/open-uem/ent/site"
	"github.com/open-uem/ent/systemupdate"
	"github.com/open-uem/ent/tag"
	"github.com/open-uem/ent/task"
	"github.com/open-uem/ent/taskreport"
	"github.com/open-uem/ent/tenant"
	"github.com/open-uem/ent/update"
	"github.com/open-uem/ent/user"
	"github.com/open-uem/ent/wingetconfigexclusion"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Agent is the client for interacting with the Agent builders.
	Agent *AgentClient
	// Antivirus is the client for interacting with the Antivirus builders.
	Antivirus *AntivirusClient
	// App is the client for interacting with the App builders.
	App *AppClient
	// Authentication is the client for interacting with the Authentication builders.
	Authentication *AuthenticationClient
	// Certificate is the client for interacting with the Certificate builders.
	Certificate *CertificateClient
	// Computer is the client for interacting with the Computer builders.
	Computer *ComputerClient
	// Deployment is the client for interacting with the Deployment builders.
	Deployment *DeploymentClient
	// LogicalDisk is the client for interacting with the LogicalDisk builders.
	LogicalDisk *LogicalDiskClient
	// MemorySlot is the client for interacting with the MemorySlot builders.
	MemorySlot *MemorySlotClient
	// Metadata is the client for interacting with the Metadata builders.
	Metadata *MetadataClient
	// Monitor is the client for interacting with the Monitor builders.
	Monitor *MonitorClient
	// Netbird is the client for interacting with the Netbird builders.
	Netbird *NetbirdClient
	// NetbirdSettings is the client for interacting with the NetbirdSettings builders.
	NetbirdSettings *NetbirdSettingsClient
	// NetworkAdapter is the client for interacting with the NetworkAdapter builders.
	NetworkAdapter *NetworkAdapterClient
	// OperatingSystem is the client for interacting with the OperatingSystem builders.
	OperatingSystem *OperatingSystemClient
	// OrgMetadata is the client for interacting with the OrgMetadata builders.
	OrgMetadata *OrgMetadataClient
	// PhysicalDisk is the client for interacting with the PhysicalDisk builders.
	PhysicalDisk *PhysicalDiskClient
	// Printer is the client for interacting with the Printer builders.
	Printer *PrinterClient
	// Profile is the client for interacting with the Profile builders.
	Profile *ProfileClient
	// ProfileIssue is the client for interacting with the ProfileIssue builders.
	ProfileIssue *ProfileIssueClient
	// RecoveryCode is the client for interacting with the RecoveryCode builders.
	RecoveryCode *RecoveryCodeClient
	// Release is the client for interacting with the Release builders.
	Release *ReleaseClient
	// Revocation is the client for interacting with the Revocation builders.
	Revocation *RevocationClient
	// Rustdesk is the client for interacting with the Rustdesk builders.
	Rustdesk *RustdeskClient
	// Server is the client for interacting with the Server builders.
	Server *ServerClient
	// Sessions is the client for interacting with the Sessions builders.
	Sessions *SessionsClient
	// Settings is the client for interacting with the Settings builders.
	Settings *SettingsClient
	// Share is the client for interacting with the Share builders.
	Share *ShareClient
	// Site is the client for interacting with the Site builders.
	Site *SiteClient
	// SystemUpdate is the client for interacting with the SystemUpdate builders.
	SystemUpdate *SystemUpdateClient
	// Tag is the client for interacting with the Tag builders.
	Tag *TagClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// TaskReport is the client for interacting with the TaskReport builders.
	TaskReport *TaskReportClient
	// Tenant is the client for interacting with the Tenant builders.
	Tenant *TenantClient
	// Update is the client for interacting with the Update builders.
	Update *UpdateClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// WingetConfigExclusion is the client for interacting with the WingetConfigExclusion builders.
	WingetConfigExclusion *WingetConfigExclusionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Agent = NewAgentClient(c.config)
	c.Antivirus = NewAntivirusClient(c.config)
	c.App = NewAppClient(c.config)
	c.Authentication = NewAuthenticationClient(c.config)
	c.Certificate = NewCertificateClient(c.config)
	c.Computer = NewComputerClient(c.config)
	c.Deployment = NewDeploymentClient(c.config)
	c.LogicalDisk = NewLogicalDiskClient(c.config)
	c.MemorySlot = NewMemorySlotClient(c.config)
	c.Metadata = NewMetadataClient(c.config)
	c.Monitor = NewMonitorClient(c.config)
	c.Netbird = NewNetbirdClient(c.config)
	c.NetbirdSettings = NewNetbirdSettingsClient(c.config)
	c.NetworkAdapter = NewNetworkAdapterClient(c.config)
	c.OperatingSystem = NewOperatingSystemClient(c.config)
	c.OrgMetadata = NewOrgMetadataClient(c.config)
	c.PhysicalDisk = NewPhysicalDiskClient(c.config)
	c.Printer = NewPrinterClient(c.config)
	c.Profile = NewProfileClient(c.config)
	c.ProfileIssue = NewProfileIssueClient(c.config)
	c.RecoveryCode = NewRecoveryCodeClient(c.config)
	c.Release = NewReleaseClient(c.config)
	c.Revocation = NewRevocationClient(c.config)
	c.Rustdesk = NewRustdeskClient(c.config)
	c.Server = NewServerClient(c.config)
	c.Sessions = NewSessionsClient(c.config)
	c.Settings = NewSettingsClient(c.config)
	c.Share = NewShareClient(c.config)
	c.Site = NewSiteClient(c.config)
	c.SystemUpdate = NewSystemUpdateClient(c.config)
	c.Tag = NewTagClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.TaskReport = NewTaskReportClient(c.config)
	c.Tenant = NewTenantClient(c.config)
	c.Update = NewUpdateClient(c.config)
	c.User = NewUserClient(c.config)
	c.WingetConfigExclusion = NewWingetConfigExclusionClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Agent:                 NewAgentClient(cfg),
		Antivirus:             NewAntivirusClient(cfg),
		App:                   NewAppClient(cfg),
		Authentication:        NewAuthenticationClient(cfg),
		Certificate:           NewCertificateClient(cfg),
		Computer:              NewComputerClient(cfg),
		Deployment:            NewDeploymentClient(cfg),
		LogicalDisk:           NewLogicalDiskClient(cfg),
		MemorySlot:            NewMemorySlotClient(cfg),
		Metadata:              NewMetadataClient(cfg),
		Monitor:               NewMonitorClient(cfg),
		Netbird:               NewNetbirdClient(cfg),
		NetbirdSettings:       NewNetbirdSettingsClient(cfg),
		NetworkAdapter:        NewNetworkAdapterClient(cfg),
		OperatingSystem:       NewOperatingSystemClient(cfg),
		OrgMetadata:           NewOrgMetadataClient(cfg),
		PhysicalDisk:          NewPhysicalDiskClient(cfg),
		Printer:               NewPrinterClient(cfg),
		Profile:               NewProfileClient(cfg),
		ProfileIssue:          NewProfileIssueClient(cfg),
		RecoveryCode:          NewRecoveryCodeClient(cfg),
		Release:               NewReleaseClient(cfg),
		Revocation:            NewRevocationClient(cfg),
		Rustdesk:              NewRustdeskClient(cfg),
		Server:                NewServerClient(cfg),
		Sessions:              NewSessionsClient(cfg),
		Settings:              NewSettingsClient(cfg),
		Share:                 NewShareClient(cfg),
		Site:                  NewSiteClient(cfg),
		SystemUpdate:          NewSystemUpdateClient(cfg),
		Tag:                   NewTagClient(cfg),
		Task:                  NewTaskClient(cfg),
		TaskReport:            NewTaskReportClient(cfg),
		Tenant:                NewTenantClient(cfg),
		Update:                NewUpdateClient(cfg),
		User:                  NewUserClient(cfg),
		WingetConfigExclusion: NewWingetConfigExclusionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                   ctx,
		config:                cfg,
		Agent:                 NewAgentClient(cfg),
		Antivirus:             NewAntivirusClient(cfg),
		App:                   NewAppClient(cfg),
		Authentication:        NewAuthenticationClient(cfg),
		Certificate:           NewCertificateClient(cfg),
		Computer:              NewComputerClient(cfg),
		Deployment:            NewDeploymentClient(cfg),
		LogicalDisk:           NewLogicalDiskClient(cfg),
		MemorySlot:            NewMemorySlotClient(cfg),
		Metadata:              NewMetadataClient(cfg),
		Monitor:               NewMonitorClient(cfg),
		Netbird:               NewNetbirdClient(cfg),
		NetbirdSettings:       NewNetbirdSettingsClient(cfg),
		NetworkAdapter:        NewNetworkAdapterClient(cfg),
		OperatingSystem:       NewOperatingSystemClient(cfg),
		OrgMetadata:           NewOrgMetadataClient(cfg),
		PhysicalDisk:          NewPhysicalDiskClient(cfg),
		Printer:               NewPrinterClient(cfg),
		Profile:               NewProfileClient(cfg),
		ProfileIssue:          NewProfileIssueClient(cfg),
		RecoveryCode:          NewRecoveryCodeClient(cfg),
		Release:               NewReleaseClient(cfg),
		Revocation:            NewRevocationClient(cfg),
		Rustdesk:              NewRustdeskClient(cfg),
		Server:                NewServerClient(cfg),
		Sessions:              NewSessionsClient(cfg),
		Settings:              NewSettingsClient(cfg),
		Share:                 NewShareClient(cfg),
		Site:                  NewSiteClient(cfg),
		SystemUpdate:          NewSystemUpdateClient(cfg),
		Tag:                   NewTagClient(cfg),
		Task:                  NewTaskClient(cfg),
		TaskReport:            NewTaskReportClient(cfg),
		Tenant:                NewTenantClient(cfg),
		Update:                NewUpdateClient(cfg),
		User:                  NewUserClient(cfg),
		WingetConfigExclusion: NewWingetConfigExclusionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Agent.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Agent, c.Antivirus, c.App, c.Authentication, c.Certificate, c.Computer,
		c.Deployment, c.LogicalDisk, c.MemorySlot, c.Metadata, c.Monitor, c.Netbird,
		c.NetbirdSettings, c.NetworkAdapter, c.OperatingSystem, c.OrgMetadata,
		c.PhysicalDisk, c.Printer, c.Profile, c.ProfileIssue, c.RecoveryCode,
		c.Release, c.Revocation, c.Rustdesk, c.Server, c.Sessions, c.Settings, c.Share,
		c.Site, c.SystemUpdate, c.Tag, c.Task, c.TaskReport, c.Tenant, c.Update,
		c.User, c.WingetConfigExclusion,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Agent, c.Antivirus, c.App, c.Authentication, c.Certificate, c.Computer,
		c.Deployment, c.LogicalDisk, c.MemorySlot, c.Metadata, c.Monitor, c.Netbird,
		c.NetbirdSettings, c.NetworkAdapter, c.OperatingSystem, c.OrgMetadata,
		c.PhysicalDisk, c.Printer, c.Profile, c.ProfileIssue, c.RecoveryCode,
		c.Release, c.Revocation, c.Rustdesk, c.Server, c.Sessions, c.Settings, c.Share,
		c.Site, c.SystemUpdate, c.Tag, c.Task, c.TaskReport, c.Tenant, c.Update,
		c.User, c.WingetConfigExclusion,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AgentMutation:
		return c.Agent.mutate(ctx, m)
	case *AntivirusMutation:
		return c.Antivirus.mutate(ctx, m)
	case *AppMutation:
		return c.App.mutate(ctx, m)
	case *AuthenticationMutation:
		return c.Authentication.mutate(ctx, m)
	case *CertificateMutation:
		return c.Certificate.mutate(ctx, m)
	case *ComputerMutation:
		return c.Computer.mutate(ctx, m)
	case *DeploymentMutation:
		return c.Deployment.mutate(ctx, m)
	case *LogicalDiskMutation:
		return c.LogicalDisk.mutate(ctx, m)
	case *MemorySlotMutation:
		return c.MemorySlot.mutate(ctx, m)
	case *MetadataMutation:
		return c.Metadata.mutate(ctx, m)
	case *MonitorMutation:
		return c.Monitor.mutate(ctx, m)
	case *NetbirdMutation:
		return c.Netbird.mutate(ctx, m)
	case *NetbirdSettingsMutation:
		return c.NetbirdSettings.mutate(ctx, m)
	case *NetworkAdapterMutation:
		return c.NetworkAdapter.mutate(ctx, m)
	case *OperatingSystemMutation:
		return c.OperatingSystem.mutate(ctx, m)
	case *OrgMetadataMutation:
		return c.OrgMetadata.mutate(ctx, m)
	case *PhysicalDiskMutation:
		return c.PhysicalDisk.mutate(ctx, m)
	case *PrinterMutation:
		return c.Printer.mutate(ctx, m)
	case *ProfileMutation:
		return c.Profile.mutate(ctx, m)
	case *ProfileIssueMutation:
		return c.ProfileIssue.mutate(ctx, m)
	case *RecoveryCodeMutation:
		return c.RecoveryCode.mutate(ctx, m)
	case *ReleaseMutation:
		return c.Release.mutate(ctx, m)
	case *RevocationMutation:
		return c.Revocation.mutate(ctx, m)
	case *RustdeskMutation:
		return c.Rustdesk.mutate(ctx, m)
	case *ServerMutation:
		return c.Server.mutate(ctx, m)
	case *SessionsMutation:
		return c.Sessions.mutate(ctx, m)
	case *SettingsMutation:
		return c.Settings.mutate(ctx, m)
	case *ShareMutation:
		return c.Share.mutate(ctx, m)
	case *SiteMutation:
		return c.Site.mutate(ctx, m)
	case *SystemUpdateMutation:
		return c.SystemUpdate.mutate(ctx, m)
	case *TagMutation:
		return c.Tag.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	case *TaskReportMutation:
		return c.TaskReport.mutate(ctx, m)
	case *TenantMutation:
		return c.Tenant.mutate(ctx, m)
	case *UpdateMutation:
		return c.Update.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *WingetConfigExclusionMutation:
		return c.WingetConfigExclusion.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AgentClient is a client for the Agent schema.
type AgentClient struct {
	config
}

// NewAgentClient returns a client for the Agent from the given config.
func NewAgentClient(c config) *AgentClient {
	return &AgentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agent.Hooks(f(g(h())))`.
func (c *AgentClient) Use(hooks ...Hook) {
	c.hooks.Agent = append(c.hooks.Agent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agent.Intercept(f(g(h())))`.
func (c *AgentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Agent = append(c.inters.Agent, interceptors...)
}

// Create returns a builder for creating a Agent entity.
func (c *AgentClient) Create() *AgentCreate {
	mutation := newAgentMutation(c.config, OpCreate)
	return &AgentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Agent entities.
func (c *AgentClient) CreateBulk(builders ...*AgentCreate) *AgentCreateBulk {
	return &AgentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentClient) MapCreateBulk(slice any, setFunc func(*AgentCreate, int)) *AgentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentCreateBulk{err: fmt.Errorf("calling to AgentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Agent.
func (c *AgentClient) Update() *AgentUpdate {
	mutation := newAgentMutation(c.config, OpUpdate)
	return &AgentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentClient) UpdateOne(a *Agent) *AgentUpdateOne {
	mutation := newAgentMutation(c.config, OpUpdateOne, withAgent(a))
	return &AgentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentClient) UpdateOneID(id string) *AgentUpdateOne {
	mutation := newAgentMutation(c.config, OpUpdateOne, withAgentID(id))
	return &AgentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Agent.
func (c *AgentClient) Delete() *AgentDelete {
	mutation := newAgentMutation(c.config, OpDelete)
	return &AgentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentClient) DeleteOne(a *Agent) *AgentDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentClient) DeleteOneID(id string) *AgentDeleteOne {
	builder := c.Delete().Where(agent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentDeleteOne{builder}
}

// Query returns a query builder for Agent.
func (c *AgentClient) Query() *AgentQuery {
	return &AgentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgent},
		inters: c.Interceptors(),
	}
}

// Get returns a Agent entity by its id.
func (c *AgentClient) Get(ctx context.Context, id string) (*Agent, error) {
	return c.Query().Where(agent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentClient) GetX(ctx context.Context, id string) *Agent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComputer queries the computer edge of a Agent.
func (c *AgentClient) QueryComputer(a *Agent) *ComputerQuery {
	query := (&ComputerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(computer.Table, computer.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, agent.ComputerTable, agent.ComputerColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOperatingsystem queries the operatingsystem edge of a Agent.
func (c *AgentClient) QueryOperatingsystem(a *Agent) *OperatingSystemQuery {
	query := (&OperatingSystemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(operatingsystem.Table, operatingsystem.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, agent.OperatingsystemTable, agent.OperatingsystemColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySystemupdate queries the systemupdate edge of a Agent.
func (c *AgentClient) QuerySystemupdate(a *Agent) *SystemUpdateQuery {
	query := (&SystemUpdateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(systemupdate.Table, systemupdate.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, agent.SystemupdateTable, agent.SystemupdateColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAntivirus queries the antivirus edge of a Agent.
func (c *AgentClient) QueryAntivirus(a *Agent) *AntivirusQuery {
	query := (&AntivirusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(antivirus.Table, antivirus.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, agent.AntivirusTable, agent.AntivirusColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogicaldisks queries the logicaldisks edge of a Agent.
func (c *AgentClient) QueryLogicaldisks(a *Agent) *LogicalDiskQuery {
	query := (&LogicalDiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(logicaldisk.Table, logicaldisk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.LogicaldisksTable, agent.LogicaldisksColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApps queries the apps edge of a Agent.
func (c *AgentClient) QueryApps(a *Agent) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.AppsTable, agent.AppsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMonitors queries the monitors edge of a Agent.
func (c *AgentClient) QueryMonitors(a *Agent) *MonitorQuery {
	query := (&MonitorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(monitor.Table, monitor.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.MonitorsTable, agent.MonitorsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryShares queries the shares edge of a Agent.
func (c *AgentClient) QueryShares(a *Agent) *ShareQuery {
	query := (&ShareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(share.Table, share.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.SharesTable, agent.SharesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrinters queries the printers edge of a Agent.
func (c *AgentClient) QueryPrinters(a *Agent) *PrinterQuery {
	query := (&PrinterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(printer.Table, printer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.PrintersTable, agent.PrintersColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetworkadapters queries the networkadapters edge of a Agent.
func (c *AgentClient) QueryNetworkadapters(a *Agent) *NetworkAdapterQuery {
	query := (&NetworkAdapterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(networkadapter.Table, networkadapter.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.NetworkadaptersTable, agent.NetworkadaptersColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeployments queries the deployments edge of a Agent.
func (c *AgentClient) QueryDeployments(a *Agent) *DeploymentQuery {
	query := (&DeploymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(deployment.Table, deployment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.DeploymentsTable, agent.DeploymentsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUpdates queries the updates edge of a Agent.
func (c *AgentClient) QueryUpdates(a *Agent) *UpdateQuery {
	query := (&UpdateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(update.Table, update.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.UpdatesTable, agent.UpdatesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a Agent.
func (c *AgentClient) QueryTags(a *Agent) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, agent.TagsTable, agent.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a Agent.
func (c *AgentClient) QueryMetadata(a *Agent) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.MetadataTable, agent.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWingetcfgexclusions queries the wingetcfgexclusions edge of a Agent.
func (c *AgentClient) QueryWingetcfgexclusions(a *Agent) *WingetConfigExclusionQuery {
	query := (&WingetConfigExclusionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(wingetconfigexclusion.Table, wingetconfigexclusion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.WingetcfgexclusionsTable, agent.WingetcfgexclusionsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMemoryslots queries the memoryslots edge of a Agent.
func (c *AgentClient) QueryMemoryslots(a *Agent) *MemorySlotQuery {
	query := (&MemorySlotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(memoryslot.Table, memoryslot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.MemoryslotsTable, agent.MemoryslotsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a Agent.
func (c *AgentClient) QueryRelease(a *Agent) *ReleaseQuery {
	query := (&ReleaseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agent.ReleaseTable, agent.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfileissue queries the profileissue edge of a Agent.
func (c *AgentClient) QueryProfileissue(a *Agent) *ProfileIssueQuery {
	query := (&ProfileIssueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(profileissue.Table, profileissue.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, agent.ProfileissueTable, agent.ProfileissueColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySite queries the site edge of a Agent.
func (c *AgentClient) QuerySite(a *Agent) *SiteQuery {
	query := (&SiteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(site.Table, site.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, agent.SiteTable, agent.SitePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPhysicaldisks queries the physicaldisks edge of a Agent.
func (c *AgentClient) QueryPhysicaldisks(a *Agent) *PhysicalDiskQuery {
	query := (&PhysicalDiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(physicaldisk.Table, physicaldisk.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agent.PhysicaldisksTable, agent.PhysicaldisksColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetbird queries the netbird edge of a Agent.
func (c *AgentClient) QueryNetbird(a *Agent) *NetbirdQuery {
	query := (&NetbirdClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agent.Table, agent.FieldID, id),
			sqlgraph.To(netbird.Table, netbird.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, agent.NetbirdTable, agent.NetbirdColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentClient) Hooks() []Hook {
	return c.hooks.Agent
}

// Interceptors returns the client interceptors.
func (c *AgentClient) Interceptors() []Interceptor {
	return c.inters.Agent
}

func (c *AgentClient) mutate(ctx context.Context, m *AgentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Agent mutation op: %q", m.Op())
	}
}

// AntivirusClient is a client for the Antivirus schema.
type AntivirusClient struct {
	config
}

// NewAntivirusClient returns a client for the Antivirus from the given config.
func NewAntivirusClient(c config) *AntivirusClient {
	return &AntivirusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `antivirus.Hooks(f(g(h())))`.
func (c *AntivirusClient) Use(hooks ...Hook) {
	c.hooks.Antivirus = append(c.hooks.Antivirus, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `antivirus.Intercept(f(g(h())))`.
func (c *AntivirusClient) Intercept(interceptors ...Interceptor) {
	c.inters.Antivirus = append(c.inters.Antivirus, interceptors...)
}

// Create returns a builder for creating a Antivirus entity.
func (c *AntivirusClient) Create() *AntivirusCreate {
	mutation := newAntivirusMutation(c.config, OpCreate)
	return &AntivirusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Antivirus entities.
func (c *AntivirusClient) CreateBulk(builders ...*AntivirusCreate) *AntivirusCreateBulk {
	return &AntivirusCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AntivirusClient) MapCreateBulk(slice any, setFunc func(*AntivirusCreate, int)) *AntivirusCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AntivirusCreateBulk{err: fmt.Errorf("calling to AntivirusClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AntivirusCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AntivirusCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Antivirus.
func (c *AntivirusClient) Update() *AntivirusUpdate {
	mutation := newAntivirusMutation(c.config, OpUpdate)
	return &AntivirusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AntivirusClient) UpdateOne(a *Antivirus) *AntivirusUpdateOne {
	mutation := newAntivirusMutation(c.config, OpUpdateOne, withAntivirus(a))
	return &AntivirusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AntivirusClient) UpdateOneID(id int) *AntivirusUpdateOne {
	mutation := newAntivirusMutation(c.config, OpUpdateOne, withAntivirusID(id))
	return &AntivirusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Antivirus.
func (c *AntivirusClient) Delete() *AntivirusDelete {
	mutation := newAntivirusMutation(c.config, OpDelete)
	return &AntivirusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AntivirusClient) DeleteOne(a *Antivirus) *AntivirusDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AntivirusClient) DeleteOneID(id int) *AntivirusDeleteOne {
	builder := c.Delete().Where(antivirus.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AntivirusDeleteOne{builder}
}

// Query returns a query builder for Antivirus.
func (c *AntivirusClient) Query() *AntivirusQuery {
	return &AntivirusQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAntivirus},
		inters: c.Interceptors(),
	}
}

// Get returns a Antivirus entity by its id.
func (c *AntivirusClient) Get(ctx context.Context, id int) (*Antivirus, error) {
	return c.Query().Where(antivirus.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AntivirusClient) GetX(ctx context.Context, id int) *Antivirus {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Antivirus.
func (c *AntivirusClient) QueryOwner(a *Antivirus) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(antivirus.Table, antivirus.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, antivirus.OwnerTable, antivirus.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AntivirusClient) Hooks() []Hook {
	return c.hooks.Antivirus
}

// Interceptors returns the client interceptors.
func (c *AntivirusClient) Interceptors() []Interceptor {
	return c.inters.Antivirus
}

func (c *AntivirusClient) mutate(ctx context.Context, m *AntivirusMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AntivirusCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AntivirusUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AntivirusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AntivirusDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Antivirus mutation op: %q", m.Op())
	}
}

// AppClient is a client for the App schema.
type AppClient struct {
	config
}

// NewAppClient returns a client for the App from the given config.
func NewAppClient(c config) *AppClient {
	return &AppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `app.Hooks(f(g(h())))`.
func (c *AppClient) Use(hooks ...Hook) {
	c.hooks.App = append(c.hooks.App, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `app.Intercept(f(g(h())))`.
func (c *AppClient) Intercept(interceptors ...Interceptor) {
	c.inters.App = append(c.inters.App, interceptors...)
}

// Create returns a builder for creating a App entity.
func (c *AppClient) Create() *AppCreate {
	mutation := newAppMutation(c.config, OpCreate)
	return &AppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of App entities.
func (c *AppClient) CreateBulk(builders ...*AppCreate) *AppCreateBulk {
	return &AppCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppClient) MapCreateBulk(slice any, setFunc func(*AppCreate, int)) *AppCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppCreateBulk{err: fmt.Errorf("calling to AppClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for App.
func (c *AppClient) Update() *AppUpdate {
	mutation := newAppMutation(c.config, OpUpdate)
	return &AppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppClient) UpdateOne(a *App) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withApp(a))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppClient) UpdateOneID(id int) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withAppID(id))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for App.
func (c *AppClient) Delete() *AppDelete {
	mutation := newAppMutation(c.config, OpDelete)
	return &AppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppClient) DeleteOne(a *App) *AppDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppClient) DeleteOneID(id int) *AppDeleteOne {
	builder := c.Delete().Where(app.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDeleteOne{builder}
}

// Query returns a query builder for App.
func (c *AppClient) Query() *AppQuery {
	return &AppQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApp},
		inters: c.Interceptors(),
	}
}

// Get returns a App entity by its id.
func (c *AppClient) Get(ctx context.Context, id int) (*App, error) {
	return c.Query().Where(app.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppClient) GetX(ctx context.Context, id int) *App {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a App.
func (c *AppClient) QueryOwner(a *App) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, app.OwnerTable, app.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppClient) Hooks() []Hook {
	return c.hooks.App
}

// Interceptors returns the client interceptors.
func (c *AppClient) Interceptors() []Interceptor {
	return c.inters.App
}

func (c *AppClient) mutate(ctx context.Context, m *AppMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown App mutation op: %q", m.Op())
	}
}

// AuthenticationClient is a client for the Authentication schema.
type AuthenticationClient struct {
	config
}

// NewAuthenticationClient returns a client for the Authentication from the given config.
func NewAuthenticationClient(c config) *AuthenticationClient {
	return &AuthenticationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authentication.Hooks(f(g(h())))`.
func (c *AuthenticationClient) Use(hooks ...Hook) {
	c.hooks.Authentication = append(c.hooks.Authentication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authentication.Intercept(f(g(h())))`.
func (c *AuthenticationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Authentication = append(c.inters.Authentication, interceptors...)
}

// Create returns a builder for creating a Authentication entity.
func (c *AuthenticationClient) Create() *AuthenticationCreate {
	mutation := newAuthenticationMutation(c.config, OpCreate)
	return &AuthenticationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Authentication entities.
func (c *AuthenticationClient) CreateBulk(builders ...*AuthenticationCreate) *AuthenticationCreateBulk {
	return &AuthenticationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthenticationClient) MapCreateBulk(slice any, setFunc func(*AuthenticationCreate, int)) *AuthenticationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthenticationCreateBulk{err: fmt.Errorf("calling to AuthenticationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthenticationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthenticationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Authentication.
func (c *AuthenticationClient) Update() *AuthenticationUpdate {
	mutation := newAuthenticationMutation(c.config, OpUpdate)
	return &AuthenticationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthenticationClient) UpdateOne(a *Authentication) *AuthenticationUpdateOne {
	mutation := newAuthenticationMutation(c.config, OpUpdateOne, withAuthentication(a))
	return &AuthenticationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthenticationClient) UpdateOneID(id int) *AuthenticationUpdateOne {
	mutation := newAuthenticationMutation(c.config, OpUpdateOne, withAuthenticationID(id))
	return &AuthenticationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Authentication.
func (c *AuthenticationClient) Delete() *AuthenticationDelete {
	mutation := newAuthenticationMutation(c.config, OpDelete)
	return &AuthenticationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthenticationClient) DeleteOne(a *Authentication) *AuthenticationDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthenticationClient) DeleteOneID(id int) *AuthenticationDeleteOne {
	builder := c.Delete().Where(authentication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthenticationDeleteOne{builder}
}

// Query returns a query builder for Authentication.
func (c *AuthenticationClient) Query() *AuthenticationQuery {
	return &AuthenticationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthentication},
		inters: c.Interceptors(),
	}
}

// Get returns a Authentication entity by its id.
func (c *AuthenticationClient) Get(ctx context.Context, id int) (*Authentication, error) {
	return c.Query().Where(authentication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthenticationClient) GetX(ctx context.Context, id int) *Authentication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthenticationClient) Hooks() []Hook {
	return c.hooks.Authentication
}

// Interceptors returns the client interceptors.
func (c *AuthenticationClient) Interceptors() []Interceptor {
	return c.inters.Authentication
}

func (c *AuthenticationClient) mutate(ctx context.Context, m *AuthenticationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthenticationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthenticationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthenticationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthenticationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Authentication mutation op: %q", m.Op())
	}
}

// CertificateClient is a client for the Certificate schema.
type CertificateClient struct {
	config
}

// NewCertificateClient returns a client for the Certificate from the given config.
func NewCertificateClient(c config) *CertificateClient {
	return &CertificateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `certificate.Hooks(f(g(h())))`.
func (c *CertificateClient) Use(hooks ...Hook) {
	c.hooks.Certificate = append(c.hooks.Certificate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `certificate.Intercept(f(g(h())))`.
func (c *CertificateClient) Intercept(interceptors ...Interceptor) {
	c.inters.Certificate = append(c.inters.Certificate, interceptors...)
}

// Create returns a builder for creating a Certificate entity.
func (c *CertificateClient) Create() *CertificateCreate {
	mutation := newCertificateMutation(c.config, OpCreate)
	return &CertificateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Certificate entities.
func (c *CertificateClient) CreateBulk(builders ...*CertificateCreate) *CertificateCreateBulk {
	return &CertificateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CertificateClient) MapCreateBulk(slice any, setFunc func(*CertificateCreate, int)) *CertificateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CertificateCreateBulk{err: fmt.Errorf("calling to CertificateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CertificateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CertificateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Certificate.
func (c *CertificateClient) Update() *CertificateUpdate {
	mutation := newCertificateMutation(c.config, OpUpdate)
	return &CertificateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CertificateClient) UpdateOne(ce *Certificate) *CertificateUpdateOne {
	mutation := newCertificateMutation(c.config, OpUpdateOne, withCertificate(ce))
	return &CertificateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CertificateClient) UpdateOneID(id int64) *CertificateUpdateOne {
	mutation := newCertificateMutation(c.config, OpUpdateOne, withCertificateID(id))
	return &CertificateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Certificate.
func (c *CertificateClient) Delete() *CertificateDelete {
	mutation := newCertificateMutation(c.config, OpDelete)
	return &CertificateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CertificateClient) DeleteOne(ce *Certificate) *CertificateDeleteOne {
	return c.DeleteOneID(ce.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CertificateClient) DeleteOneID(id int64) *CertificateDeleteOne {
	builder := c.Delete().Where(certificate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CertificateDeleteOne{builder}
}

// Query returns a query builder for Certificate.
func (c *CertificateClient) Query() *CertificateQuery {
	return &CertificateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCertificate},
		inters: c.Interceptors(),
	}
}

// Get returns a Certificate entity by its id.
func (c *CertificateClient) Get(ctx context.Context, id int64) (*Certificate, error) {
	return c.Query().Where(certificate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CertificateClient) GetX(ctx context.Context, id int64) *Certificate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CertificateClient) Hooks() []Hook {
	return c.hooks.Certificate
}

// Interceptors returns the client interceptors.
func (c *CertificateClient) Interceptors() []Interceptor {
	return c.inters.Certificate
}

func (c *CertificateClient) mutate(ctx context.Context, m *CertificateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CertificateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CertificateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CertificateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CertificateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Certificate mutation op: %q", m.Op())
	}
}

// ComputerClient is a client for the Computer schema.
type ComputerClient struct {
	config
}

// NewComputerClient returns a client for the Computer from the given config.
func NewComputerClient(c config) *ComputerClient {
	return &ComputerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `computer.Hooks(f(g(h())))`.
func (c *ComputerClient) Use(hooks ...Hook) {
	c.hooks.Computer = append(c.hooks.Computer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `computer.Intercept(f(g(h())))`.
func (c *ComputerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Computer = append(c.inters.Computer, interceptors...)
}

// Create returns a builder for creating a Computer entity.
func (c *ComputerClient) Create() *ComputerCreate {
	mutation := newComputerMutation(c.config, OpCreate)
	return &ComputerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Computer entities.
func (c *ComputerClient) CreateBulk(builders ...*ComputerCreate) *ComputerCreateBulk {
	return &ComputerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ComputerClient) MapCreateBulk(slice any, setFunc func(*ComputerCreate, int)) *ComputerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ComputerCreateBulk{err: fmt.Errorf("calling to ComputerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ComputerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ComputerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Computer.
func (c *ComputerClient) Update() *ComputerUpdate {
	mutation := newComputerMutation(c.config, OpUpdate)
	return &ComputerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ComputerClient) UpdateOne(co *Computer) *ComputerUpdateOne {
	mutation := newComputerMutation(c.config, OpUpdateOne, withComputer(co))
	return &ComputerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ComputerClient) UpdateOneID(id int) *ComputerUpdateOne {
	mutation := newComputerMutation(c.config, OpUpdateOne, withComputerID(id))
	return &ComputerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Computer.
func (c *ComputerClient) Delete() *ComputerDelete {
	mutation := newComputerMutation(c.config, OpDelete)
	return &ComputerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ComputerClient) DeleteOne(co *Computer) *ComputerDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ComputerClient) DeleteOneID(id int) *ComputerDeleteOne {
	builder := c.Delete().Where(computer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ComputerDeleteOne{builder}
}

// Query returns a query builder for Computer.
func (c *ComputerClient) Query() *ComputerQuery {
	return &ComputerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComputer},
		inters: c.Interceptors(),
	}
}

// Get returns a Computer entity by its id.
func (c *ComputerClient) Get(ctx context.Context, id int) (*Computer, error) {
	return c.Query().Where(computer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ComputerClient) GetX(ctx context.Context, id int) *Computer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Computer.
func (c *ComputerClient) QueryOwner(co *Computer) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(computer.Table, computer.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, computer.OwnerTable, computer.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ComputerClient) Hooks() []Hook {
	return c.hooks.Computer
}

// Interceptors returns the client interceptors.
func (c *ComputerClient) Interceptors() []Interceptor {
	return c.inters.Computer
}

func (c *ComputerClient) mutate(ctx context.Context, m *ComputerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ComputerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ComputerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ComputerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ComputerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Computer mutation op: %q", m.Op())
	}
}

// DeploymentClient is a client for the Deployment schema.
type DeploymentClient struct {
	config
}

// NewDeploymentClient returns a client for the Deployment from the given config.
func NewDeploymentClient(c config) *DeploymentClient {
	return &DeploymentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deployment.Hooks(f(g(h())))`.
func (c *DeploymentClient) Use(hooks ...Hook) {
	c.hooks.Deployment = append(c.hooks.Deployment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deployment.Intercept(f(g(h())))`.
func (c *DeploymentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Deployment = append(c.inters.Deployment, interceptors...)
}

// Create returns a builder for creating a Deployment entity.
func (c *DeploymentClient) Create() *DeploymentCreate {
	mutation := newDeploymentMutation(c.config, OpCreate)
	return &DeploymentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Deployment entities.
func (c *DeploymentClient) CreateBulk(builders ...*DeploymentCreate) *DeploymentCreateBulk {
	return &DeploymentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DeploymentClient) MapCreateBulk(slice any, setFunc func(*DeploymentCreate, int)) *DeploymentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DeploymentCreateBulk{err: fmt.Errorf("calling to DeploymentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DeploymentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DeploymentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Deployment.
func (c *DeploymentClient) Update() *DeploymentUpdate {
	mutation := newDeploymentMutation(c.config, OpUpdate)
	return &DeploymentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeploymentClient) UpdateOne(d *Deployment) *DeploymentUpdateOne {
	mutation := newDeploymentMutation(c.config, OpUpdateOne, withDeployment(d))
	return &DeploymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeploymentClient) UpdateOneID(id int) *DeploymentUpdateOne {
	mutation := newDeploymentMutation(c.config, OpUpdateOne, withDeploymentID(id))
	return &DeploymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Deployment.
func (c *DeploymentClient) Delete() *DeploymentDelete {
	mutation := newDeploymentMutation(c.config, OpDelete)
	return &DeploymentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeploymentClient) DeleteOne(d *Deployment) *DeploymentDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeploymentClient) DeleteOneID(id int) *DeploymentDeleteOne {
	builder := c.Delete().Where(deployment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeploymentDeleteOne{builder}
}

// Query returns a query builder for Deployment.
func (c *DeploymentClient) Query() *DeploymentQuery {
	return &DeploymentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeployment},
		inters: c.Interceptors(),
	}
}

// Get returns a Deployment entity by its id.
func (c *DeploymentClient) Get(ctx context.Context, id int) (*Deployment, error) {
	return c.Query().Where(deployment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeploymentClient) GetX(ctx context.Context, id int) *Deployment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Deployment.
func (c *DeploymentClient) QueryOwner(d *Deployment) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deployment.Table, deployment.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, deployment.OwnerTable, deployment.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeploymentClient) Hooks() []Hook {
	return c.hooks.Deployment
}

// Interceptors returns the client interceptors.
func (c *DeploymentClient) Interceptors() []Interceptor {
	return c.inters.Deployment
}

func (c *DeploymentClient) mutate(ctx context.Context, m *DeploymentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeploymentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeploymentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeploymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeploymentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Deployment mutation op: %q", m.Op())
	}
}

// LogicalDiskClient is a client for the LogicalDisk schema.
type LogicalDiskClient struct {
	config
}

// NewLogicalDiskClient returns a client for the LogicalDisk from the given config.
func NewLogicalDiskClient(c config) *LogicalDiskClient {
	return &LogicalDiskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `logicaldisk.Hooks(f(g(h())))`.
func (c *LogicalDiskClient) Use(hooks ...Hook) {
	c.hooks.LogicalDisk = append(c.hooks.LogicalDisk, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `logicaldisk.Intercept(f(g(h())))`.
func (c *LogicalDiskClient) Intercept(interceptors ...Interceptor) {
	c.inters.LogicalDisk = append(c.inters.LogicalDisk, interceptors...)
}

// Create returns a builder for creating a LogicalDisk entity.
func (c *LogicalDiskClient) Create() *LogicalDiskCreate {
	mutation := newLogicalDiskMutation(c.config, OpCreate)
	return &LogicalDiskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LogicalDisk entities.
func (c *LogicalDiskClient) CreateBulk(builders ...*LogicalDiskCreate) *LogicalDiskCreateBulk {
	return &LogicalDiskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LogicalDiskClient) MapCreateBulk(slice any, setFunc func(*LogicalDiskCreate, int)) *LogicalDiskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LogicalDiskCreateBulk{err: fmt.Errorf("calling to LogicalDiskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LogicalDiskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LogicalDiskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LogicalDisk.
func (c *LogicalDiskClient) Update() *LogicalDiskUpdate {
	mutation := newLogicalDiskMutation(c.config, OpUpdate)
	return &LogicalDiskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LogicalDiskClient) UpdateOne(ld *LogicalDisk) *LogicalDiskUpdateOne {
	mutation := newLogicalDiskMutation(c.config, OpUpdateOne, withLogicalDisk(ld))
	return &LogicalDiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LogicalDiskClient) UpdateOneID(id int) *LogicalDiskUpdateOne {
	mutation := newLogicalDiskMutation(c.config, OpUpdateOne, withLogicalDiskID(id))
	return &LogicalDiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LogicalDisk.
func (c *LogicalDiskClient) Delete() *LogicalDiskDelete {
	mutation := newLogicalDiskMutation(c.config, OpDelete)
	return &LogicalDiskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LogicalDiskClient) DeleteOne(ld *LogicalDisk) *LogicalDiskDeleteOne {
	return c.DeleteOneID(ld.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LogicalDiskClient) DeleteOneID(id int) *LogicalDiskDeleteOne {
	builder := c.Delete().Where(logicaldisk.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LogicalDiskDeleteOne{builder}
}

// Query returns a query builder for LogicalDisk.
func (c *LogicalDiskClient) Query() *LogicalDiskQuery {
	return &LogicalDiskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLogicalDisk},
		inters: c.Interceptors(),
	}
}

// Get returns a LogicalDisk entity by its id.
func (c *LogicalDiskClient) Get(ctx context.Context, id int) (*LogicalDisk, error) {
	return c.Query().Where(logicaldisk.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LogicalDiskClient) GetX(ctx context.Context, id int) *LogicalDisk {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a LogicalDisk.
func (c *LogicalDiskClient) QueryOwner(ld *LogicalDisk) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ld.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(logicaldisk.Table, logicaldisk.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, logicaldisk.OwnerTable, logicaldisk.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(ld.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LogicalDiskClient) Hooks() []Hook {
	return c.hooks.LogicalDisk
}

// Interceptors returns the client interceptors.
func (c *LogicalDiskClient) Interceptors() []Interceptor {
	return c.inters.LogicalDisk
}

func (c *LogicalDiskClient) mutate(ctx context.Context, m *LogicalDiskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LogicalDiskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LogicalDiskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LogicalDiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LogicalDiskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LogicalDisk mutation op: %q", m.Op())
	}
}

// MemorySlotClient is a client for the MemorySlot schema.
type MemorySlotClient struct {
	config
}

// NewMemorySlotClient returns a client for the MemorySlot from the given config.
func NewMemorySlotClient(c config) *MemorySlotClient {
	return &MemorySlotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memoryslot.Hooks(f(g(h())))`.
func (c *MemorySlotClient) Use(hooks ...Hook) {
	c.hooks.MemorySlot = append(c.hooks.MemorySlot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memoryslot.Intercept(f(g(h())))`.
func (c *MemorySlotClient) Intercept(interceptors ...Interceptor) {
	c.inters.MemorySlot = append(c.inters.MemorySlot, interceptors...)
}

// Create returns a builder for creating a MemorySlot entity.
func (c *MemorySlotClient) Create() *MemorySlotCreate {
	mutation := newMemorySlotMutation(c.config, OpCreate)
	return &MemorySlotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MemorySlot entities.
func (c *MemorySlotClient) CreateBulk(builders ...*MemorySlotCreate) *MemorySlotCreateBulk {
	return &MemorySlotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MemorySlotClient) MapCreateBulk(slice any, setFunc func(*MemorySlotCreate, int)) *MemorySlotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MemorySlotCreateBulk{err: fmt.Errorf("calling to MemorySlotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MemorySlotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MemorySlotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MemorySlot.
func (c *MemorySlotClient) Update() *MemorySlotUpdate {
	mutation := newMemorySlotMutation(c.config, OpUpdate)
	return &MemorySlotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MemorySlotClient) UpdateOne(ms *MemorySlot) *MemorySlotUpdateOne {
	mutation := newMemorySlotMutation(c.config, OpUpdateOne, withMemorySlot(ms))
	return &MemorySlotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MemorySlotClient) UpdateOneID(id int) *MemorySlotUpdateOne {
	mutation := newMemorySlotMutation(c.config, OpUpdateOne, withMemorySlotID(id))
	return &MemorySlotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MemorySlot.
func (c *MemorySlotClient) Delete() *MemorySlotDelete {
	mutation := newMemorySlotMutation(c.config, OpDelete)
	return &MemorySlotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MemorySlotClient) DeleteOne(ms *MemorySlot) *MemorySlotDeleteOne {
	return c.DeleteOneID(ms.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MemorySlotClient) DeleteOneID(id int) *MemorySlotDeleteOne {
	builder := c.Delete().Where(memoryslot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MemorySlotDeleteOne{builder}
}

// Query returns a query builder for MemorySlot.
func (c *MemorySlotClient) Query() *MemorySlotQuery {
	return &MemorySlotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMemorySlot},
		inters: c.Interceptors(),
	}
}

// Get returns a MemorySlot entity by its id.
func (c *MemorySlotClient) Get(ctx context.Context, id int) (*MemorySlot, error) {
	return c.Query().Where(memoryslot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MemorySlotClient) GetX(ctx context.Context, id int) *MemorySlot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a MemorySlot.
func (c *MemorySlotClient) QueryOwner(ms *MemorySlot) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ms.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memoryslot.Table, memoryslot.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, memoryslot.OwnerTable, memoryslot.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(ms.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MemorySlotClient) Hooks() []Hook {
	return c.hooks.MemorySlot
}

// Interceptors returns the client interceptors.
func (c *MemorySlotClient) Interceptors() []Interceptor {
	return c.inters.MemorySlot
}

func (c *MemorySlotClient) mutate(ctx context.Context, m *MemorySlotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MemorySlotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MemorySlotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MemorySlotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MemorySlotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MemorySlot mutation op: %q", m.Op())
	}
}

// MetadataClient is a client for the Metadata schema.
type MetadataClient struct {
	config
}

// NewMetadataClient returns a client for the Metadata from the given config.
func NewMetadataClient(c config) *MetadataClient {
	return &MetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `metadata.Hooks(f(g(h())))`.
func (c *MetadataClient) Use(hooks ...Hook) {
	c.hooks.Metadata = append(c.hooks.Metadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `metadata.Intercept(f(g(h())))`.
func (c *MetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.Metadata = append(c.inters.Metadata, interceptors...)
}

// Create returns a builder for creating a Metadata entity.
func (c *MetadataClient) Create() *MetadataCreate {
	mutation := newMetadataMutation(c.config, OpCreate)
	return &MetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Metadata entities.
func (c *MetadataClient) CreateBulk(builders ...*MetadataCreate) *MetadataCreateBulk {
	return &MetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MetadataClient) MapCreateBulk(slice any, setFunc func(*MetadataCreate, int)) *MetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MetadataCreateBulk{err: fmt.Errorf("calling to MetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Metadata.
func (c *MetadataClient) Update() *MetadataUpdate {
	mutation := newMetadataMutation(c.config, OpUpdate)
	return &MetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MetadataClient) UpdateOne(m *Metadata) *MetadataUpdateOne {
	mutation := newMetadataMutation(c.config, OpUpdateOne, withMetadata(m))
	return &MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MetadataClient) UpdateOneID(id int) *MetadataUpdateOne {
	mutation := newMetadataMutation(c.config, OpUpdateOne, withMetadataID(id))
	return &MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Metadata.
func (c *MetadataClient) Delete() *MetadataDelete {
	mutation := newMetadataMutation(c.config, OpDelete)
	return &MetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MetadataClient) DeleteOne(m *Metadata) *MetadataDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MetadataClient) DeleteOneID(id int) *MetadataDeleteOne {
	builder := c.Delete().Where(metadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MetadataDeleteOne{builder}
}

// Query returns a query builder for Metadata.
func (c *MetadataClient) Query() *MetadataQuery {
	return &MetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a Metadata entity by its id.
func (c *MetadataClient) Get(ctx context.Context, id int) (*Metadata, error) {
	return c.Query().Where(metadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MetadataClient) GetX(ctx context.Context, id int) *Metadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Metadata.
func (c *MetadataClient) QueryOwner(m *Metadata) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, metadata.OwnerTable, metadata.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrg queries the org edge of a Metadata.
func (c *MetadataClient) QueryOrg(m *Metadata) *OrgMetadataQuery {
	query := (&OrgMetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(orgmetadata.Table, orgmetadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, metadata.OrgTable, metadata.OrgColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MetadataClient) Hooks() []Hook {
	return c.hooks.Metadata
}

// Interceptors returns the client interceptors.
func (c *MetadataClient) Interceptors() []Interceptor {
	return c.inters.Metadata
}

func (c *MetadataClient) mutate(ctx context.Context, m *MetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Metadata mutation op: %q", m.Op())
	}
}

// MonitorClient is a client for the Monitor schema.
type MonitorClient struct {
	config
}

// NewMonitorClient returns a client for the Monitor from the given config.
func NewMonitorClient(c config) *MonitorClient {
	return &MonitorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `monitor.Hooks(f(g(h())))`.
func (c *MonitorClient) Use(hooks ...Hook) {
	c.hooks.Monitor = append(c.hooks.Monitor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `monitor.Intercept(f(g(h())))`.
func (c *MonitorClient) Intercept(interceptors ...Interceptor) {
	c.inters.Monitor = append(c.inters.Monitor, interceptors...)
}

// Create returns a builder for creating a Monitor entity.
func (c *MonitorClient) Create() *MonitorCreate {
	mutation := newMonitorMutation(c.config, OpCreate)
	return &MonitorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Monitor entities.
func (c *MonitorClient) CreateBulk(builders ...*MonitorCreate) *MonitorCreateBulk {
	return &MonitorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MonitorClient) MapCreateBulk(slice any, setFunc func(*MonitorCreate, int)) *MonitorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MonitorCreateBulk{err: fmt.Errorf("calling to MonitorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MonitorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MonitorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Monitor.
func (c *MonitorClient) Update() *MonitorUpdate {
	mutation := newMonitorMutation(c.config, OpUpdate)
	return &MonitorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MonitorClient) UpdateOne(m *Monitor) *MonitorUpdateOne {
	mutation := newMonitorMutation(c.config, OpUpdateOne, withMonitor(m))
	return &MonitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MonitorClient) UpdateOneID(id int) *MonitorUpdateOne {
	mutation := newMonitorMutation(c.config, OpUpdateOne, withMonitorID(id))
	return &MonitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Monitor.
func (c *MonitorClient) Delete() *MonitorDelete {
	mutation := newMonitorMutation(c.config, OpDelete)
	return &MonitorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MonitorClient) DeleteOne(m *Monitor) *MonitorDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MonitorClient) DeleteOneID(id int) *MonitorDeleteOne {
	builder := c.Delete().Where(monitor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MonitorDeleteOne{builder}
}

// Query returns a query builder for Monitor.
func (c *MonitorClient) Query() *MonitorQuery {
	return &MonitorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMonitor},
		inters: c.Interceptors(),
	}
}

// Get returns a Monitor entity by its id.
func (c *MonitorClient) Get(ctx context.Context, id int) (*Monitor, error) {
	return c.Query().Where(monitor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MonitorClient) GetX(ctx context.Context, id int) *Monitor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Monitor.
func (c *MonitorClient) QueryOwner(m *Monitor) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(monitor.Table, monitor.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, monitor.OwnerTable, monitor.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MonitorClient) Hooks() []Hook {
	return c.hooks.Monitor
}

// Interceptors returns the client interceptors.
func (c *MonitorClient) Interceptors() []Interceptor {
	return c.inters.Monitor
}

func (c *MonitorClient) mutate(ctx context.Context, m *MonitorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MonitorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MonitorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MonitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MonitorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Monitor mutation op: %q", m.Op())
	}
}

// NetbirdClient is a client for the Netbird schema.
type NetbirdClient struct {
	config
}

// NewNetbirdClient returns a client for the Netbird from the given config.
func NewNetbirdClient(c config) *NetbirdClient {
	return &NetbirdClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `netbird.Hooks(f(g(h())))`.
func (c *NetbirdClient) Use(hooks ...Hook) {
	c.hooks.Netbird = append(c.hooks.Netbird, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `netbird.Intercept(f(g(h())))`.
func (c *NetbirdClient) Intercept(interceptors ...Interceptor) {
	c.inters.Netbird = append(c.inters.Netbird, interceptors...)
}

// Create returns a builder for creating a Netbird entity.
func (c *NetbirdClient) Create() *NetbirdCreate {
	mutation := newNetbirdMutation(c.config, OpCreate)
	return &NetbirdCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Netbird entities.
func (c *NetbirdClient) CreateBulk(builders ...*NetbirdCreate) *NetbirdCreateBulk {
	return &NetbirdCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NetbirdClient) MapCreateBulk(slice any, setFunc func(*NetbirdCreate, int)) *NetbirdCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NetbirdCreateBulk{err: fmt.Errorf("calling to NetbirdClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NetbirdCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NetbirdCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Netbird.
func (c *NetbirdClient) Update() *NetbirdUpdate {
	mutation := newNetbirdMutation(c.config, OpUpdate)
	return &NetbirdUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetbirdClient) UpdateOne(n *Netbird) *NetbirdUpdateOne {
	mutation := newNetbirdMutation(c.config, OpUpdateOne, withNetbird(n))
	return &NetbirdUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetbirdClient) UpdateOneID(id int) *NetbirdUpdateOne {
	mutation := newNetbirdMutation(c.config, OpUpdateOne, withNetbirdID(id))
	return &NetbirdUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Netbird.
func (c *NetbirdClient) Delete() *NetbirdDelete {
	mutation := newNetbirdMutation(c.config, OpDelete)
	return &NetbirdDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NetbirdClient) DeleteOne(n *Netbird) *NetbirdDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NetbirdClient) DeleteOneID(id int) *NetbirdDeleteOne {
	builder := c.Delete().Where(netbird.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetbirdDeleteOne{builder}
}

// Query returns a query builder for Netbird.
func (c *NetbirdClient) Query() *NetbirdQuery {
	return &NetbirdQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNetbird},
		inters: c.Interceptors(),
	}
}

// Get returns a Netbird entity by its id.
func (c *NetbirdClient) Get(ctx context.Context, id int) (*Netbird, error) {
	return c.Query().Where(netbird.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetbirdClient) GetX(ctx context.Context, id int) *Netbird {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Netbird.
func (c *NetbirdClient) QueryOwner(n *Netbird) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(netbird.Table, netbird.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, netbird.OwnerTable, netbird.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetbirdClient) Hooks() []Hook {
	return c.hooks.Netbird
}

// Interceptors returns the client interceptors.
func (c *NetbirdClient) Interceptors() []Interceptor {
	return c.inters.Netbird
}

func (c *NetbirdClient) mutate(ctx context.Context, m *NetbirdMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NetbirdCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NetbirdUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NetbirdUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NetbirdDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Netbird mutation op: %q", m.Op())
	}
}

// NetbirdSettingsClient is a client for the NetbirdSettings schema.
type NetbirdSettingsClient struct {
	config
}

// NewNetbirdSettingsClient returns a client for the NetbirdSettings from the given config.
func NewNetbirdSettingsClient(c config) *NetbirdSettingsClient {
	return &NetbirdSettingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `netbirdsettings.Hooks(f(g(h())))`.
func (c *NetbirdSettingsClient) Use(hooks ...Hook) {
	c.hooks.NetbirdSettings = append(c.hooks.NetbirdSettings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `netbirdsettings.Intercept(f(g(h())))`.
func (c *NetbirdSettingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.NetbirdSettings = append(c.inters.NetbirdSettings, interceptors...)
}

// Create returns a builder for creating a NetbirdSettings entity.
func (c *NetbirdSettingsClient) Create() *NetbirdSettingsCreate {
	mutation := newNetbirdSettingsMutation(c.config, OpCreate)
	return &NetbirdSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NetbirdSettings entities.
func (c *NetbirdSettingsClient) CreateBulk(builders ...*NetbirdSettingsCreate) *NetbirdSettingsCreateBulk {
	return &NetbirdSettingsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NetbirdSettingsClient) MapCreateBulk(slice any, setFunc func(*NetbirdSettingsCreate, int)) *NetbirdSettingsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NetbirdSettingsCreateBulk{err: fmt.Errorf("calling to NetbirdSettingsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NetbirdSettingsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NetbirdSettingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NetbirdSettings.
func (c *NetbirdSettingsClient) Update() *NetbirdSettingsUpdate {
	mutation := newNetbirdSettingsMutation(c.config, OpUpdate)
	return &NetbirdSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetbirdSettingsClient) UpdateOne(ns *NetbirdSettings) *NetbirdSettingsUpdateOne {
	mutation := newNetbirdSettingsMutation(c.config, OpUpdateOne, withNetbirdSettings(ns))
	return &NetbirdSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetbirdSettingsClient) UpdateOneID(id int) *NetbirdSettingsUpdateOne {
	mutation := newNetbirdSettingsMutation(c.config, OpUpdateOne, withNetbirdSettingsID(id))
	return &NetbirdSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NetbirdSettings.
func (c *NetbirdSettingsClient) Delete() *NetbirdSettingsDelete {
	mutation := newNetbirdSettingsMutation(c.config, OpDelete)
	return &NetbirdSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NetbirdSettingsClient) DeleteOne(ns *NetbirdSettings) *NetbirdSettingsDeleteOne {
	return c.DeleteOneID(ns.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NetbirdSettingsClient) DeleteOneID(id int) *NetbirdSettingsDeleteOne {
	builder := c.Delete().Where(netbirdsettings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetbirdSettingsDeleteOne{builder}
}

// Query returns a query builder for NetbirdSettings.
func (c *NetbirdSettingsClient) Query() *NetbirdSettingsQuery {
	return &NetbirdSettingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNetbirdSettings},
		inters: c.Interceptors(),
	}
}

// Get returns a NetbirdSettings entity by its id.
func (c *NetbirdSettingsClient) Get(ctx context.Context, id int) (*NetbirdSettings, error) {
	return c.Query().Where(netbirdsettings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetbirdSettingsClient) GetX(ctx context.Context, id int) *NetbirdSettings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a NetbirdSettings.
func (c *NetbirdSettingsClient) QueryTenant(ns *NetbirdSettings) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ns.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(netbirdsettings.Table, netbirdsettings.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, netbirdsettings.TenantTable, netbirdsettings.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(ns.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetbirdSettingsClient) Hooks() []Hook {
	return c.hooks.NetbirdSettings
}

// Interceptors returns the client interceptors.
func (c *NetbirdSettingsClient) Interceptors() []Interceptor {
	return c.inters.NetbirdSettings
}

func (c *NetbirdSettingsClient) mutate(ctx context.Context, m *NetbirdSettingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NetbirdSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NetbirdSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NetbirdSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NetbirdSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NetbirdSettings mutation op: %q", m.Op())
	}
}

// NetworkAdapterClient is a client for the NetworkAdapter schema.
type NetworkAdapterClient struct {
	config
}

// NewNetworkAdapterClient returns a client for the NetworkAdapter from the given config.
func NewNetworkAdapterClient(c config) *NetworkAdapterClient {
	return &NetworkAdapterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `networkadapter.Hooks(f(g(h())))`.
func (c *NetworkAdapterClient) Use(hooks ...Hook) {
	c.hooks.NetworkAdapter = append(c.hooks.NetworkAdapter, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `networkadapter.Intercept(f(g(h())))`.
func (c *NetworkAdapterClient) Intercept(interceptors ...Interceptor) {
	c.inters.NetworkAdapter = append(c.inters.NetworkAdapter, interceptors...)
}

// Create returns a builder for creating a NetworkAdapter entity.
func (c *NetworkAdapterClient) Create() *NetworkAdapterCreate {
	mutation := newNetworkAdapterMutation(c.config, OpCreate)
	return &NetworkAdapterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NetworkAdapter entities.
func (c *NetworkAdapterClient) CreateBulk(builders ...*NetworkAdapterCreate) *NetworkAdapterCreateBulk {
	return &NetworkAdapterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NetworkAdapterClient) MapCreateBulk(slice any, setFunc func(*NetworkAdapterCreate, int)) *NetworkAdapterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NetworkAdapterCreateBulk{err: fmt.Errorf("calling to NetworkAdapterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NetworkAdapterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NetworkAdapterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NetworkAdapter.
func (c *NetworkAdapterClient) Update() *NetworkAdapterUpdate {
	mutation := newNetworkAdapterMutation(c.config, OpUpdate)
	return &NetworkAdapterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetworkAdapterClient) UpdateOne(na *NetworkAdapter) *NetworkAdapterUpdateOne {
	mutation := newNetworkAdapterMutation(c.config, OpUpdateOne, withNetworkAdapter(na))
	return &NetworkAdapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetworkAdapterClient) UpdateOneID(id int) *NetworkAdapterUpdateOne {
	mutation := newNetworkAdapterMutation(c.config, OpUpdateOne, withNetworkAdapterID(id))
	return &NetworkAdapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NetworkAdapter.
func (c *NetworkAdapterClient) Delete() *NetworkAdapterDelete {
	mutation := newNetworkAdapterMutation(c.config, OpDelete)
	return &NetworkAdapterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NetworkAdapterClient) DeleteOne(na *NetworkAdapter) *NetworkAdapterDeleteOne {
	return c.DeleteOneID(na.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NetworkAdapterClient) DeleteOneID(id int) *NetworkAdapterDeleteOne {
	builder := c.Delete().Where(networkadapter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetworkAdapterDeleteOne{builder}
}

// Query returns a query builder for NetworkAdapter.
func (c *NetworkAdapterClient) Query() *NetworkAdapterQuery {
	return &NetworkAdapterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNetworkAdapter},
		inters: c.Interceptors(),
	}
}

// Get returns a NetworkAdapter entity by its id.
func (c *NetworkAdapterClient) Get(ctx context.Context, id int) (*NetworkAdapter, error) {
	return c.Query().Where(networkadapter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetworkAdapterClient) GetX(ctx context.Context, id int) *NetworkAdapter {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a NetworkAdapter.
func (c *NetworkAdapterClient) QueryOwner(na *NetworkAdapter) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := na.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(networkadapter.Table, networkadapter.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, networkadapter.OwnerTable, networkadapter.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(na.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetworkAdapterClient) Hooks() []Hook {
	return c.hooks.NetworkAdapter
}

// Interceptors returns the client interceptors.
func (c *NetworkAdapterClient) Interceptors() []Interceptor {
	return c.inters.NetworkAdapter
}

func (c *NetworkAdapterClient) mutate(ctx context.Context, m *NetworkAdapterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NetworkAdapterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NetworkAdapterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NetworkAdapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NetworkAdapterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NetworkAdapter mutation op: %q", m.Op())
	}
}

// OperatingSystemClient is a client for the OperatingSystem schema.
type OperatingSystemClient struct {
	config
}

// NewOperatingSystemClient returns a client for the OperatingSystem from the given config.
func NewOperatingSystemClient(c config) *OperatingSystemClient {
	return &OperatingSystemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `operatingsystem.Hooks(f(g(h())))`.
func (c *OperatingSystemClient) Use(hooks ...Hook) {
	c.hooks.OperatingSystem = append(c.hooks.OperatingSystem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `operatingsystem.Intercept(f(g(h())))`.
func (c *OperatingSystemClient) Intercept(interceptors ...Interceptor) {
	c.inters.OperatingSystem = append(c.inters.OperatingSystem, interceptors...)
}

// Create returns a builder for creating a OperatingSystem entity.
func (c *OperatingSystemClient) Create() *OperatingSystemCreate {
	mutation := newOperatingSystemMutation(c.config, OpCreate)
	return &OperatingSystemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OperatingSystem entities.
func (c *OperatingSystemClient) CreateBulk(builders ...*OperatingSystemCreate) *OperatingSystemCreateBulk {
	return &OperatingSystemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OperatingSystemClient) MapCreateBulk(slice any, setFunc func(*OperatingSystemCreate, int)) *OperatingSystemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OperatingSystemCreateBulk{err: fmt.Errorf("calling to OperatingSystemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OperatingSystemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OperatingSystemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OperatingSystem.
func (c *OperatingSystemClient) Update() *OperatingSystemUpdate {
	mutation := newOperatingSystemMutation(c.config, OpUpdate)
	return &OperatingSystemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OperatingSystemClient) UpdateOne(os *OperatingSystem) *OperatingSystemUpdateOne {
	mutation := newOperatingSystemMutation(c.config, OpUpdateOne, withOperatingSystem(os))
	return &OperatingSystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OperatingSystemClient) UpdateOneID(id int) *OperatingSystemUpdateOne {
	mutation := newOperatingSystemMutation(c.config, OpUpdateOne, withOperatingSystemID(id))
	return &OperatingSystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OperatingSystem.
func (c *OperatingSystemClient) Delete() *OperatingSystemDelete {
	mutation := newOperatingSystemMutation(c.config, OpDelete)
	return &OperatingSystemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OperatingSystemClient) DeleteOne(os *OperatingSystem) *OperatingSystemDeleteOne {
	return c.DeleteOneID(os.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OperatingSystemClient) DeleteOneID(id int) *OperatingSystemDeleteOne {
	builder := c.Delete().Where(operatingsystem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OperatingSystemDeleteOne{builder}
}

// Query returns a query builder for OperatingSystem.
func (c *OperatingSystemClient) Query() *OperatingSystemQuery {
	return &OperatingSystemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOperatingSystem},
		inters: c.Interceptors(),
	}
}

// Get returns a OperatingSystem entity by its id.
func (c *OperatingSystemClient) Get(ctx context.Context, id int) (*OperatingSystem, error) {
	return c.Query().Where(operatingsystem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OperatingSystemClient) GetX(ctx context.Context, id int) *OperatingSystem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a OperatingSystem.
func (c *OperatingSystemClient) QueryOwner(os *OperatingSystem) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := os.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(operatingsystem.Table, operatingsystem.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, operatingsystem.OwnerTable, operatingsystem.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(os.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OperatingSystemClient) Hooks() []Hook {
	return c.hooks.OperatingSystem
}

// Interceptors returns the client interceptors.
func (c *OperatingSystemClient) Interceptors() []Interceptor {
	return c.inters.OperatingSystem
}

func (c *OperatingSystemClient) mutate(ctx context.Context, m *OperatingSystemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OperatingSystemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OperatingSystemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OperatingSystemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OperatingSystemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OperatingSystem mutation op: %q", m.Op())
	}
}

// OrgMetadataClient is a client for the OrgMetadata schema.
type OrgMetadataClient struct {
	config
}

// NewOrgMetadataClient returns a client for the OrgMetadata from the given config.
func NewOrgMetadataClient(c config) *OrgMetadataClient {
	return &OrgMetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orgmetadata.Hooks(f(g(h())))`.
func (c *OrgMetadataClient) Use(hooks ...Hook) {
	c.hooks.OrgMetadata = append(c.hooks.OrgMetadata, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orgmetadata.Intercept(f(g(h())))`.
func (c *OrgMetadataClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrgMetadata = append(c.inters.OrgMetadata, interceptors...)
}

// Create returns a builder for creating a OrgMetadata entity.
func (c *OrgMetadataClient) Create() *OrgMetadataCreate {
	mutation := newOrgMetadataMutation(c.config, OpCreate)
	return &OrgMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrgMetadata entities.
func (c *OrgMetadataClient) CreateBulk(builders ...*OrgMetadataCreate) *OrgMetadataCreateBulk {
	return &OrgMetadataCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrgMetadataClient) MapCreateBulk(slice any, setFunc func(*OrgMetadataCreate, int)) *OrgMetadataCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrgMetadataCreateBulk{err: fmt.Errorf("calling to OrgMetadataClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrgMetadataCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrgMetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrgMetadata.
func (c *OrgMetadataClient) Update() *OrgMetadataUpdate {
	mutation := newOrgMetadataMutation(c.config, OpUpdate)
	return &OrgMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrgMetadataClient) UpdateOne(om *OrgMetadata) *OrgMetadataUpdateOne {
	mutation := newOrgMetadataMutation(c.config, OpUpdateOne, withOrgMetadata(om))
	return &OrgMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrgMetadataClient) UpdateOneID(id int) *OrgMetadataUpdateOne {
	mutation := newOrgMetadataMutation(c.config, OpUpdateOne, withOrgMetadataID(id))
	return &OrgMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrgMetadata.
func (c *OrgMetadataClient) Delete() *OrgMetadataDelete {
	mutation := newOrgMetadataMutation(c.config, OpDelete)
	return &OrgMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrgMetadataClient) DeleteOne(om *OrgMetadata) *OrgMetadataDeleteOne {
	return c.DeleteOneID(om.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrgMetadataClient) DeleteOneID(id int) *OrgMetadataDeleteOne {
	builder := c.Delete().Where(orgmetadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrgMetadataDeleteOne{builder}
}

// Query returns a query builder for OrgMetadata.
func (c *OrgMetadataClient) Query() *OrgMetadataQuery {
	return &OrgMetadataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrgMetadata},
		inters: c.Interceptors(),
	}
}

// Get returns a OrgMetadata entity by its id.
func (c *OrgMetadataClient) Get(ctx context.Context, id int) (*OrgMetadata, error) {
	return c.Query().Where(orgmetadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrgMetadataClient) GetX(ctx context.Context, id int) *OrgMetadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetadata queries the metadata edge of a OrgMetadata.
func (c *OrgMetadataClient) QueryMetadata(om *OrgMetadata) *MetadataQuery {
	query := (&MetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := om.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmetadata.Table, orgmetadata.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, orgmetadata.MetadataTable, orgmetadata.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(om.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a OrgMetadata.
func (c *OrgMetadataClient) QueryTenant(om *OrgMetadata) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := om.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orgmetadata.Table, orgmetadata.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, orgmetadata.TenantTable, orgmetadata.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(om.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrgMetadataClient) Hooks() []Hook {
	return c.hooks.OrgMetadata
}

// Interceptors returns the client interceptors.
func (c *OrgMetadataClient) Interceptors() []Interceptor {
	return c.inters.OrgMetadata
}

func (c *OrgMetadataClient) mutate(ctx context.Context, m *OrgMetadataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrgMetadataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrgMetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrgMetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrgMetadataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrgMetadata mutation op: %q", m.Op())
	}
}

// PhysicalDiskClient is a client for the PhysicalDisk schema.
type PhysicalDiskClient struct {
	config
}

// NewPhysicalDiskClient returns a client for the PhysicalDisk from the given config.
func NewPhysicalDiskClient(c config) *PhysicalDiskClient {
	return &PhysicalDiskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `physicaldisk.Hooks(f(g(h())))`.
func (c *PhysicalDiskClient) Use(hooks ...Hook) {
	c.hooks.PhysicalDisk = append(c.hooks.PhysicalDisk, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `physicaldisk.Intercept(f(g(h())))`.
func (c *PhysicalDiskClient) Intercept(interceptors ...Interceptor) {
	c.inters.PhysicalDisk = append(c.inters.PhysicalDisk, interceptors...)
}

// Create returns a builder for creating a PhysicalDisk entity.
func (c *PhysicalDiskClient) Create() *PhysicalDiskCreate {
	mutation := newPhysicalDiskMutation(c.config, OpCreate)
	return &PhysicalDiskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PhysicalDisk entities.
func (c *PhysicalDiskClient) CreateBulk(builders ...*PhysicalDiskCreate) *PhysicalDiskCreateBulk {
	return &PhysicalDiskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PhysicalDiskClient) MapCreateBulk(slice any, setFunc func(*PhysicalDiskCreate, int)) *PhysicalDiskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PhysicalDiskCreateBulk{err: fmt.Errorf("calling to PhysicalDiskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PhysicalDiskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PhysicalDiskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PhysicalDisk.
func (c *PhysicalDiskClient) Update() *PhysicalDiskUpdate {
	mutation := newPhysicalDiskMutation(c.config, OpUpdate)
	return &PhysicalDiskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PhysicalDiskClient) UpdateOne(pd *PhysicalDisk) *PhysicalDiskUpdateOne {
	mutation := newPhysicalDiskMutation(c.config, OpUpdateOne, withPhysicalDisk(pd))
	return &PhysicalDiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PhysicalDiskClient) UpdateOneID(id int) *PhysicalDiskUpdateOne {
	mutation := newPhysicalDiskMutation(c.config, OpUpdateOne, withPhysicalDiskID(id))
	return &PhysicalDiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PhysicalDisk.
func (c *PhysicalDiskClient) Delete() *PhysicalDiskDelete {
	mutation := newPhysicalDiskMutation(c.config, OpDelete)
	return &PhysicalDiskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PhysicalDiskClient) DeleteOne(pd *PhysicalDisk) *PhysicalDiskDeleteOne {
	return c.DeleteOneID(pd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PhysicalDiskClient) DeleteOneID(id int) *PhysicalDiskDeleteOne {
	builder := c.Delete().Where(physicaldisk.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PhysicalDiskDeleteOne{builder}
}

// Query returns a query builder for PhysicalDisk.
func (c *PhysicalDiskClient) Query() *PhysicalDiskQuery {
	return &PhysicalDiskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePhysicalDisk},
		inters: c.Interceptors(),
	}
}

// Get returns a PhysicalDisk entity by its id.
func (c *PhysicalDiskClient) Get(ctx context.Context, id int) (*PhysicalDisk, error) {
	return c.Query().Where(physicaldisk.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PhysicalDiskClient) GetX(ctx context.Context, id int) *PhysicalDisk {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a PhysicalDisk.
func (c *PhysicalDiskClient) QueryOwner(pd *PhysicalDisk) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(physicaldisk.Table, physicaldisk.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, physicaldisk.OwnerTable, physicaldisk.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(pd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PhysicalDiskClient) Hooks() []Hook {
	return c.hooks.PhysicalDisk
}

// Interceptors returns the client interceptors.
func (c *PhysicalDiskClient) Interceptors() []Interceptor {
	return c.inters.PhysicalDisk
}

func (c *PhysicalDiskClient) mutate(ctx context.Context, m *PhysicalDiskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PhysicalDiskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PhysicalDiskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PhysicalDiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PhysicalDiskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PhysicalDisk mutation op: %q", m.Op())
	}
}

// PrinterClient is a client for the Printer schema.
type PrinterClient struct {
	config
}

// NewPrinterClient returns a client for the Printer from the given config.
func NewPrinterClient(c config) *PrinterClient {
	return &PrinterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `printer.Hooks(f(g(h())))`.
func (c *PrinterClient) Use(hooks ...Hook) {
	c.hooks.Printer = append(c.hooks.Printer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `printer.Intercept(f(g(h())))`.
func (c *PrinterClient) Intercept(interceptors ...Interceptor) {
	c.inters.Printer = append(c.inters.Printer, interceptors...)
}

// Create returns a builder for creating a Printer entity.
func (c *PrinterClient) Create() *PrinterCreate {
	mutation := newPrinterMutation(c.config, OpCreate)
	return &PrinterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Printer entities.
func (c *PrinterClient) CreateBulk(builders ...*PrinterCreate) *PrinterCreateBulk {
	return &PrinterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PrinterClient) MapCreateBulk(slice any, setFunc func(*PrinterCreate, int)) *PrinterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PrinterCreateBulk{err: fmt.Errorf("calling to PrinterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PrinterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PrinterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Printer.
func (c *PrinterClient) Update() *PrinterUpdate {
	mutation := newPrinterMutation(c.config, OpUpdate)
	return &PrinterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PrinterClient) UpdateOne(pr *Printer) *PrinterUpdateOne {
	mutation := newPrinterMutation(c.config, OpUpdateOne, withPrinter(pr))
	return &PrinterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PrinterClient) UpdateOneID(id int) *PrinterUpdateOne {
	mutation := newPrinterMutation(c.config, OpUpdateOne, withPrinterID(id))
	return &PrinterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Printer.
func (c *PrinterClient) Delete() *PrinterDelete {
	mutation := newPrinterMutation(c.config, OpDelete)
	return &PrinterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PrinterClient) DeleteOne(pr *Printer) *PrinterDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PrinterClient) DeleteOneID(id int) *PrinterDeleteOne {
	builder := c.Delete().Where(printer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PrinterDeleteOne{builder}
}

// Query returns a query builder for Printer.
func (c *PrinterClient) Query() *PrinterQuery {
	return &PrinterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrinter},
		inters: c.Interceptors(),
	}
}

// Get returns a Printer entity by its id.
func (c *PrinterClient) Get(ctx context.Context, id int) (*Printer, error) {
	return c.Query().Where(printer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PrinterClient) GetX(ctx context.Context, id int) *Printer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Printer.
func (c *PrinterClient) QueryOwner(pr *Printer) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(printer.Table, printer.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, printer.OwnerTable, printer.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PrinterClient) Hooks() []Hook {
	return c.hooks.Printer
}

// Interceptors returns the client interceptors.
func (c *PrinterClient) Interceptors() []Interceptor {
	return c.inters.Printer
}

func (c *PrinterClient) mutate(ctx context.Context, m *PrinterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PrinterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PrinterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PrinterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PrinterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Printer mutation op: %q", m.Op())
	}
}

// ProfileClient is a client for the Profile schema.
type ProfileClient struct {
	config
}

// NewProfileClient returns a client for the Profile from the given config.
func NewProfileClient(c config) *ProfileClient {
	return &ProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profile.Hooks(f(g(h())))`.
func (c *ProfileClient) Use(hooks ...Hook) {
	c.hooks.Profile = append(c.hooks.Profile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profile.Intercept(f(g(h())))`.
func (c *ProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.Profile = append(c.inters.Profile, interceptors...)
}

// Create returns a builder for creating a Profile entity.
func (c *ProfileClient) Create() *ProfileCreate {
	mutation := newProfileMutation(c.config, OpCreate)
	return &ProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Profile entities.
func (c *ProfileClient) CreateBulk(builders ...*ProfileCreate) *ProfileCreateBulk {
	return &ProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfileClient) MapCreateBulk(slice any, setFunc func(*ProfileCreate, int)) *ProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfileCreateBulk{err: fmt.Errorf("calling to ProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Profile.
func (c *ProfileClient) Update() *ProfileUpdate {
	mutation := newProfileMutation(c.config, OpUpdate)
	return &ProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfileClient) UpdateOne(pr *Profile) *ProfileUpdateOne {
	mutation := newProfileMutation(c.config, OpUpdateOne, withProfile(pr))
	return &ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfileClient) UpdateOneID(id int) *ProfileUpdateOne {
	mutation := newProfileMutation(c.config, OpUpdateOne, withProfileID(id))
	return &ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Profile.
func (c *ProfileClient) Delete() *ProfileDelete {
	mutation := newProfileMutation(c.config, OpDelete)
	return &ProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfileClient) DeleteOne(pr *Profile) *ProfileDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfileClient) DeleteOneID(id int) *ProfileDeleteOne {
	builder := c.Delete().Where(profile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfileDeleteOne{builder}
}

// Query returns a query builder for Profile.
func (c *ProfileClient) Query() *ProfileQuery {
	return &ProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a Profile entity by its id.
func (c *ProfileClient) Get(ctx context.Context, id int) (*Profile, error) {
	return c.Query().Where(profile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfileClient) GetX(ctx context.Context, id int) *Profile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTags queries the tags edge of a Profile.
func (c *ProfileClient) QueryTags(pr *Profile) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, profile.TagsTable, profile.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Profile.
func (c *ProfileClient) QueryTasks(pr *Profile) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.TasksTable, profile.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIssues queries the issues edge of a Profile.
func (c *ProfileClient) QueryIssues(pr *Profile) *ProfileIssueQuery {
	query := (&ProfileIssueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(profileissue.Table, profileissue.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, profile.IssuesTable, profile.IssuesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySite queries the site edge of a Profile.
func (c *ProfileClient) QuerySite(pr *Profile) *SiteQuery {
	query := (&SiteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(site.Table, site.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, profile.SiteTable, profile.SiteColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfileClient) Hooks() []Hook {
	return c.hooks.Profile
}

// Interceptors returns the client interceptors.
func (c *ProfileClient) Interceptors() []Interceptor {
	return c.inters.Profile
}

func (c *ProfileClient) mutate(ctx context.Context, m *ProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Profile mutation op: %q", m.Op())
	}
}

// ProfileIssueClient is a client for the ProfileIssue schema.
type ProfileIssueClient struct {
	config
}

// NewProfileIssueClient returns a client for the ProfileIssue from the given config.
func NewProfileIssueClient(c config) *ProfileIssueClient {
	return &ProfileIssueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profileissue.Hooks(f(g(h())))`.
func (c *ProfileIssueClient) Use(hooks ...Hook) {
	c.hooks.ProfileIssue = append(c.hooks.ProfileIssue, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profileissue.Intercept(f(g(h())))`.
func (c *ProfileIssueClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProfileIssue = append(c.inters.ProfileIssue, interceptors...)
}

// Create returns a builder for creating a ProfileIssue entity.
func (c *ProfileIssueClient) Create() *ProfileIssueCreate {
	mutation := newProfileIssueMutation(c.config, OpCreate)
	return &ProfileIssueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProfileIssue entities.
func (c *ProfileIssueClient) CreateBulk(builders ...*ProfileIssueCreate) *ProfileIssueCreateBulk {
	return &ProfileIssueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfileIssueClient) MapCreateBulk(slice any, setFunc func(*ProfileIssueCreate, int)) *ProfileIssueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfileIssueCreateBulk{err: fmt.Errorf("calling to ProfileIssueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfileIssueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfileIssueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProfileIssue.
func (c *ProfileIssueClient) Update() *ProfileIssueUpdate {
	mutation := newProfileIssueMutation(c.config, OpUpdate)
	return &ProfileIssueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfileIssueClient) UpdateOne(pi *ProfileIssue) *ProfileIssueUpdateOne {
	mutation := newProfileIssueMutation(c.config, OpUpdateOne, withProfileIssue(pi))
	return &ProfileIssueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfileIssueClient) UpdateOneID(id int) *ProfileIssueUpdateOne {
	mutation := newProfileIssueMutation(c.config, OpUpdateOne, withProfileIssueID(id))
	return &ProfileIssueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProfileIssue.
func (c *ProfileIssueClient) Delete() *ProfileIssueDelete {
	mutation := newProfileIssueMutation(c.config, OpDelete)
	return &ProfileIssueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfileIssueClient) DeleteOne(pi *ProfileIssue) *ProfileIssueDeleteOne {
	return c.DeleteOneID(pi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfileIssueClient) DeleteOneID(id int) *ProfileIssueDeleteOne {
	builder := c.Delete().Where(profileissue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfileIssueDeleteOne{builder}
}

// Query returns a query builder for ProfileIssue.
func (c *ProfileIssueClient) Query() *ProfileIssueQuery {
	return &ProfileIssueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfileIssue},
		inters: c.Interceptors(),
	}
}

// Get returns a ProfileIssue entity by its id.
func (c *ProfileIssueClient) Get(ctx context.Context, id int) (*ProfileIssue, error) {
	return c.Query().Where(profileissue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfileIssueClient) GetX(ctx context.Context, id int) *ProfileIssue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a ProfileIssue.
func (c *ProfileIssueClient) QueryProfile(pi *ProfileIssue) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profileissue.Table, profileissue.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, profileissue.ProfileTable, profileissue.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgents queries the agents edge of a ProfileIssue.
func (c *ProfileIssueClient) QueryAgents(pi *ProfileIssue) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profileissue.Table, profileissue.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, profileissue.AgentsTable, profileissue.AgentsColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasksreports queries the tasksreports edge of a ProfileIssue.
func (c *ProfileIssueClient) QueryTasksreports(pi *ProfileIssue) *TaskReportQuery {
	query := (&TaskReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profileissue.Table, profileissue.FieldID, id),
			sqlgraph.To(taskreport.Table, taskreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, profileissue.TasksreportsTable, profileissue.TasksreportsColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfileIssueClient) Hooks() []Hook {
	return c.hooks.ProfileIssue
}

// Interceptors returns the client interceptors.
func (c *ProfileIssueClient) Interceptors() []Interceptor {
	return c.inters.ProfileIssue
}

func (c *ProfileIssueClient) mutate(ctx context.Context, m *ProfileIssueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfileIssueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfileIssueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfileIssueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfileIssueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProfileIssue mutation op: %q", m.Op())
	}
}

// RecoveryCodeClient is a client for the RecoveryCode schema.
type RecoveryCodeClient struct {
	config
}

// NewRecoveryCodeClient returns a client for the RecoveryCode from the given config.
func NewRecoveryCodeClient(c config) *RecoveryCodeClient {
	return &RecoveryCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `recoverycode.Hooks(f(g(h())))`.
func (c *RecoveryCodeClient) Use(hooks ...Hook) {
	c.hooks.RecoveryCode = append(c.hooks.RecoveryCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `recoverycode.Intercept(f(g(h())))`.
func (c *RecoveryCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.RecoveryCode = append(c.inters.RecoveryCode, interceptors...)
}

// Create returns a builder for creating a RecoveryCode entity.
func (c *RecoveryCodeClient) Create() *RecoveryCodeCreate {
	mutation := newRecoveryCodeMutation(c.config, OpCreate)
	return &RecoveryCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RecoveryCode entities.
func (c *RecoveryCodeClient) CreateBulk(builders ...*RecoveryCodeCreate) *RecoveryCodeCreateBulk {
	return &RecoveryCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RecoveryCodeClient) MapCreateBulk(slice any, setFunc func(*RecoveryCodeCreate, int)) *RecoveryCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RecoveryCodeCreateBulk{err: fmt.Errorf("calling to RecoveryCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RecoveryCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RecoveryCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RecoveryCode.
func (c *RecoveryCodeClient) Update() *RecoveryCodeUpdate {
	mutation := newRecoveryCodeMutation(c.config, OpUpdate)
	return &RecoveryCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RecoveryCodeClient) UpdateOne(rc *RecoveryCode) *RecoveryCodeUpdateOne {
	mutation := newRecoveryCodeMutation(c.config, OpUpdateOne, withRecoveryCode(rc))
	return &RecoveryCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RecoveryCodeClient) UpdateOneID(id int) *RecoveryCodeUpdateOne {
	mutation := newRecoveryCodeMutation(c.config, OpUpdateOne, withRecoveryCodeID(id))
	return &RecoveryCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RecoveryCode.
func (c *RecoveryCodeClient) Delete() *RecoveryCodeDelete {
	mutation := newRecoveryCodeMutation(c.config, OpDelete)
	return &RecoveryCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RecoveryCodeClient) DeleteOne(rc *RecoveryCode) *RecoveryCodeDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RecoveryCodeClient) DeleteOneID(id int) *RecoveryCodeDeleteOne {
	builder := c.Delete().Where(recoverycode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RecoveryCodeDeleteOne{builder}
}

// Query returns a query builder for RecoveryCode.
func (c *RecoveryCodeClient) Query() *RecoveryCodeQuery {
	return &RecoveryCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRecoveryCode},
		inters: c.Interceptors(),
	}
}

// Get returns a RecoveryCode entity by its id.
func (c *RecoveryCodeClient) Get(ctx context.Context, id int) (*RecoveryCode, error) {
	return c.Query().Where(recoverycode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RecoveryCodeClient) GetX(ctx context.Context, id int) *RecoveryCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a RecoveryCode.
func (c *RecoveryCodeClient) QueryUser(rc *RecoveryCode) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(recoverycode.Table, recoverycode.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, recoverycode.UserTable, recoverycode.UserColumn),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RecoveryCodeClient) Hooks() []Hook {
	return c.hooks.RecoveryCode
}

// Interceptors returns the client interceptors.
func (c *RecoveryCodeClient) Interceptors() []Interceptor {
	return c.inters.RecoveryCode
}

func (c *RecoveryCodeClient) mutate(ctx context.Context, m *RecoveryCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RecoveryCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RecoveryCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RecoveryCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RecoveryCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RecoveryCode mutation op: %q", m.Op())
	}
}

// ReleaseClient is a client for the Release schema.
type ReleaseClient struct {
	config
}

// NewReleaseClient returns a client for the Release from the given config.
func NewReleaseClient(c config) *ReleaseClient {
	return &ReleaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `release.Hooks(f(g(h())))`.
func (c *ReleaseClient) Use(hooks ...Hook) {
	c.hooks.Release = append(c.hooks.Release, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `release.Intercept(f(g(h())))`.
func (c *ReleaseClient) Intercept(interceptors ...Interceptor) {
	c.inters.Release = append(c.inters.Release, interceptors...)
}

// Create returns a builder for creating a Release entity.
func (c *ReleaseClient) Create() *ReleaseCreate {
	mutation := newReleaseMutation(c.config, OpCreate)
	return &ReleaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Release entities.
func (c *ReleaseClient) CreateBulk(builders ...*ReleaseCreate) *ReleaseCreateBulk {
	return &ReleaseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReleaseClient) MapCreateBulk(slice any, setFunc func(*ReleaseCreate, int)) *ReleaseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReleaseCreateBulk{err: fmt.Errorf("calling to ReleaseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReleaseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReleaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Release.
func (c *ReleaseClient) Update() *ReleaseUpdate {
	mutation := newReleaseMutation(c.config, OpUpdate)
	return &ReleaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseClient) UpdateOne(r *Release) *ReleaseUpdateOne {
	mutation := newReleaseMutation(c.config, OpUpdateOne, withRelease(r))
	return &ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseClient) UpdateOneID(id int) *ReleaseUpdateOne {
	mutation := newReleaseMutation(c.config, OpUpdateOne, withReleaseID(id))
	return &ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Release.
func (c *ReleaseClient) Delete() *ReleaseDelete {
	mutation := newReleaseMutation(c.config, OpDelete)
	return &ReleaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReleaseClient) DeleteOne(r *Release) *ReleaseDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReleaseClient) DeleteOneID(id int) *ReleaseDeleteOne {
	builder := c.Delete().Where(release.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseDeleteOne{builder}
}

// Query returns a query builder for Release.
func (c *ReleaseClient) Query() *ReleaseQuery {
	return &ReleaseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRelease},
		inters: c.Interceptors(),
	}
}

// Get returns a Release entity by its id.
func (c *ReleaseClient) Get(ctx context.Context, id int) (*Release, error) {
	return c.Query().Where(release.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseClient) GetX(ctx context.Context, id int) *Release {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAgents queries the agents edge of a Release.
func (c *ReleaseClient) QueryAgents(r *Release) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, release.AgentsTable, release.AgentsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseClient) Hooks() []Hook {
	return c.hooks.Release
}

// Interceptors returns the client interceptors.
func (c *ReleaseClient) Interceptors() []Interceptor {
	return c.inters.Release
}

func (c *ReleaseClient) mutate(ctx context.Context, m *ReleaseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReleaseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReleaseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReleaseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Release mutation op: %q", m.Op())
	}
}

// RevocationClient is a client for the Revocation schema.
type RevocationClient struct {
	config
}

// NewRevocationClient returns a client for the Revocation from the given config.
func NewRevocationClient(c config) *RevocationClient {
	return &RevocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `revocation.Hooks(f(g(h())))`.
func (c *RevocationClient) Use(hooks ...Hook) {
	c.hooks.Revocation = append(c.hooks.Revocation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `revocation.Intercept(f(g(h())))`.
func (c *RevocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Revocation = append(c.inters.Revocation, interceptors...)
}

// Create returns a builder for creating a Revocation entity.
func (c *RevocationClient) Create() *RevocationCreate {
	mutation := newRevocationMutation(c.config, OpCreate)
	return &RevocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Revocation entities.
func (c *RevocationClient) CreateBulk(builders ...*RevocationCreate) *RevocationCreateBulk {
	return &RevocationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RevocationClient) MapCreateBulk(slice any, setFunc func(*RevocationCreate, int)) *RevocationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RevocationCreateBulk{err: fmt.Errorf("calling to RevocationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RevocationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RevocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Revocation.
func (c *RevocationClient) Update() *RevocationUpdate {
	mutation := newRevocationMutation(c.config, OpUpdate)
	return &RevocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RevocationClient) UpdateOne(r *Revocation) *RevocationUpdateOne {
	mutation := newRevocationMutation(c.config, OpUpdateOne, withRevocation(r))
	return &RevocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RevocationClient) UpdateOneID(id int64) *RevocationUpdateOne {
	mutation := newRevocationMutation(c.config, OpUpdateOne, withRevocationID(id))
	return &RevocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Revocation.
func (c *RevocationClient) Delete() *RevocationDelete {
	mutation := newRevocationMutation(c.config, OpDelete)
	return &RevocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RevocationClient) DeleteOne(r *Revocation) *RevocationDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RevocationClient) DeleteOneID(id int64) *RevocationDeleteOne {
	builder := c.Delete().Where(revocation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RevocationDeleteOne{builder}
}

// Query returns a query builder for Revocation.
func (c *RevocationClient) Query() *RevocationQuery {
	return &RevocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRevocation},
		inters: c.Interceptors(),
	}
}

// Get returns a Revocation entity by its id.
func (c *RevocationClient) Get(ctx context.Context, id int64) (*Revocation, error) {
	return c.Query().Where(revocation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RevocationClient) GetX(ctx context.Context, id int64) *Revocation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RevocationClient) Hooks() []Hook {
	return c.hooks.Revocation
}

// Interceptors returns the client interceptors.
func (c *RevocationClient) Interceptors() []Interceptor {
	return c.inters.Revocation
}

func (c *RevocationClient) mutate(ctx context.Context, m *RevocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RevocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RevocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RevocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RevocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Revocation mutation op: %q", m.Op())
	}
}

// RustdeskClient is a client for the Rustdesk schema.
type RustdeskClient struct {
	config
}

// NewRustdeskClient returns a client for the Rustdesk from the given config.
func NewRustdeskClient(c config) *RustdeskClient {
	return &RustdeskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rustdesk.Hooks(f(g(h())))`.
func (c *RustdeskClient) Use(hooks ...Hook) {
	c.hooks.Rustdesk = append(c.hooks.Rustdesk, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rustdesk.Intercept(f(g(h())))`.
func (c *RustdeskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Rustdesk = append(c.inters.Rustdesk, interceptors...)
}

// Create returns a builder for creating a Rustdesk entity.
func (c *RustdeskClient) Create() *RustdeskCreate {
	mutation := newRustdeskMutation(c.config, OpCreate)
	return &RustdeskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Rustdesk entities.
func (c *RustdeskClient) CreateBulk(builders ...*RustdeskCreate) *RustdeskCreateBulk {
	return &RustdeskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RustdeskClient) MapCreateBulk(slice any, setFunc func(*RustdeskCreate, int)) *RustdeskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RustdeskCreateBulk{err: fmt.Errorf("calling to RustdeskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RustdeskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RustdeskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Rustdesk.
func (c *RustdeskClient) Update() *RustdeskUpdate {
	mutation := newRustdeskMutation(c.config, OpUpdate)
	return &RustdeskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RustdeskClient) UpdateOne(r *Rustdesk) *RustdeskUpdateOne {
	mutation := newRustdeskMutation(c.config, OpUpdateOne, withRustdesk(r))
	return &RustdeskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RustdeskClient) UpdateOneID(id int) *RustdeskUpdateOne {
	mutation := newRustdeskMutation(c.config, OpUpdateOne, withRustdeskID(id))
	return &RustdeskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Rustdesk.
func (c *RustdeskClient) Delete() *RustdeskDelete {
	mutation := newRustdeskMutation(c.config, OpDelete)
	return &RustdeskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RustdeskClient) DeleteOne(r *Rustdesk) *RustdeskDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RustdeskClient) DeleteOneID(id int) *RustdeskDeleteOne {
	builder := c.Delete().Where(rustdesk.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RustdeskDeleteOne{builder}
}

// Query returns a query builder for Rustdesk.
func (c *RustdeskClient) Query() *RustdeskQuery {
	return &RustdeskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRustdesk},
		inters: c.Interceptors(),
	}
}

// Get returns a Rustdesk entity by its id.
func (c *RustdeskClient) Get(ctx context.Context, id int) (*Rustdesk, error) {
	return c.Query().Where(rustdesk.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RustdeskClient) GetX(ctx context.Context, id int) *Rustdesk {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Rustdesk.
func (c *RustdeskClient) QueryTenant(r *Rustdesk) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rustdesk.Table, rustdesk.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, rustdesk.TenantTable, rustdesk.TenantPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RustdeskClient) Hooks() []Hook {
	return c.hooks.Rustdesk
}

// Interceptors returns the client interceptors.
func (c *RustdeskClient) Interceptors() []Interceptor {
	return c.inters.Rustdesk
}

func (c *RustdeskClient) mutate(ctx context.Context, m *RustdeskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RustdeskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RustdeskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RustdeskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RustdeskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Rustdesk mutation op: %q", m.Op())
	}
}

// ServerClient is a client for the Server schema.
type ServerClient struct {
	config
}

// NewServerClient returns a client for the Server from the given config.
func NewServerClient(c config) *ServerClient {
	return &ServerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `server.Hooks(f(g(h())))`.
func (c *ServerClient) Use(hooks ...Hook) {
	c.hooks.Server = append(c.hooks.Server, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `server.Intercept(f(g(h())))`.
func (c *ServerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Server = append(c.inters.Server, interceptors...)
}

// Create returns a builder for creating a Server entity.
func (c *ServerClient) Create() *ServerCreate {
	mutation := newServerMutation(c.config, OpCreate)
	return &ServerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Server entities.
func (c *ServerClient) CreateBulk(builders ...*ServerCreate) *ServerCreateBulk {
	return &ServerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServerClient) MapCreateBulk(slice any, setFunc func(*ServerCreate, int)) *ServerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServerCreateBulk{err: fmt.Errorf("calling to ServerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Server.
func (c *ServerClient) Update() *ServerUpdate {
	mutation := newServerMutation(c.config, OpUpdate)
	return &ServerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServerClient) UpdateOne(s *Server) *ServerUpdateOne {
	mutation := newServerMutation(c.config, OpUpdateOne, withServer(s))
	return &ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServerClient) UpdateOneID(id int) *ServerUpdateOne {
	mutation := newServerMutation(c.config, OpUpdateOne, withServerID(id))
	return &ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Server.
func (c *ServerClient) Delete() *ServerDelete {
	mutation := newServerMutation(c.config, OpDelete)
	return &ServerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServerClient) DeleteOne(s *Server) *ServerDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServerClient) DeleteOneID(id int) *ServerDeleteOne {
	builder := c.Delete().Where(server.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServerDeleteOne{builder}
}

// Query returns a query builder for Server.
func (c *ServerClient) Query() *ServerQuery {
	return &ServerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServer},
		inters: c.Interceptors(),
	}
}

// Get returns a Server entity by its id.
func (c *ServerClient) Get(ctx context.Context, id int) (*Server, error) {
	return c.Query().Where(server.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServerClient) GetX(ctx context.Context, id int) *Server {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ServerClient) Hooks() []Hook {
	return c.hooks.Server
}

// Interceptors returns the client interceptors.
func (c *ServerClient) Interceptors() []Interceptor {
	return c.inters.Server
}

func (c *ServerClient) mutate(ctx context.Context, m *ServerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Server mutation op: %q", m.Op())
	}
}

// SessionsClient is a client for the Sessions schema.
type SessionsClient struct {
	config
}

// NewSessionsClient returns a client for the Sessions from the given config.
func NewSessionsClient(c config) *SessionsClient {
	return &SessionsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sessions.Hooks(f(g(h())))`.
func (c *SessionsClient) Use(hooks ...Hook) {
	c.hooks.Sessions = append(c.hooks.Sessions, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sessions.Intercept(f(g(h())))`.
func (c *SessionsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Sessions = append(c.inters.Sessions, interceptors...)
}

// Create returns a builder for creating a Sessions entity.
func (c *SessionsClient) Create() *SessionsCreate {
	mutation := newSessionsMutation(c.config, OpCreate)
	return &SessionsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Sessions entities.
func (c *SessionsClient) CreateBulk(builders ...*SessionsCreate) *SessionsCreateBulk {
	return &SessionsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionsClient) MapCreateBulk(slice any, setFunc func(*SessionsCreate, int)) *SessionsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionsCreateBulk{err: fmt.Errorf("calling to SessionsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Sessions.
func (c *SessionsClient) Update() *SessionsUpdate {
	mutation := newSessionsMutation(c.config, OpUpdate)
	return &SessionsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionsClient) UpdateOne(s *Sessions) *SessionsUpdateOne {
	mutation := newSessionsMutation(c.config, OpUpdateOne, withSessions(s))
	return &SessionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionsClient) UpdateOneID(id string) *SessionsUpdateOne {
	mutation := newSessionsMutation(c.config, OpUpdateOne, withSessionsID(id))
	return &SessionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Sessions.
func (c *SessionsClient) Delete() *SessionsDelete {
	mutation := newSessionsMutation(c.config, OpDelete)
	return &SessionsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionsClient) DeleteOne(s *Sessions) *SessionsDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionsClient) DeleteOneID(id string) *SessionsDeleteOne {
	builder := c.Delete().Where(sessions.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionsDeleteOne{builder}
}

// Query returns a query builder for Sessions.
func (c *SessionsClient) Query() *SessionsQuery {
	return &SessionsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSessions},
		inters: c.Interceptors(),
	}
}

// Get returns a Sessions entity by its id.
func (c *SessionsClient) Get(ctx context.Context, id string) (*Sessions, error) {
	return c.Query().Where(sessions.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionsClient) GetX(ctx context.Context, id string) *Sessions {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Sessions.
func (c *SessionsClient) QueryOwner(s *Sessions) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sessions.Table, sessions.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sessions.OwnerTable, sessions.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionsClient) Hooks() []Hook {
	return c.hooks.Sessions
}

// Interceptors returns the client interceptors.
func (c *SessionsClient) Interceptors() []Interceptor {
	return c.inters.Sessions
}

func (c *SessionsClient) mutate(ctx context.Context, m *SessionsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Sessions mutation op: %q", m.Op())
	}
}

// SettingsClient is a client for the Settings schema.
type SettingsClient struct {
	config
}

// NewSettingsClient returns a client for the Settings from the given config.
func NewSettingsClient(c config) *SettingsClient {
	return &SettingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `settings.Hooks(f(g(h())))`.
func (c *SettingsClient) Use(hooks ...Hook) {
	c.hooks.Settings = append(c.hooks.Settings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `settings.Intercept(f(g(h())))`.
func (c *SettingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Settings = append(c.inters.Settings, interceptors...)
}

// Create returns a builder for creating a Settings entity.
func (c *SettingsClient) Create() *SettingsCreate {
	mutation := newSettingsMutation(c.config, OpCreate)
	return &SettingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Settings entities.
func (c *SettingsClient) CreateBulk(builders ...*SettingsCreate) *SettingsCreateBulk {
	return &SettingsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SettingsClient) MapCreateBulk(slice any, setFunc func(*SettingsCreate, int)) *SettingsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SettingsCreateBulk{err: fmt.Errorf("calling to SettingsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SettingsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SettingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Settings.
func (c *SettingsClient) Update() *SettingsUpdate {
	mutation := newSettingsMutation(c.config, OpUpdate)
	return &SettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettingsClient) UpdateOne(s *Settings) *SettingsUpdateOne {
	mutation := newSettingsMutation(c.config, OpUpdateOne, withSettings(s))
	return &SettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettingsClient) UpdateOneID(id int) *SettingsUpdateOne {
	mutation := newSettingsMutation(c.config, OpUpdateOne, withSettingsID(id))
	return &SettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Settings.
func (c *SettingsClient) Delete() *SettingsDelete {
	mutation := newSettingsMutation(c.config, OpDelete)
	return &SettingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettingsClient) DeleteOne(s *Settings) *SettingsDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettingsClient) DeleteOneID(id int) *SettingsDeleteOne {
	builder := c.Delete().Where(settings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettingsDeleteOne{builder}
}

// Query returns a query builder for Settings.
func (c *SettingsClient) Query() *SettingsQuery {
	return &SettingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSettings},
		inters: c.Interceptors(),
	}
}

// Get returns a Settings entity by its id.
func (c *SettingsClient) Get(ctx context.Context, id int) (*Settings, error) {
	return c.Query().Where(settings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettingsClient) GetX(ctx context.Context, id int) *Settings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTag queries the tag edge of a Settings.
func (c *SettingsClient) QueryTag(s *Settings) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(settings.Table, settings.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, settings.TagTable, settings.TagColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a Settings.
func (c *SettingsClient) QueryTenant(s *Settings) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(settings.Table, settings.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, settings.TenantTable, settings.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SettingsClient) Hooks() []Hook {
	return c.hooks.Settings
}

// Interceptors returns the client interceptors.
func (c *SettingsClient) Interceptors() []Interceptor {
	return c.inters.Settings
}

func (c *SettingsClient) mutate(ctx context.Context, m *SettingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SettingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SettingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Settings mutation op: %q", m.Op())
	}
}

// ShareClient is a client for the Share schema.
type ShareClient struct {
	config
}

// NewShareClient returns a client for the Share from the given config.
func NewShareClient(c config) *ShareClient {
	return &ShareClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `share.Hooks(f(g(h())))`.
func (c *ShareClient) Use(hooks ...Hook) {
	c.hooks.Share = append(c.hooks.Share, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `share.Intercept(f(g(h())))`.
func (c *ShareClient) Intercept(interceptors ...Interceptor) {
	c.inters.Share = append(c.inters.Share, interceptors...)
}

// Create returns a builder for creating a Share entity.
func (c *ShareClient) Create() *ShareCreate {
	mutation := newShareMutation(c.config, OpCreate)
	return &ShareCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Share entities.
func (c *ShareClient) CreateBulk(builders ...*ShareCreate) *ShareCreateBulk {
	return &ShareCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ShareClient) MapCreateBulk(slice any, setFunc func(*ShareCreate, int)) *ShareCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ShareCreateBulk{err: fmt.Errorf("calling to ShareClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ShareCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ShareCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Share.
func (c *ShareClient) Update() *ShareUpdate {
	mutation := newShareMutation(c.config, OpUpdate)
	return &ShareUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ShareClient) UpdateOne(s *Share) *ShareUpdateOne {
	mutation := newShareMutation(c.config, OpUpdateOne, withShare(s))
	return &ShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ShareClient) UpdateOneID(id int) *ShareUpdateOne {
	mutation := newShareMutation(c.config, OpUpdateOne, withShareID(id))
	return &ShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Share.
func (c *ShareClient) Delete() *ShareDelete {
	mutation := newShareMutation(c.config, OpDelete)
	return &ShareDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ShareClient) DeleteOne(s *Share) *ShareDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ShareClient) DeleteOneID(id int) *ShareDeleteOne {
	builder := c.Delete().Where(share.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ShareDeleteOne{builder}
}

// Query returns a query builder for Share.
func (c *ShareClient) Query() *ShareQuery {
	return &ShareQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeShare},
		inters: c.Interceptors(),
	}
}

// Get returns a Share entity by its id.
func (c *ShareClient) Get(ctx context.Context, id int) (*Share, error) {
	return c.Query().Where(share.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ShareClient) GetX(ctx context.Context, id int) *Share {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Share.
func (c *ShareClient) QueryOwner(s *Share) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(share.Table, share.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, share.OwnerTable, share.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ShareClient) Hooks() []Hook {
	return c.hooks.Share
}

// Interceptors returns the client interceptors.
func (c *ShareClient) Interceptors() []Interceptor {
	return c.inters.Share
}

func (c *ShareClient) mutate(ctx context.Context, m *ShareMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ShareCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ShareUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ShareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ShareDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Share mutation op: %q", m.Op())
	}
}

// SiteClient is a client for the Site schema.
type SiteClient struct {
	config
}

// NewSiteClient returns a client for the Site from the given config.
func NewSiteClient(c config) *SiteClient {
	return &SiteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `site.Hooks(f(g(h())))`.
func (c *SiteClient) Use(hooks ...Hook) {
	c.hooks.Site = append(c.hooks.Site, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `site.Intercept(f(g(h())))`.
func (c *SiteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Site = append(c.inters.Site, interceptors...)
}

// Create returns a builder for creating a Site entity.
func (c *SiteClient) Create() *SiteCreate {
	mutation := newSiteMutation(c.config, OpCreate)
	return &SiteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Site entities.
func (c *SiteClient) CreateBulk(builders ...*SiteCreate) *SiteCreateBulk {
	return &SiteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SiteClient) MapCreateBulk(slice any, setFunc func(*SiteCreate, int)) *SiteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SiteCreateBulk{err: fmt.Errorf("calling to SiteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SiteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SiteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Site.
func (c *SiteClient) Update() *SiteUpdate {
	mutation := newSiteMutation(c.config, OpUpdate)
	return &SiteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SiteClient) UpdateOne(s *Site) *SiteUpdateOne {
	mutation := newSiteMutation(c.config, OpUpdateOne, withSite(s))
	return &SiteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SiteClient) UpdateOneID(id int) *SiteUpdateOne {
	mutation := newSiteMutation(c.config, OpUpdateOne, withSiteID(id))
	return &SiteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Site.
func (c *SiteClient) Delete() *SiteDelete {
	mutation := newSiteMutation(c.config, OpDelete)
	return &SiteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SiteClient) DeleteOne(s *Site) *SiteDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SiteClient) DeleteOneID(id int) *SiteDeleteOne {
	builder := c.Delete().Where(site.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SiteDeleteOne{builder}
}

// Query returns a query builder for Site.
func (c *SiteClient) Query() *SiteQuery {
	return &SiteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSite},
		inters: c.Interceptors(),
	}
}

// Get returns a Site entity by its id.
func (c *SiteClient) Get(ctx context.Context, id int) (*Site, error) {
	return c.Query().Where(site.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SiteClient) GetX(ctx context.Context, id int) *Site {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenant queries the tenant edge of a Site.
func (c *SiteClient) QueryTenant(s *Site) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(site.Table, site.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, site.TenantTable, site.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgents queries the agents edge of a Site.
func (c *SiteClient) QueryAgents(s *Site) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(site.Table, site.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, site.AgentsTable, site.AgentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfiles queries the profiles edge of a Site.
func (c *SiteClient) QueryProfiles(s *Site) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(site.Table, site.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, site.ProfilesTable, site.ProfilesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SiteClient) Hooks() []Hook {
	return c.hooks.Site
}

// Interceptors returns the client interceptors.
func (c *SiteClient) Interceptors() []Interceptor {
	return c.inters.Site
}

func (c *SiteClient) mutate(ctx context.Context, m *SiteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SiteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SiteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SiteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SiteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Site mutation op: %q", m.Op())
	}
}

// SystemUpdateClient is a client for the SystemUpdate schema.
type SystemUpdateClient struct {
	config
}

// NewSystemUpdateClient returns a client for the SystemUpdate from the given config.
func NewSystemUpdateClient(c config) *SystemUpdateClient {
	return &SystemUpdateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemupdate.Hooks(f(g(h())))`.
func (c *SystemUpdateClient) Use(hooks ...Hook) {
	c.hooks.SystemUpdate = append(c.hooks.SystemUpdate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemupdate.Intercept(f(g(h())))`.
func (c *SystemUpdateClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemUpdate = append(c.inters.SystemUpdate, interceptors...)
}

// Create returns a builder for creating a SystemUpdate entity.
func (c *SystemUpdateClient) Create() *SystemUpdateCreate {
	mutation := newSystemUpdateMutation(c.config, OpCreate)
	return &SystemUpdateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemUpdate entities.
func (c *SystemUpdateClient) CreateBulk(builders ...*SystemUpdateCreate) *SystemUpdateCreateBulk {
	return &SystemUpdateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemUpdateClient) MapCreateBulk(slice any, setFunc func(*SystemUpdateCreate, int)) *SystemUpdateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemUpdateCreateBulk{err: fmt.Errorf("calling to SystemUpdateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemUpdateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemUpdateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemUpdate.
func (c *SystemUpdateClient) Update() *SystemUpdateUpdate {
	mutation := newSystemUpdateMutation(c.config, OpUpdate)
	return &SystemUpdateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemUpdateClient) UpdateOne(su *SystemUpdate) *SystemUpdateUpdateOne {
	mutation := newSystemUpdateMutation(c.config, OpUpdateOne, withSystemUpdate(su))
	return &SystemUpdateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemUpdateClient) UpdateOneID(id int) *SystemUpdateUpdateOne {
	mutation := newSystemUpdateMutation(c.config, OpUpdateOne, withSystemUpdateID(id))
	return &SystemUpdateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemUpdate.
func (c *SystemUpdateClient) Delete() *SystemUpdateDelete {
	mutation := newSystemUpdateMutation(c.config, OpDelete)
	return &SystemUpdateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemUpdateClient) DeleteOne(su *SystemUpdate) *SystemUpdateDeleteOne {
	return c.DeleteOneID(su.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemUpdateClient) DeleteOneID(id int) *SystemUpdateDeleteOne {
	builder := c.Delete().Where(systemupdate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemUpdateDeleteOne{builder}
}

// Query returns a query builder for SystemUpdate.
func (c *SystemUpdateClient) Query() *SystemUpdateQuery {
	return &SystemUpdateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemUpdate},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemUpdate entity by its id.
func (c *SystemUpdateClient) Get(ctx context.Context, id int) (*SystemUpdate, error) {
	return c.Query().Where(systemupdate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemUpdateClient) GetX(ctx context.Context, id int) *SystemUpdate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a SystemUpdate.
func (c *SystemUpdateClient) QueryOwner(su *SystemUpdate) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := su.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(systemupdate.Table, systemupdate.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, systemupdate.OwnerTable, systemupdate.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(su.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SystemUpdateClient) Hooks() []Hook {
	return c.hooks.SystemUpdate
}

// Interceptors returns the client interceptors.
func (c *SystemUpdateClient) Interceptors() []Interceptor {
	return c.inters.SystemUpdate
}

func (c *SystemUpdateClient) mutate(ctx context.Context, m *SystemUpdateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemUpdateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemUpdateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemUpdateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemUpdateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemUpdate mutation op: %q", m.Op())
	}
}

// TagClient is a client for the Tag schema.
type TagClient struct {
	config
}

// NewTagClient returns a client for the Tag from the given config.
func NewTagClient(c config) *TagClient {
	return &TagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tag.Hooks(f(g(h())))`.
func (c *TagClient) Use(hooks ...Hook) {
	c.hooks.Tag = append(c.hooks.Tag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tag.Intercept(f(g(h())))`.
func (c *TagClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tag = append(c.inters.Tag, interceptors...)
}

// Create returns a builder for creating a Tag entity.
func (c *TagClient) Create() *TagCreate {
	mutation := newTagMutation(c.config, OpCreate)
	return &TagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tag entities.
func (c *TagClient) CreateBulk(builders ...*TagCreate) *TagCreateBulk {
	return &TagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TagClient) MapCreateBulk(slice any, setFunc func(*TagCreate, int)) *TagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TagCreateBulk{err: fmt.Errorf("calling to TagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tag.
func (c *TagClient) Update() *TagUpdate {
	mutation := newTagMutation(c.config, OpUpdate)
	return &TagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TagClient) UpdateOne(t *Tag) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTag(t))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TagClient) UpdateOneID(id int) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTagID(id))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tag.
func (c *TagClient) Delete() *TagDelete {
	mutation := newTagMutation(c.config, OpDelete)
	return &TagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TagClient) DeleteOne(t *Tag) *TagDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TagClient) DeleteOneID(id int) *TagDeleteOne {
	builder := c.Delete().Where(tag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TagDeleteOne{builder}
}

// Query returns a query builder for Tag.
func (c *TagClient) Query() *TagQuery {
	return &TagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTag},
		inters: c.Interceptors(),
	}
}

// Get returns a Tag entity by its id.
func (c *TagClient) Get(ctx context.Context, id int) (*Tag, error) {
	return c.Query().Where(tag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TagClient) GetX(ctx context.Context, id int) *Tag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Tag.
func (c *TagClient) QueryOwner(t *Tag) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, tag.OwnerTable, tag.OwnerPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Tag.
func (c *TagClient) QueryParent(t *Tag) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tag.ParentTable, tag.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Tag.
func (c *TagClient) QueryChildren(t *Tag) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tag.ChildrenTable, tag.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfile queries the profile edge of a Tag.
func (c *TagClient) QueryProfile(t *Tag) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, tag.ProfileTable, tag.ProfilePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenant queries the tenant edge of a Tag.
func (c *TagClient) QueryTenant(t *Tag) *TenantQuery {
	query := (&TenantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tag.TenantTable, tag.TenantColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TagClient) Hooks() []Hook {
	return c.hooks.Tag
}

// Interceptors returns the client interceptors.
func (c *TagClient) Interceptors() []Interceptor {
	return c.inters.Tag
}

func (c *TagClient) mutate(ctx context.Context, m *TagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tag mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id int) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id int) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id int) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id int) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTags queries the tags edge of a Task.
func (c *TaskClient) QueryTags(t *Task) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, task.TagsTable, task.TagsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfile queries the profile edge of a Task.
func (c *TaskClient) QueryProfile(t *Task) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.ProfileTable, task.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReports queries the reports edge of a Task.
func (c *TaskClient) QueryReports(t *Task) *TaskReportQuery {
	query := (&TaskReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(taskreport.Table, taskreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, task.ReportsTable, task.ReportsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	return c.hooks.Task
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	return c.inters.Task
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())
	}
}

// TaskReportClient is a client for the TaskReport schema.
type TaskReportClient struct {
	config
}

// NewTaskReportClient returns a client for the TaskReport from the given config.
func NewTaskReportClient(c config) *TaskReportClient {
	return &TaskReportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `taskreport.Hooks(f(g(h())))`.
func (c *TaskReportClient) Use(hooks ...Hook) {
	c.hooks.TaskReport = append(c.hooks.TaskReport, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `taskreport.Intercept(f(g(h())))`.
func (c *TaskReportClient) Intercept(interceptors ...Interceptor) {
	c.inters.TaskReport = append(c.inters.TaskReport, interceptors...)
}

// Create returns a builder for creating a TaskReport entity.
func (c *TaskReportClient) Create() *TaskReportCreate {
	mutation := newTaskReportMutation(c.config, OpCreate)
	return &TaskReportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TaskReport entities.
func (c *TaskReportClient) CreateBulk(builders ...*TaskReportCreate) *TaskReportCreateBulk {
	return &TaskReportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskReportClient) MapCreateBulk(slice any, setFunc func(*TaskReportCreate, int)) *TaskReportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskReportCreateBulk{err: fmt.Errorf("calling to TaskReportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskReportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskReportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TaskReport.
func (c *TaskReportClient) Update() *TaskReportUpdate {
	mutation := newTaskReportMutation(c.config, OpUpdate)
	return &TaskReportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskReportClient) UpdateOne(tr *TaskReport) *TaskReportUpdateOne {
	mutation := newTaskReportMutation(c.config, OpUpdateOne, withTaskReport(tr))
	return &TaskReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskReportClient) UpdateOneID(id int) *TaskReportUpdateOne {
	mutation := newTaskReportMutation(c.config, OpUpdateOne, withTaskReportID(id))
	return &TaskReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TaskReport.
func (c *TaskReportClient) Delete() *TaskReportDelete {
	mutation := newTaskReportMutation(c.config, OpDelete)
	return &TaskReportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskReportClient) DeleteOne(tr *TaskReport) *TaskReportDeleteOne {
	return c.DeleteOneID(tr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskReportClient) DeleteOneID(id int) *TaskReportDeleteOne {
	builder := c.Delete().Where(taskreport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskReportDeleteOne{builder}
}

// Query returns a query builder for TaskReport.
func (c *TaskReportClient) Query() *TaskReportQuery {
	return &TaskReportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTaskReport},
		inters: c.Interceptors(),
	}
}

// Get returns a TaskReport entity by its id.
func (c *TaskReportClient) Get(ctx context.Context, id int) (*TaskReport, error) {
	return c.Query().Where(taskreport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskReportClient) GetX(ctx context.Context, id int) *TaskReport {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfileissue queries the profileissue edge of a TaskReport.
func (c *TaskReportClient) QueryProfileissue(tr *TaskReport) *ProfileIssueQuery {
	query := (&ProfileIssueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(taskreport.Table, taskreport.FieldID, id),
			sqlgraph.To(profileissue.Table, profileissue.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, taskreport.ProfileissueTable, taskreport.ProfileissueColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTask queries the task edge of a TaskReport.
func (c *TaskReportClient) QueryTask(tr *TaskReport) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(taskreport.Table, taskreport.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, taskreport.TaskTable, taskreport.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskReportClient) Hooks() []Hook {
	return c.hooks.TaskReport
}

// Interceptors returns the client interceptors.
func (c *TaskReportClient) Interceptors() []Interceptor {
	return c.inters.TaskReport
}

func (c *TaskReportClient) mutate(ctx context.Context, m *TaskReportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskReportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskReportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskReportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TaskReport mutation op: %q", m.Op())
	}
}

// TenantClient is a client for the Tenant schema.
type TenantClient struct {
	config
}

// NewTenantClient returns a client for the Tenant from the given config.
func NewTenantClient(c config) *TenantClient {
	return &TenantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tenant.Hooks(f(g(h())))`.
func (c *TenantClient) Use(hooks ...Hook) {
	c.hooks.Tenant = append(c.hooks.Tenant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tenant.Intercept(f(g(h())))`.
func (c *TenantClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tenant = append(c.inters.Tenant, interceptors...)
}

// Create returns a builder for creating a Tenant entity.
func (c *TenantClient) Create() *TenantCreate {
	mutation := newTenantMutation(c.config, OpCreate)
	return &TenantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tenant entities.
func (c *TenantClient) CreateBulk(builders ...*TenantCreate) *TenantCreateBulk {
	return &TenantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TenantClient) MapCreateBulk(slice any, setFunc func(*TenantCreate, int)) *TenantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TenantCreateBulk{err: fmt.Errorf("calling to TenantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TenantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TenantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tenant.
func (c *TenantClient) Update() *TenantUpdate {
	mutation := newTenantMutation(c.config, OpUpdate)
	return &TenantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TenantClient) UpdateOne(t *Tenant) *TenantUpdateOne {
	mutation := newTenantMutation(c.config, OpUpdateOne, withTenant(t))
	return &TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TenantClient) UpdateOneID(id int) *TenantUpdateOne {
	mutation := newTenantMutation(c.config, OpUpdateOne, withTenantID(id))
	return &TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tenant.
func (c *TenantClient) Delete() *TenantDelete {
	mutation := newTenantMutation(c.config, OpDelete)
	return &TenantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TenantClient) DeleteOne(t *Tenant) *TenantDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TenantClient) DeleteOneID(id int) *TenantDeleteOne {
	builder := c.Delete().Where(tenant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TenantDeleteOne{builder}
}

// Query returns a query builder for Tenant.
func (c *TenantClient) Query() *TenantQuery {
	return &TenantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTenant},
		inters: c.Interceptors(),
	}
}

// Get returns a Tenant entity by its id.
func (c *TenantClient) Get(ctx context.Context, id int) (*Tenant, error) {
	return c.Query().Where(tenant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TenantClient) GetX(ctx context.Context, id int) *Tenant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySites queries the sites edge of a Tenant.
func (c *TenantClient) QuerySites(t *Tenant) *SiteQuery {
	query := (&SiteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(site.Table, site.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.SitesTable, tenant.SitesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySettings queries the settings edge of a Tenant.
func (c *TenantClient) QuerySettings(t *Tenant) *SettingsQuery {
	query := (&SettingsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(settings.Table, settings.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, tenant.SettingsTable, tenant.SettingsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a Tenant.
func (c *TenantClient) QueryTags(t *Tenant) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.TagsTable, tenant.TagsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetadata queries the metadata edge of a Tenant.
func (c *TenantClient) QueryMetadata(t *Tenant) *OrgMetadataQuery {
	query := (&OrgMetadataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(orgmetadata.Table, orgmetadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tenant.MetadataTable, tenant.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRustdesk queries the rustdesk edge of a Tenant.
func (c *TenantClient) QueryRustdesk(t *Tenant) *RustdeskQuery {
	query := (&RustdeskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(rustdesk.Table, rustdesk.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, tenant.RustdeskTable, tenant.RustdeskPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetbird queries the netbird edge of a Tenant.
func (c *TenantClient) QueryNetbird(t *Tenant) *NetbirdSettingsQuery {
	query := (&NetbirdSettingsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenant.Table, tenant.FieldID, id),
			sqlgraph.To(netbirdsettings.Table, netbirdsettings.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tenant.NetbirdTable, tenant.NetbirdColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TenantClient) Hooks() []Hook {
	return c.hooks.Tenant
}

// Interceptors returns the client interceptors.
func (c *TenantClient) Interceptors() []Interceptor {
	return c.inters.Tenant
}

func (c *TenantClient) mutate(ctx context.Context, m *TenantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TenantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TenantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TenantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TenantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tenant mutation op: %q", m.Op())
	}
}

// UpdateClient is a client for the Update schema.
type UpdateClient struct {
	config
}

// NewUpdateClient returns a client for the Update from the given config.
func NewUpdateClient(c config) *UpdateClient {
	return &UpdateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `update.Hooks(f(g(h())))`.
func (c *UpdateClient) Use(hooks ...Hook) {
	c.hooks.Update = append(c.hooks.Update, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `update.Intercept(f(g(h())))`.
func (c *UpdateClient) Intercept(interceptors ...Interceptor) {
	c.inters.Update = append(c.inters.Update, interceptors...)
}

// Create returns a builder for creating a Update entity.
func (c *UpdateClient) Create() *UpdateCreate {
	mutation := newUpdateMutation(c.config, OpCreate)
	return &UpdateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Update entities.
func (c *UpdateClient) CreateBulk(builders ...*UpdateCreate) *UpdateCreateBulk {
	return &UpdateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UpdateClient) MapCreateBulk(slice any, setFunc func(*UpdateCreate, int)) *UpdateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UpdateCreateBulk{err: fmt.Errorf("calling to UpdateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UpdateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UpdateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Update.
func (c *UpdateClient) Update() *UpdateUpdate {
	mutation := newUpdateMutation(c.config, OpUpdate)
	return &UpdateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UpdateClient) UpdateOne(u *Update) *UpdateUpdateOne {
	mutation := newUpdateMutation(c.config, OpUpdateOne, withUpdate(u))
	return &UpdateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UpdateClient) UpdateOneID(id int) *UpdateUpdateOne {
	mutation := newUpdateMutation(c.config, OpUpdateOne, withUpdateID(id))
	return &UpdateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Update.
func (c *UpdateClient) Delete() *UpdateDelete {
	mutation := newUpdateMutation(c.config, OpDelete)
	return &UpdateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UpdateClient) DeleteOne(u *Update) *UpdateDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UpdateClient) DeleteOneID(id int) *UpdateDeleteOne {
	builder := c.Delete().Where(update.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UpdateDeleteOne{builder}
}

// Query returns a query builder for Update.
func (c *UpdateClient) Query() *UpdateQuery {
	return &UpdateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUpdate},
		inters: c.Interceptors(),
	}
}

// Get returns a Update entity by its id.
func (c *UpdateClient) Get(ctx context.Context, id int) (*Update, error) {
	return c.Query().Where(update.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UpdateClient) GetX(ctx context.Context, id int) *Update {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Update.
func (c *UpdateClient) QueryOwner(u *Update) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(update.Table, update.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, update.OwnerTable, update.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UpdateClient) Hooks() []Hook {
	return c.hooks.Update
}

// Interceptors returns the client interceptors.
func (c *UpdateClient) Interceptors() []Interceptor {
	return c.inters.Update
}

func (c *UpdateClient) mutate(ctx context.Context, m *UpdateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UpdateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UpdateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UpdateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UpdateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Update mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(u *User) *SessionsQuery {
	query := (&SessionsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(sessions.Table, sessions.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionsTable, user.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecoverycodes queries the recoverycodes edge of a User.
func (c *UserClient) QueryRecoverycodes(u *User) *RecoveryCodeQuery {
	query := (&RecoveryCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(recoverycode.Table, recoverycode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.RecoverycodesTable, user.RecoverycodesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// WingetConfigExclusionClient is a client for the WingetConfigExclusion schema.
type WingetConfigExclusionClient struct {
	config
}

// NewWingetConfigExclusionClient returns a client for the WingetConfigExclusion from the given config.
func NewWingetConfigExclusionClient(c config) *WingetConfigExclusionClient {
	return &WingetConfigExclusionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wingetconfigexclusion.Hooks(f(g(h())))`.
func (c *WingetConfigExclusionClient) Use(hooks ...Hook) {
	c.hooks.WingetConfigExclusion = append(c.hooks.WingetConfigExclusion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `wingetconfigexclusion.Intercept(f(g(h())))`.
func (c *WingetConfigExclusionClient) Intercept(interceptors ...Interceptor) {
	c.inters.WingetConfigExclusion = append(c.inters.WingetConfigExclusion, interceptors...)
}

// Create returns a builder for creating a WingetConfigExclusion entity.
func (c *WingetConfigExclusionClient) Create() *WingetConfigExclusionCreate {
	mutation := newWingetConfigExclusionMutation(c.config, OpCreate)
	return &WingetConfigExclusionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WingetConfigExclusion entities.
func (c *WingetConfigExclusionClient) CreateBulk(builders ...*WingetConfigExclusionCreate) *WingetConfigExclusionCreateBulk {
	return &WingetConfigExclusionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WingetConfigExclusionClient) MapCreateBulk(slice any, setFunc func(*WingetConfigExclusionCreate, int)) *WingetConfigExclusionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WingetConfigExclusionCreateBulk{err: fmt.Errorf("calling to WingetConfigExclusionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WingetConfigExclusionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WingetConfigExclusionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WingetConfigExclusion.
func (c *WingetConfigExclusionClient) Update() *WingetConfigExclusionUpdate {
	mutation := newWingetConfigExclusionMutation(c.config, OpUpdate)
	return &WingetConfigExclusionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WingetConfigExclusionClient) UpdateOne(wce *WingetConfigExclusion) *WingetConfigExclusionUpdateOne {
	mutation := newWingetConfigExclusionMutation(c.config, OpUpdateOne, withWingetConfigExclusion(wce))
	return &WingetConfigExclusionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WingetConfigExclusionClient) UpdateOneID(id int) *WingetConfigExclusionUpdateOne {
	mutation := newWingetConfigExclusionMutation(c.config, OpUpdateOne, withWingetConfigExclusionID(id))
	return &WingetConfigExclusionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WingetConfigExclusion.
func (c *WingetConfigExclusionClient) Delete() *WingetConfigExclusionDelete {
	mutation := newWingetConfigExclusionMutation(c.config, OpDelete)
	return &WingetConfigExclusionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WingetConfigExclusionClient) DeleteOne(wce *WingetConfigExclusion) *WingetConfigExclusionDeleteOne {
	return c.DeleteOneID(wce.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WingetConfigExclusionClient) DeleteOneID(id int) *WingetConfigExclusionDeleteOne {
	builder := c.Delete().Where(wingetconfigexclusion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WingetConfigExclusionDeleteOne{builder}
}

// Query returns a query builder for WingetConfigExclusion.
func (c *WingetConfigExclusionClient) Query() *WingetConfigExclusionQuery {
	return &WingetConfigExclusionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWingetConfigExclusion},
		inters: c.Interceptors(),
	}
}

// Get returns a WingetConfigExclusion entity by its id.
func (c *WingetConfigExclusionClient) Get(ctx context.Context, id int) (*WingetConfigExclusion, error) {
	return c.Query().Where(wingetconfigexclusion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WingetConfigExclusionClient) GetX(ctx context.Context, id int) *WingetConfigExclusion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a WingetConfigExclusion.
func (c *WingetConfigExclusionClient) QueryOwner(wce *WingetConfigExclusion) *AgentQuery {
	query := (&AgentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(wingetconfigexclusion.Table, wingetconfigexclusion.FieldID, id),
			sqlgraph.To(agent.Table, agent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, wingetconfigexclusion.OwnerTable, wingetconfigexclusion.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(wce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WingetConfigExclusionClient) Hooks() []Hook {
	return c.hooks.WingetConfigExclusion
}

// Interceptors returns the client interceptors.
func (c *WingetConfigExclusionClient) Interceptors() []Interceptor {
	return c.inters.WingetConfigExclusion
}

func (c *WingetConfigExclusionClient) mutate(ctx context.Context, m *WingetConfigExclusionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WingetConfigExclusionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WingetConfigExclusionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WingetConfigExclusionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WingetConfigExclusionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WingetConfigExclusion mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Agent, Antivirus, App, Authentication, Certificate, Computer, Deployment,
		LogicalDisk, MemorySlot, Metadata, Monitor, Netbird, NetbirdSettings,
		NetworkAdapter, OperatingSystem, OrgMetadata, PhysicalDisk, Printer, Profile,
		ProfileIssue, RecoveryCode, Release, Revocation, Rustdesk, Server, Sessions,
		Settings, Share, Site, SystemUpdate, Tag, Task, TaskReport, Tenant, Update,
		User, WingetConfigExclusion []ent.Hook
	}
	inters struct {
		Agent, Antivirus, App, Authentication, Certificate, Computer, Deployment,
		LogicalDisk, MemorySlot, Metadata, Monitor, Netbird, NetbirdSettings,
		NetworkAdapter, OperatingSystem, OrgMetadata, PhysicalDisk, Printer, Profile,
		ProfileIssue, RecoveryCode, Release, Revocation, Rustdesk, Server, Sessions,
		Settings, Share, Site, SystemUpdate, Tag, Task, TaskReport, Tenant, Update,
		User, WingetConfigExclusion []ent.Interceptor
	}
)
